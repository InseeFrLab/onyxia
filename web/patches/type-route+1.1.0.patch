diff --git a/node_modules/type-route/core/index.d.ts b/node_modules/type-route/core/index.d.ts
index 6fc2dab..2353808 100644
--- a/node_modules/type-route/core/index.d.ts
+++ b/node_modules/type-route/core/index.d.ts
@@ -372,6 +372,8 @@ declare type CoreRouter<TRouteDefCollection extends {
         [TRouteName in keyof TRouteDefCollection]: RouteBuilder<TRouteName, TRouteDefCollection[TRouteName]["~internal"]["params"]>;
     };
     session: RouterSession<TRouteDefCollection>;
+    stopListening: () => void;
+    getRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;
 };
 declare type RouteGroup<T extends any[] = any[]> = {
     ["~internal"]: {
@@ -1490,6 +1492,9 @@ declare const param: {
 };
 
 declare function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;
+declare function createGroup<TRouteDefCollection extends {
+    [routeName: string]: any;
+}>(routeDefs: TRouteDefCollection): RouteGroup<CoreRouter<TRouteDefCollection>["routes"][keyof TRouteDefCollection][]>;
 
 declare function preventDefaultLinkClickBehavior(event?: any): boolean;
 
diff --git a/node_modules/type-route/core/tools/UnionToIntersection.d.ts b/node_modules/type-route/core/tools/UnionToIntersection.d.ts
new file mode 100644
index 0000000..4dd6bdc
--- /dev/null
+++ b/node_modules/type-route/core/tools/UnionToIntersection.d.ts
@@ -0,0 +1,2 @@
+/** @see <https://docs.tsafe.dev/uniontointersection> **/
+export declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
diff --git a/node_modules/type-route/core/type-route.cjs.development.js b/node_modules/type-route/core/type-route.cjs.development.js
index 4770c08..4be1998 100644
--- a/node_modules/type-route/core/type-route.cjs.development.js
+++ b/node_modules/type-route/core/type-route.cjs.development.js
@@ -224,12 +224,6 @@ var TypeRouteError = /*#__PURE__*/buildErrorCollection({
       return ["The following characters are invalid: " + invalidCharacters.join(", ") + "."];
     }
   },
-  App_should_be_wrapped_in_a_RouteProvider_component: {
-    errorCode: 1020,
-    getDetails: function getDetails() {
-      return ["Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook."];
-    }
-  },
   Invalid_React_version: {
     errorCode: 1021,
     getDetails: function getDetails(version) {
@@ -1201,8 +1195,8 @@ function createNavigationHandlerManager(_ref) {
   }
 }
 
-function attemptScrollToTop(route, scrollToTop) {
-  if (route.action === "push" && typeof window === "object" && window !== null && typeof window.scroll === "function" && scrollToTop !== false && typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string" && !(navigator.userAgent.indexOf("Node.js") > 0 || navigator.userAgent.indexOf("jsdom") > 0)) {
+function attemptScrollToTop(route) {
+  if (route.action === "push" && typeof window === "object" && window !== null && typeof window.scroll === "function" && typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string" && !(navigator.userAgent.indexOf("Node.js") > 0 || navigator.userAgent.indexOf("jsdom") > 0)) {
     try {
       window.scroll(0, 0);
     } catch (_unused) {}
@@ -1271,95 +1265,113 @@ function createRouter() {
   var blockerCollection = [];
   applySessionOpts(opts.session);
   var routes = createRouteBuilderCollection(getRouterContext);
-  var router = {
-    routes: routes,
-    session: {
-      push: function push(href, state) {
-        {
-          assert("[RouterSessionHistory].push", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
-        }
-        var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),
-          route = _getRouteByHref.route,
-          primaryPath = _getRouteByHref.primaryPath;
-        return navigate(_extends({}, route, {
-          action: "push"
-        }), primaryPath);
-      },
-      replace: function replace(href, state) {
-        {
-          assert("[RouterSessionHistory].replace", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
-        }
-        var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),
-          route = _getRouteByHref2.route,
-          primaryPath = _getRouteByHref2.primaryPath;
-        return navigate(_extends({}, route, {
-          action: "replace"
-        }), primaryPath);
-      },
-      back: function back(amount) {
-        if (amount === void 0) {
-          amount = 1;
-        }
-        {
-          assert("[RouterSessionHistory].back", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
-        }
-        history$1.go(-amount);
-      },
-      forward: function forward(amount) {
-        if (amount === void 0) {
-          amount = 1;
-        }
-        {
-          assert("[RouterSessionHistory].forward", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
-        }
-        history$1.go(amount);
-      },
-      getInitialRoute: function getInitialRoute() {
-        {
-          assert("[RouterSessionHistory].getInitialRoute", [assert.numArgs([].slice.call(arguments), 0)]);
-        }
-        if (!initialRoute) {
-          var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history$1.location, baseUrl), getRouterContext());
-          if (!result.primaryPath) {
-            skipHandlingNextApplicationTriggeredNavigation = true;
-            result.route.replace();
-            result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history$1.location, baseUrl), getRouterContext());
-          }
-          initialRoute = result.route;
-        }
-        return initialRoute;
-      },
-      reset: function reset(session) {
-        {
-          assert("[RouterSessionHistory].reset", [assert.numArgs([].slice.call(arguments), 1), assert.type("object", "session", session)]);
+  var session = {
+    push: function push(href, state) {
+      {
+        assert("[RouterSessionHistory].push", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
+      }
+      var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),
+        route = _getRouteByHref.route,
+        primaryPath = _getRouteByHref.primaryPath;
+      return navigate(_extends({}, route, {
+        action: "push"
+      }), primaryPath);
+    },
+    replace: function replace(href, state) {
+      {
+        assert("[RouterSessionHistory].replace", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
+      }
+      var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),
+        route = _getRouteByHref2.route,
+        primaryPath = _getRouteByHref2.primaryPath;
+      return navigate(_extends({}, route, {
+        action: "replace"
+      }), primaryPath);
+    },
+    back: function back(amount) {
+      if (amount === void 0) {
+        amount = 1;
+      }
+      {
+        assert("[RouterSessionHistory].back", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
+      }
+      history$1.go(-amount);
+    },
+    forward: function forward(amount) {
+      if (amount === void 0) {
+        amount = 1;
+      }
+      {
+        assert("[RouterSessionHistory].forward", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
+      }
+      history$1.go(amount);
+    },
+    getInitialRoute: function getInitialRoute() {
+      {
+        assert("[RouterSessionHistory].getInitialRoute", [assert.numArgs([].slice.call(arguments), 0)]);
+      }
+      if (!initialRoute) {
+        var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history$1.location, baseUrl), getRouterContext());
+        if (!result.primaryPath) {
+          skipHandlingNextApplicationTriggeredNavigation = true;
+          result.route.replace();
+          result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history$1.location, baseUrl), getRouterContext());
         }
-        return applySessionOpts(session);
-      },
-      block: function block(blocker) {
-        blockerCollection.push(blocker);
-        var unblock = history$1.block(function (update) {
-          var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),
-            route = _getMatchingRoute2.route;
-          var action = update.action.toLowerCase();
-          blocker({
-            route: _extends({}, route, {
-              action: action
-            }),
-            retry: update.retry
-          });
-        });
-        return function () {
-          blockerCollection.splice(blockerCollection.findIndex(function (item) {
-            return item === blocker;
-          }), 1);
-          unblock();
-        };
-      },
-      listen: function listen(handler) {
-        return navigationHandlerManager.add(handler);
+        initialRoute = result.route;
       }
+      return initialRoute;
+    },
+    reset: function reset(session) {
+      {
+        assert("[RouterSessionHistory].reset", [assert.numArgs([].slice.call(arguments), 1), assert.type("object", "session", session)]);
+      }
+      return applySessionOpts(session);
+    },
+    block: function block(blocker) {
+      blockerCollection.push(blocker);
+      var unblock = history$1.block(function (update) {
+        var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),
+          route = _getMatchingRoute2.route;
+        var action = update.action.toLowerCase();
+        blocker({
+          route: _extends({}, route, {
+            action: action
+          }),
+          retry: update.retry
+        });
+      });
+      return function () {
+        blockerCollection.splice(blockerCollection.findIndex(function (item) {
+          return item === blocker;
+        }), 1);
+        unblock();
+      };
+    },
+    listen: function listen(handler) {
+      return navigationHandlerManager.add(handler);
     }
   };
+  var _ref = function () {
+      var route_current = session.getInitialRoute();
+      session.listen(function (route) {
+        return route_current = route;
+      });
+      function getRoute() {
+        return route_current;
+      }
+      return {
+        getRoute: getRoute
+      };
+    }(),
+    getRoute = _ref.getRoute;
+  var router = {
+    routes: routes,
+    session: session,
+    stopListening: function stopListening() {
+      return unlisten == null ? void 0 : unlisten();
+    },
+    getRoute: getRoute
+  };
   return router;
   function applySessionOpts(sessionOpts) {
     if (sessionOpts === void 0) {
@@ -1426,7 +1438,9 @@ function createRouter() {
       var handler = _step.value;
       handler(route);
     }
-    attemptScrollToTop(route, opts.scrollToTop);
+    if (opts.scrollToTop === true) {
+      attemptScrollToTop(route);
+    }
     previousRoute = route;
   }
   function getRouterContext() {
@@ -1702,7 +1716,7 @@ function getParamDefKindSection(kind, trailing) {
   }
 }
 
-function createGroup(groupItems) {
+function createGroup_fromItems(groupItems) {
   {
     assert("createGroup", [assert.numArgs([].slice.call(arguments), 1), assert.arrayOfType(["RouteGroup", "RouteBuilder"], "groupItems", groupItems)]);
   }
@@ -1736,6 +1750,15 @@ function createGroup(groupItems) {
 function isRouteGroup(value) {
   return !!value.routeNames;
 }
+function createGroup_fromRouteDefs(routeDefs) {
+  var core = createRouter(routeDefs);
+  var group = createGroup_fromItems(Object.values(core.routes));
+  core.stopListening();
+  return group;
+}
+function createGroup(arg) {
+  return arg instanceof Array ? createGroup_fromItems(arg) : createGroup_fromRouteDefs(arg);
+}
 
 exports.createGroup = createGroup;
 exports.createRouter = createRouter;
diff --git a/node_modules/type-route/core/type-route.cjs.development.js.map b/node_modules/type-route/core/type-route.cjs.development.js.map
index 7335a30..edf83e1 100644
--- a/node_modules/type-route/core/type-route.cjs.development.js.map
+++ b/node_modules/type-route/core/type-route.cjs.development.js.map
@@ -1 +1 @@
-{"version":3,"file":"type-route.cjs.development.js","sources":["../src/typeOf.ts","../src/TypeRouteError.ts","../src/asArray.ts","../src/assert.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/getStateMatch.ts","../src/getQueryMatch.ts","../src/createMatcher.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  App_should_be_wrapped_in_a_RouteProvider_component: {\n    errorCode: 1020,\n    getDetails() {\n      return [\n        \"Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook.\",\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session: {\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n    },\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n"],"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","App_should_be_wrapped_in_a_RouteProvider_component","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","_loop","_paramDef$Internal$v","paramValue","undefined","urlEncodeDefault","urlEncode","valueSerializer","getValue","valueSerializerId","id","_ret","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","router","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","_opts$arrayFormat3","_getRouterContext","defineRoute","assertDefineRouteOrExtendArgs","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup","groupItems","routeNames","isRouteGroup","has"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"type-route.cjs.development.js","sources":["../src/typeOf.ts","../src/TypeRouteError.ts","../src/asArray.ts","../src/assert.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/getStateMatch.ts","../src/getQueryMatch.ts","../src/createMatcher.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const session: UmbrellaCoreRouter[\"session\"] = {\n\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n\n  };\n\n  const { getRoute } = (() => {\n    let route_current = session.getInitialRoute();\n\n    session.listen(route => (route_current = route));\n\n    function getRoute() {\n        return route_current;\n    }\n\n    return { getRoute };\n  })();\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session,\n    stopListening: ()=> unlisten?.(),\n    getRoute\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    if( opts.scrollToTop === true){\n      attemptScrollToTop(route);\n    }\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder, CoreRouter } from \"./types\";\nimport { assert } from \"./assert\";\nimport { createRouter as coreCreateRouter } from \"./createRouter\";\n\nfunction createGroup_fromItems<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n\nexport function createGroup_fromRouteDefs<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n> {\n  const core = coreCreateRouter(routeDefs);\n\n  const group= createGroup_fromItems(\n    Object.values(core.routes)\n  );\n\n  core.stopListening();\n\n  return group;\n}\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;\nexport function createGroup<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n>;\nexport function createGroup(\n  arg: any[] | Record<string, unknown>\n): RouteGroup<any> {\n  return arg instanceof Array\n    ? createGroup_fromItems(arg)\n    : createGroup_fromRouteDefs(arg);\n}\n\n\n"],"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","_loop","_paramDef$Internal$v","paramValue","undefined","urlEncodeDefault","urlEncode","valueSerializer","getValue","valueSerializerId","id","_ret","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","route_current","getRoute","router","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","scrollToTop","_opts$arrayFormat3","_getRouterContext","defineRoute","assertDefineRouteOrExtendArgs","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup_fromItems","groupItems","routeNames","isRouteGroup","has","createGroup_fromRouteDefs","core","coreCreateRouter","group","values","createGroup","arg"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAAgBA,MAAMA,CAACC,KAAU;EAC/B,IAAIA,KAAK,KAAK,IAAI,EAAE;IAClB,OAAO,MAAM;;EAGf,IAAIC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;IACxB,OAAO,OAAO;;EAGhB,OAAO,OAAOA,KAAK;AACrB;;ACPA,SAASG,+BAA+BA,CAACC,SAAiB;EACxD,+EAA4EA,SAAS;AACvF;AAEA,SAASC,2BAA2BA,CAACC,OAAiC;EACpE,OAAO,CACLH,+BAA+B,CAACG,OAAO,CAACF,SAAS,CAAC,oCACjBE,OAAO,CAACC,OAAO,OACjD;AACH;AAEA,AAAO,IAAMC,cAAc,gBAAGC,oBAAoB,CAAC;EACjDC,+BAA+B,EAAE;IAC/BC,SAAS,EAAE,IAAI;IACfC,UAAU,EAAEP;GACb;EAEDQ,oCAAoC,EAAE;IACpCF,SAAS,EAAE,IAAI;IACfC,UAAU,EAAEP;GACb;EAEDS,qCAAqC,EAAE;IACrCH,SAAS,EAAE,IAAI;IACfC,UAAU,EAAEP;GACb;EAEDU,wDAAwD,EAAE;IACxDJ,SAAS,EAAE,IAAI;IACfC,UAAU,EAAE,SAAAA,WACVN,OAAiC,EACjCU,OAIC;;MAED,IAAMC,OAAO,GAAGD,OAAO,CAACC,OAAO;MAC/B,IAAMC,QAAQ,IAAAC,iBAAA,GAAGH,OAAO,CAACE,QAAQ,YAAAC,iBAAA,GAAI,EAAE;MACvC,IAAMC,OAAO,IAAAC,gBAAA,GAAGL,OAAO,CAACI,OAAO,YAAAC,gBAAA,GAAI,EAAE;MAErC,IAAMC,iBAAiB,GAAG,CAACL,OAAO,GAAGC,QAAQ,EAC1CK,KAAK,CAAC,EAAE,CAAC,CACTC,MAAM,CAAC,UAACC,SAAS;QAAA,OAAKA,SAAS,KAAKC,kBAAkB,CAACD,SAAS,CAAC;QAAC;MAErE,UAAAE,MAAA,CACKtB,2BAA2B,CAACC,OAAO,CAAC,2BAErCW,OAAO,GAAGG,OAAO,GAAGF,QACtB,iDAA4CI,iBAAiB,CAACM,IAAI,CAChE,IAAI,CACL;;GAGN;EAEDC,mCAAmC,EAAE;IACnClB,SAAS,EAAE,IAAI;IACfC,UAAU,EAAE,SAAAA,WAACN,OAAiC;MAC5C,UAAAqB,MAAA,CACKtB,2BAA2B,CAACC,OAAO,CAAC,GACvC,2GAA2G;;GAGhH;EAEDwB,+CAA+C,EAAE;IAC/CnB,SAAS,EAAE,IAAI;IACfC,UAAU,EAAE,SAAAA,WACVN,OAAiC,EACjCyB,cAAwB;MAExB,UAAAJ,MAAA,CACKtB,2BAA2B,CAACC,OAAO,CAAC,wEAC4ByB,cAAc,EACjF,0EAA0E;;GAG/E;EAEDC,mEAAmE,EAAE;IACnErB,SAAS,EAAE,IAAI;IACfC,UAAU,EAAE,SAAAA,WAACN,OAAiC,EAAE2B,aAAqB;MACnE,UAAAN,MAAA,CACKtB,2BAA2B,CAACC,OAAO,CAAC,wBACrB2B,aAAa;;GAGpC;EAEDC,mEAAmE,EAAE;IACnEvB,SAAS,EAAE,IAAI;IACfC,UAAU,EAAE,SAAAA,WACVN,OAAiC,EACjC2B,aAAqB,EACrBE,WAAmB,EACnBC,YAAoB;MAEpB,IAAMC,QAAQ,GAAGhC,2BAA2B,CAACC,OAAO,CAAC;MAErD,IAAI6B,WAAW,EAAE;QACfE,QAAQ,CAACC,IAAI,sBACOL,aAAa,mCAA4BE,WAAW,QAAI,CAC3E;;MAGH,IAAIC,YAAY,EAAE;QAChBC,QAAQ,CAACC,IAAI,sBACOL,aAAa,mCAA4BG,YAAY,QAAI,CAC5E;;MAGH,OAAOC,QAAQ;;GAElB;EAEDE,wDAAwD,EAAE;IACxD5B,SAAS,EAAE,IAAI;IACfC,UAAU,WAAAA,WACRN,OAAiC,EACjCkC,iCAAyC;MAEzC,UAAAb,MAAA,CACKtB,2BAA2B,CAACC,OAAO,CAAC,oEACwBkC,iCAAiC;;GAGrG;EAEDC,6EAA6E,EAC3E;IACE9B,SAAS,EAAE,IAAI;IACfC,UAAU,EAAEP;GACb;EAEHqC,qDAAqD,EAAE;IACrD/B,SAAS,EAAE,IAAI;IACfC,UAAU,WAAAA,WAACN,OAAiC,EAAEqC,gBAA0B;MACtE,UAAAhB,MAAA,CACKtB,2BAA2B,CAACC,OAAO,CAAC,gDACIqC,gBAAgB,CAACf,IAAI,CAC9D,IAAI,CACL;;GAGN;EAEDgB,+FAA+F,EAC7F;IACEjC,SAAS,EAAE,IAAI;IACfC,UAAU,WAAAA,WAACR,SAAiB,EAAEyC,SAAiB;MAC7C,OAAO,CACL1C,+BAA+B,CAACC,SAAS,CAAC,iEACmByC,SAAS,CACvE;;GAEJ;EAEHC,uGAAuG,EACrG;IACEnC,SAAS,EAAE,IAAI;IACfC,UAAU,WAAAA,WAACmC,uBAAiC;MAC1C,OAAO,mGAC2FA,uBAAuB,CAACnB,IAAI,CAC1H,IAAI,CACL,CACF;;GAEJ;EAEHoB,wCAAwC,EAAE;IACxCrC,SAAS,EAAE,IAAI;IACfC,UAAU,WAAAA,WAAAqC,IAAA;UACR3C,OAAO,GAAA2C,IAAA,CAAP3C,OAAO;QACPN,KAAK,GAAAiD,IAAA,CAALjD,KAAK;QACLkD,SAAS,GAAAD,IAAA,CAATC,SAAS;QACTC,YAAY,GAAAF,IAAA,CAAZE,YAAY;QACZC,UAAU,GAAAH,IAAA,CAAVG,UAAU;MAQV,OAAO,wCACiC9C,OAAO,cACxC4C,SAAS,uCACZjD,KAAK,CAACC,OAAO,CAACiD,YAAY,CAAC,GAAGA,YAAY,CAACvB,IAAI,CAAC,KAAK,CAAC,GAAGuB,YAC3D,4BAAwBC,UAAU,6CAEhCrD,MAAM,CAACC,KAAK,CAAC,KAAK,QAAQ,GACtB,IAAI,GACJqD,IAAI,CAACC,SAAS,CAACtD,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC,CAC3BuB,KAAK,CAAC,IAAI,CAAC,CACXgC,GAAG,CAAC,UAACC,IAAI;QAAA,cAAUA,IAAI;OAAE,CAAC,CAC1B5B,IAAI,CAAC,IAAI,CAAC,GACb,GAAG,GAAG5B,KAAK,GAAG,GACpB,EACD;;GAEJ;EAEDyD,qDAAqD,EAAE;IACrD9C,SAAS,EAAE,IAAI;IACfC,UAAU,WAAAA,WAAA8C,KAAA;UACRpD,OAAO,GAAAoD,KAAA,CAAPpD,OAAO;QACPqD,IAAI,GAAAD,KAAA,CAAJC,IAAI;QACJC,GAAG,GAAAF,KAAA,CAAHE,GAAG;QACHC,GAAG,GAAAH,KAAA,CAAHG,GAAG;MAOH,OAAO,wCACiCvD,OAAO,sBACjCsD,GAAG,IAAGA,GAAG,KAAKC,GAAG,GAAG,EAAE,GAAG,KAAK,GAAGA,GAAG,uBAC9CF,IAAI,CAACG,MACP,kBAAYH,IAAI,CAACG,MAAM,KAAK,CAAC,GAAG,EAAE,GAAG,GAAG,EACzC;;GAEJ;EAEDC,qFAAqF,EACnF;IACEpD,SAAS,EAAE,IAAI;IACfC,UAAU,WAAAA;MACR,OAAO,CACL,+HAA+H,CAChI;;GAEJ;EAEHoD,iDAAiD,EAAE;IACjDrD,SAAS,EAAE,IAAI;IACfC,UAAU,WAAAA,WAAAqD,KAAA;UACR3D,OAAO,GAAA2D,KAAA,CAAP3D,OAAO;QACP4D,KAAK,GAAAD,KAAA,CAALC,KAAK;QACLN,GAAG,GAAAK,KAAA,CAAHL,GAAG;QACHC,GAAG,GAAAI,KAAA,CAAHJ,GAAG;MAOH,OAAO,wCACiCvD,OAAO,4CACXsD,GAAG,IACnCA,GAAG,KAAKC,GAAG,GAAG,EAAE,GAAG,KAAK,GAAGA,GAC7B,gCAA0BK,KAAK,CAACJ,MAAM,CACvC;;GAEJ;EAEDK,oDAAoD,EAAE;IACpDxD,SAAS,EAAE,IAAI;IACfC,UAAU,WAAAA,WAAAwD,KAAA;UACRhE,SAAS,GAAAgE,KAAA,CAAThE,SAAS;QACTiE,uBAAuB,GAAAD,KAAA,CAAvBC,uBAAuB;QACvBC,qBAAqB,GAAAF,KAAA,CAArBE,qBAAqB;MAMrB,OAAO,8CACsClE,SAAS,wEACGiE,uBAAuB,SAC9EC,qBAAqB,CAACR,MAAM,KAAK,CAAC,GAC9B,wCAAwC,mDACMQ,qBAAqB,CAChEf,GAAG,CAAC,UAACgB,IAAI;QAAA,cAASA,IAAI;OAAG,CAAC,CAC1B3C,IAAI,CAAC,IAAI,CAAG,CACpB;;GAEJ;EAED4C,8CAA8C,EAAE;IAC9C7D,SAAS,EAAE,IAAI;IACfC,UAAU,WAAAA,WAAA6D,KAAA;UACRrE,SAAS,GAAAqE,KAAA,CAATrE,SAAS;QACTsE,oBAAoB,GAAAD,KAAA,CAApBC,oBAAoB;MAKpB,OAAO,8CACsCtE,SAAS,mCAClCsE,oBAAoB,0CACvC;;GAEJ;EAEDC,wCAAwC,EAAE;IACxChE,SAAS,EAAE,IAAI;IACfC,UAAU,WAAAA,WAACgE,OAAe;MACxB,OAAO,CACL,8CAA8C,gCACnBA,OAAO,6CACnC;;GAEJ;EAEDC,iEAAiE,EAAE;IACjElE,SAAS,EAAE,IAAI;IACfC,UAAU,WAAAA,WAACgE,OAAe;MACxB,IAAMtD,iBAAiB,GAAGsD,OAAO,CAC9BE,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAClBvD,KAAK,CAAC,EAAE,CAAC,CACTC,MAAM,CAAC,UAACC,SAAS;QAAA,OAAKA,SAAS,KAAKC,kBAAkB,CAACD,SAAS,CAAC;QAAC;MACrE,OAAO,4CACoCH,iBAAiB,CAACM,IAAI,CAC7D,IAAI,CACL,OACF;;GAEJ;EAEDmD,qBAAqB,EAAE;IACrBpE,SAAS,EAAE,IAAI;IACfC,UAAU,WAAAA,WAACoE,OAAe;MACxB,OAAO,CACL,wCAAwC,wBACpBA,OAAO,kBAC3B,sEAAsE,CACvE;;;CAGN,CAAC;AAEF,SAASvE,oBAAoBA,CAE3BwE,WAAgC;EAChC,IAAMC,MAAM,GAOR,EAAE;EAENC,MAAM,CAACC,IAAI,CAACH,WAAW,CAAC,CAACI,OAAO,CAAC,UAACC,GAAG;IACnC,IAAMf,IAAI,GAAGe,GAAG,CAACR,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,GAAG,GAAG;IACzC,IAAAS,gBAAA,GAAkCN,WAAW,CAACK,GAAG,CAAC;MAA1C3E,SAAS,GAAA4E,gBAAA,CAAT5E,SAAS;MAAEC,UAAU,GAAA2E,gBAAA,CAAV3E,UAAU;IAC7B,IAAM4E,YAAY,UAAQ7E,SAAS,cAAM4D,IAAM;IAE/CW,MAAM,CAACI,GAAG,CAAC,GAAG;MACZ3E,SAAS,EAATA,SAAS;MACT4D,IAAI,EAAJA,IAAI;MACJkB,MAAM,WAAAA;;0CAAI9B,IAAW,OAAA1D,KAAA,CAAAyF,IAAA,GAAAC,IAAA,MAAAA,IAAA,GAAAD,IAAA,EAAAC,IAAA;UAAXhC,IAAW,CAAAgC,IAAA,IAAAC,SAAA,CAAAD,IAAA;;QACnB,IAAME,OAAO,GAAG,EAAAC,WAAA,GAAClF,UAAU,oBAAVA,UAAU,CAAAmF,KAAA,SAAMpC,IAAI,CAAC,YAAAmC,WAAA,GAAI,EAAE,EACzCvC,GAAG,CAAC,UAACyC,MAAM;UAAA,cAAUA,MAAM;SAAE,CAAC,CAC9BpE,IAAI,CAAC,IAAI,CAAC;QAEb,IAAMqE,KAAK,GAAG,IAAIC,KAAK,CACrBL,OAAO,YACIL,YAAY,YAAOK,OAAO,mBAC1BL,YAAY,OAAI,CAC5B;QACDS,KAAK,CAAC1B,IAAI,oDAA0C;QAEpD,OAAO0B,KAAK;;KAEf;GACF,CAAC;EAEF,OAAOf,MAQN;AACH;;SC9XgBiB,OAAOA,CAAInG,KAAc;EACvC,OAAOC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,GAAGA,KAAK,GAAG,CAACA,KAAK,CAAC;AAC/C;;SCCgBoG,MAAMA,CACpB9F,OAAe,EACf+F,UAAyC;EAEzCA,UAAU,CAAChB,OAAO,CAAC,UAACe,MAAM;IAAA,OAAKA,MAAM,CAAC9F,OAAO,CAAC;IAAC;AACjD;AAEA8F,MAAM,CAACE,WAAW,GAChB,UAACpC,KAAY,EAAEN,GAAW,EAAEC,GAAG;EAAA,IAAHA,GAAG;IAAHA,GAAG,GAAGD,GAAG;;EAAA,OACrC,UAACtD,OAAe;IACd,IAAI4D,KAAK,CAACJ,MAAM,GAAGF,GAAG,IAAIM,KAAK,CAACJ,MAAM,GAAGD,GAAG,EAAE;MAC5C,MAAMrD,cAAc,CAACwD,iDAAiD,CAACyB,MAAM,CAC3E;QACEnF,OAAO,EAAPA,OAAO;QACP4D,KAAK,EAALA,KAAK;QACLN,GAAG,EAAHA,GAAG;QACHC,GAAG,EAAHA;OACD,CACF;;GAEJ;AAAA;AAEHuC,MAAM,CAACG,OAAO,GACZ,UAAC5C,IAAW,EAAEC,GAAW,EAAEC,GAAG;EAAA,IAAHA,GAAG;IAAHA,GAAG,GAAGD,GAAG;;EAAA,OACpC,UAACtD,OAAe;IACd,IAAIqD,IAAI,CAACG,MAAM,GAAGF,GAAG,IAAID,IAAI,CAACG,MAAM,GAAGD,GAAG,EAAE;MAC1C,MAAMrD,cAAc,CAACiD,qDAAqD,CAACgC,MAAM,CAC/E;QACEnF,OAAO,EAAPA,OAAO;QACPqD,IAAI,EAAJA,IAAI;QACJC,GAAG,EAAHA,GAAG;QACHC,GAAG,EAAHA;OACD,CACF;;GAEJ;AAAA;AAEHuC,MAAM,CAACI,gBAAgB,GACrB,UAACrD,YAA+B,EAAED,SAAiB,EAAElD,KAAU;EAAA,OAC/D,UAACM,OAAe;IACd,IAAIP,MAAM,CAACC,KAAK,CAAC,KAAK,QAAQ,EAAE;MAC9B,IAAMyG,kBAAkB,GAAGtB,MAAM,CAACC,IAAI,CAACpF,KAAK,CAAC;MAE7C,SAAA0G,EAAA,MAAAC,mBAAA,GAA2BF,kBAAkB,EAAAC,EAAA,GAAAC,mBAAA,CAAA7C,MAAA,EAAA4C,EAAA,IAAE;QAA1C,IAAME,YAAY,GAAAD,mBAAA,CAAAD,EAAA;QACrBN,MAAM,CAACS,IAAI,CACT1D,YAAY,EACTD,SAAS,SAAI0D,YAAY,EAC5B5G,KAAK,CAAC4G,YAAY,CAAC,CACpB,CAACtG,OAAO,CAAC;;MAGZ;;IAGF,MAAME,cAAc,CAACwC,wCAAwC,CAACyC,MAAM,CAAC;MACnEnF,OAAO,EAAPA,OAAO;MACP8C,UAAU,EAAErD,MAAM,CAACC,KAAK,CAAC;MACzBmD,YAAY,uBACVlD,KAAK,CAACC,OAAO,CAACiD,YAAY,CAAC,GAAGA,YAAY,CAACvB,IAAI,CAAC,KAAK,CAAC,GAAGuB,YAC3D,OAAG;MACHnD,KAAK,EAALA,KAAK;MACLkD,SAAS,EAATA;KACD,CAAC;GACH;AAAA;AAEHkD,MAAM,CAACU,WAAW,GAChB,UAAC3D,YAA+B,EAAED,SAAiB,EAAElD,KAAU;EAAA,OAC/D,UAACM,OAAe;IACd,IAAIL,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;MACxB,KAAK,IAAI+G,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG/G,KAAK,CAAC8D,MAAM,EAAEiD,KAAK,EAAE,EAAE;QACjDX,MAAM,CAACS,IAAI,CACT1D,YAAY,EACTD,SAAS,SAAI6D,KAAK,QACrB/G,KAAK,CAAC+G,KAAK,CAAC,CACb,CAACzG,OAAO,CAAC;;MAGZ;;IAGF,MAAME,cAAc,CAACwC,wCAAwC,CAACyC,MAAM,CAAC;MACnEnF,OAAO,EAAPA,OAAO;MACP8C,UAAU,EAAErD,MAAM,CAACC,KAAK,CAAC;MACzBmD,YAAY,cACVlD,KAAK,CAACC,OAAO,CAACiD,YAAY,CAAC,GAAGA,YAAY,CAACvB,IAAI,CAAC,KAAK,CAAC,GAAGuB,YAC3D,OAAG;MACHnD,KAAK,EAALA,KAAK;MACLkD,SAAS,EAATA;KACD,CAAC;GACH;AAAA;AAEHkD,MAAM,CAACS,IAAI,GACT,UAAC1D,YAA+B,EAAED,SAAiB,EAAElD,KAAU;EAAA,OAC/D,UAACM,OAAe;IACd,IAAM0G,gBAAgB,GACpB,OAAO7D,YAAY,KAAK,QAAQ,GAAG,CAACA,YAAY,CAAC,GAAGA,YAAY;IAElE,SAAA8D,SAAA,GAAAC,+BAAA,CAA2BF,gBAAgB,GAAAG,KAAA,IAAAA,KAAA,GAAAF,SAAA,IAAAG,IAAA,GAAE;MAAA,IAAlCjE,aAAY,GAAAgE,KAAA,CAAAnH,KAAA;MACrB,IAAMqH,iBAAiB,GACrBlE,aAAY,CAAC,CAAC,CAAC,CAACmE,WAAW,EAAE,KAAKnE,aAAY,CAAC,CAAC,CAAC;MAEnD,IACGkE,iBAAiB,KACftH,MAAM,CAACC,KAAK,CAAC,KAAK,QAAQ,IAAID,MAAM,CAACC,KAAK,CAAC,KAAK,UAAU,CAAC,IAC5DD,MAAM,CAACC,KAAK,CAAC,WAAW,CAAC,CAAC,KAAK,QAAQ,IACvCA,KAAK,CAAC,WAAW,CAAC,CAAC6G,IAAI,KAAK1D,aAAY,IACzC,CAACkE,iBAAiB,IAAItH,MAAM,CAACC,KAAK,CAAC,KAAKmD,aAAa,EACtD;QACA;;;IAIJ,MAAM3C,cAAc,CAACwC,wCAAwC,CAACyC,MAAM,CAAC;MACnEnF,OAAO,EAAPA,OAAO;MACP8C,UAAU,EAAErD,MAAM,CAACC,KAAK,CAAC;MACzBmD,YAAY,EAAZA,YAAY;MACZnD,KAAK,EAALA,KAAK;MACLkD,SAAS,EAATA;KACD,CAAC;GACH;AAAA;;SC9GaqE,aAAaA,CAC3BnH,SAAiB,EACjBoH,sBAAoD,EACpDC,UAAsB;EAEtB,IAAMC,kBAAkB,GAAGvC,MAAM,CAACC,IAAI,CAACoC,sBAAsB,CAAC,CAACjE,GAAG,CAChE,UAACV,SAAS;IACR,IAAM8E,4BAA4B,GAAAC,QAAA;MAChC/E,SAAS,EAATA;OACG2E,sBAAsB,CAAC3E,SAAS,CAAC,CACrC;IAED,OAAO8E,4BAA4B;GACpC,CACF;EAED,IAAME,iBAAiB,GAAsB,EAAE;EAE/CH,kBAAkB,CAACrC,OAAO,CAAC,UAAApC,IAAA;QAAGJ,SAAS,GAAAI,IAAA,CAATJ,SAAS;IACrC,AAAa;MACX,IACEA,SAAS,CAACiF,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAC3BjF,SAAS,CAACiF,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAC3BjF,SAAS,CAACiF,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAC3BjF,SAAS,CAACiF,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAC3B;QACA,MAAMtH,cAAc,CAACoC,+FAA+F,CAAC6C,MAAM,CACzHrF,SAAS,EACTyC,SAAS,CACV;;;IAILgF,iBAAiB,CAAChF,SAAS,CAAC,GAAGkF,UAAU,CAAClF,SAAS,CAAC;GACrD,CAAC;EAEF,IAAMtC,OAAO,GAAGkH,UAAU,CAACI,iBAAiB,CAAC;EAE7C,AAAa;IACX,IAAI5H,KAAK,CAACC,OAAO,CAACK,OAAO,CAAC,EAAE;MAC1B6F,MAAM,iBAAehG,SAAS,aAAU,CACtCgG,MAAM,CAACU,WAAW,CAAC,QAAQ,EAAE,MAAM,EAAEvG,OAAO,CAAC,EAC7C6F,MAAM,CAACE,WAAW,CAAC/F,OAAO,EAAE,CAAC,EAAEyH,QAAQ,CAAC,CACzC,CAAC;KACH,MAAM;MACL5B,MAAM,iBAAehG,SAAS,aAAU,CACtCgG,MAAM,CAACS,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAEtG,OAAO,CAAC,CACvC,CAAC;;;EAIN,OAAO4F,OAAO,CAAC5F,OAAO,CAAC,CAACgD,GAAG,CAAC,UAAChD,OAAO;IAClC,IAAM0H,YAAY,GAA6B;MAC7C1H,OAAO,EAAPA,OAAO;MACPH,SAAS,EAATA;KACD;IAED,AAAa;MACX,IAAIG,OAAO,CAACuD,MAAM,KAAK,CAAC,EAAE;QACxB,MAAMtD,cAAc,CAACE,+BAA+B,CAAC+E,MAAM,CACzDwC,YAAY,CACb;;MAGH,IAAI1H,OAAO,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QACtB,MAAMC,cAAc,CAACK,oCAAoC,CAAC4E,MAAM,CAC9DwC,YAAY,CACb;;;IAIL,IAAI1H,OAAO,CAACuD,MAAM,KAAK,CAAC,EAAE;MACxB,OAAO,EAAE;;IAGX,AAAa;MACX,IAAIvD,OAAO,CAACuD,MAAM,GAAG,CAAC,IAAIvD,OAAO,CAACA,OAAO,CAACuD,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;QAC7D,MAAMtD,cAAc,CAACM,qCAAqC,CAAC2E,MAAM,CAC/DwC,YAAY,CACb;;;IAIL,IAAMC,eAAe,GAAG3H,OAAO,CAACgB,KAAK,CAAC,GAAG,CAAC,CAAC4G,KAAK,CAAC,CAAC,CAAC;IAEnD,IAAMC,cAAc,GAAyB,EAAE;IAC/C,IAAMC,OAAO,GAAY,EAAE;IAE3B,SAAApB,SAAA,GAAAC,+BAAA,CAAyBgB,eAAe,GAAAf,KAAA,IAAAA,KAAA,GAAAF,SAAA,IAAAG,IAAA,GAAE;MAAA,IAA/BkB,UAAU,GAAAnB,KAAA,CAAAnH,KAAA;MACnB,AAAa;QACX,IAAIsI,UAAU,CAACxE,MAAM,KAAK,CAAC,EAAE;UAC3B,MAAMtD,cAAc,CAACqB,mCAAmC,CAAC4D,MAAM,CAC7DwC,YAAY,CACb;;;MAIL,IAAIM,gBAAgB,GAAsC,IAAI;MAE9D,SAAAC,UAAA,GAAAtB,+BAAA,CAAuBQ,kBAAkB,GAAAe,MAAA,IAAAA,MAAA,GAAAD,UAAA,IAAApB,IAAA,GAAE;QAAA,IAAhCsB,QAAQ,GAAAD,MAAA,CAAAzI,KAAA;QACjB,IAAIsI,UAAU,CAACR,OAAO,CAACC,UAAU,CAACW,QAAQ,CAAC7F,SAAS,CAAC,CAAC,IAAI,CAAC,EAAE;UAC3D,AAAa;YACX,IAAI0F,gBAAgB,KAAK,IAAI,EAAE;cAC7B,MAAM/H,cAAc,CAACsB,+CAA+C,CAAC2D,MAAM,CACzEwC,YAAY,EACZ,CAACS,QAAQ,CAAC7F,SAAS,EAAE0F,gBAAgB,CAAC1F,SAAS,CAAC,CACjD;;YAGH,IAAIuF,cAAc,CAACM,QAAQ,CAAC7F,SAAS,CAAC,EAAE;cACtC,MAAMrC,cAAc,CAACwB,mEAAmE,CAACyD,MAAM,CAC7FwC,YAAY,EACZS,QAAQ,CAAC7F,SAAS,CACnB;;;UAIL0F,gBAAgB,GAAGG,QAAQ;UAC3BN,cAAc,CAACM,QAAQ,CAAC7F,SAAS,CAAC,GAAG,IAAI;;;MAI7C,IAAI0F,gBAAgB,EAAE;QACpB,IAAAI,iBAAA,GAA4BL,UAAU,CAAC/G,KAAK,CAC1CwG,UAAU,CAACQ,gBAAgB,CAAC1F,SAAS,CAAC,CACvC;UAFM5B,OAAO,GAAA0H,iBAAA;UAAEzH,QAAQ,GAAAyH,iBAAA;QAIxB,AAAa;UACX,IACEjH,kBAAkB,CAACT,OAAO,CAAC,KAAKA,OAAO,IACvCS,kBAAkB,CAACR,QAAQ,CAAC,KAAKA,QAAQ,EACzC;YACA,MAAMV,cAAc,CAACO,wDAAwD,CAAC0E,MAAM,CAClFwC,YAAY,EACZ;cACEhH,OAAO,EAAPA,OAAO;cACPG,OAAO,EAAE2G,UAAU,CAACQ,gBAAgB,CAAC1F,SAAS,CAAC;cAC/C3B,QAAQ,EAARA;aACD,CACF;;UAGH,IACEqH,gBAAgB,CAAC,WAAW,CAAC,CAACK,QAAQ,KACrC3H,OAAO,KAAK,EAAE,IAAIC,QAAQ,KAAK,EAAE,CAAC,EACnC;YACA,MAAMV,cAAc,CAAC0B,mEAAmE,CAACuD,MAAM,CAC7FwC,YAAY,EACZM,gBAAgB,CAAC1F,SAAS,EAC1B5B,OAAO,EACPC,QAAQ,CACT;;;QAILmH,OAAO,CAAC/F,IAAI,CAAC;UACXrB,OAAO,EAAPA,OAAO;UACPC,QAAQ,EAARA,QAAQ;UACR2H,aAAa,EAAEN;SAChB,CAAC;OACH,MAAM;QACL,AAAa;UACX,IAAI7G,kBAAkB,CAAC4G,UAAU,CAAC,KAAKA,UAAU,EAAE;YACjD,MAAM9H,cAAc,CAACO,wDAAwD,CAAC0E,MAAM,CAClFwC,YAAY,EACZ;cAAEhH,OAAO,EAAEqH;aAAY,CACxB;;;QAILD,OAAO,CAAC/F,IAAI,CAAC;UACXrB,OAAO,EAAEqH,UAAU;UACnBpH,QAAQ,EAAE,EAAE;UACZ2H,aAAa,EAAE;SAChB,CAAC;;;IAIN,IAAMC,2BAA2B,GAAGT,OAAO,CAAC7G,MAAM,CAChD,UAACuH,IAAI;MAAA,IAAAC,mBAAA,EAAAC,oBAAA;MAAA,OACH,EAAAD,mBAAA,GAAAD,IAAI,CAACF,aAAa,qBAAlBG,mBAAA,CAAqB,WAAW,CAAC,CAACJ,QAAQ,OAAAK,oBAAA,GAC1CF,IAAI,CAACF,aAAa,qBAAlBI,oBAAA,CAAqB,WAAW,CAAC,CAAC/H,QAAQ;MAC7C,CAAC4C,MAAM;IAER,AAAa;MACX,IAAIgF,2BAA2B,GAAG,CAAC,EAAE;QACnC,MAAMtI,cAAc,CAAC+B,wDAAwD,CAACkD,MAAM,CAClFwC,YAAY,EACZa,2BAA2B,CAC5B;;;IAIL,IAAMI,kCAAkC,GACtCb,OAAO,CAACA,OAAO,CAACvE,MAAM,GAAG,CAAC,CAAC,CAAC+E,aAAa;IAE3C,AAAa;MACX,IACEC,2BAA2B,KAAK,CAAC,IACjC,EAACI,kCAAkC,YAAlCA,kCAAkC,CAAG,WAAW,CAAC,CAACN,QAAQ,KAC3D,EAACM,kCAAkC,YAAlCA,kCAAkC,CAAG,WAAW,CAAC,CAAChI,QAAQ,GAC3D;QACA,MAAMV,cAAc,CAACiC,6EAA6E,CAACgD,MAAM,CACvGwC,YAAY,CACb;;;IAIL,IAAMkB,8BAA8B,GAAGzB,kBAAkB,CACtDnE,GAAG,CAAC,UAAAG,KAAA;MAAA,IAAca,IAAI,GAAAb,KAAA,CAAfb,SAAS;MAAA,OAAa0B,IAAI;MAAC,CAClC/C,MAAM,CAAC,UAAC+C,IAAI;MAAA,OAAK,CAAC6D,cAAc,CAAC7D,IAAI,CAAC;MAAC;IAE1C,AAAa;MACX,IAAI4E,8BAA8B,CAACrF,MAAM,GAAG,CAAC,EAAE;QAC7C,MAAMtD,cAAc,CAACkC,qDAAqD,CAAC+C,MAAM,CAC/EwC,YAAY,EACZkB,8BAA8B,CAC/B;;;IAIL,OAAOd,OAAO;GACf,CAAC;AACJ;AAEA,SAASN,UAAUA,CAAC9F,aAAqB;EACvC,OAAO,MAAM,GAAGA,aAAa,GAAG,GAAG;AACrC;;SC7OgBmH,kBAAkBA,CAChCvC,IAAgB,EAChBwC,kBAAoD;EAEpD,IAAMC,0BAA0B,GAAmC,EAAE;EAErEnE,MAAM,CAACC,IAAI,CAACiE,kBAAkB,CAAC,CAAChE,OAAO,CAAC,UAACd,IAAI;IAC3C,IAAMmE,QAAQ,GAAGW,kBAAkB,CAAC9E,IAAI,CAAC;IACzC,IAAImE,QAAQ,CAAC,WAAW,CAAC,CAACa,IAAI,KAAK1C,IAAI,EAAE;MACvCyC,0BAA0B,CAAC/E,IAAI,CAAC,GAC9BmE,QAAkD;;GAEvD,CAAC;EAEF,OAAOY,0BAA0B;AACnC;;SCDgBE,cAAcA,CAAAvG,IAAA;MAC5BwG,eAAe,GAAAxG,IAAA,CAAfwG,eAAe;IACfJ,kBAAkB,GAAApG,IAAA,CAAlBoG,kBAAkB;IAClBK,cAAc,GAAAzG,IAAA,CAAdyG,cAAc;IACdC,qBAAqB,GAAA1G,IAAA,CAArB0G,qBAAqB;IACrBC,QAAQ,GAAA3G,IAAA,CAAR2G,QAAQ;IACRhF,OAAO,GAAA3B,IAAA,CAAP2B,OAAO;EASP,IAAMiF,MAAM,GAAG;IACbC,IAAI,EAAE,EAAgC;IACtCC,KAAK,EAAE,EAAgC;IACvCC,KAAK,EAAE;GACR;EAAC,IAAAC,KAAA,YAAAA,MAESpH,SAAS;IAAA,IAAAqH,oBAAA;IAClB,IAAMC,UAAU,GAAGV,eAAe,CAAC5G,SAAS,CAAC;IAE7C,IAAIsH,UAAU,KAAKC,SAAS,EAAE;MAC5B;;IAGF,IAAM1B,QAAQ,GAAGW,kBAAkB,CAACxG,SAAS,CAAC;IAC9C,IAAMwH,gBAAgB,GACpB3B,QAAQ,CAAC,WAAW,CAAC,CAACa,IAAI,KAAK,OAAO,IAAI,CAACb,QAAQ,CAAC,WAAW,CAAC,CAACxH,QAAQ;IAC3E,IAAMoJ,SAAS,IAAAJ,oBAAA,GACbxB,QAAQ,CAAC,WAAW,CAAC,CAAC6B,eAAe,CAACD,SAAS,YAAAJ,oBAAA,GAAIG,gBAAgB;IAErE,IAAMG,QAAQ,GAAG,SAAXA,QAAQA,CAAIL,UAAmB;MACnC,IAAInK,KAAoB;MAExB,IAAI0I,QAAQ,CAAC,WAAW,CAAC,CAACxE,KAAK,EAAE;QAC/B,IAAI,CAACjE,KAAK,CAACC,OAAO,CAACiK,UAAU,CAAC,EAAE;UAC9B,AAAa;YACX,MAAM3J,cAAc,CAACwC,wCAAwC,CAACyC,MAAM,CAClE;cACEnF,OAAO,EAAE,wBAAwB;cACjC8C,UAAU,EAAErD,MAAM,CAACoK,UAAU,CAAC;cAC9BhH,YAAY,EAAE,OAAO;cACrBnD,KAAK,EAAEmK,UAAU;cACjBjH,SAAS,EAAEL;aACZ,CACF;;;QAIL7C,KAAK,GACFmK,UAAwB,CAACrG,MAAM,KAAK,CAAC,GAClC,IAAI,GACHqG,UAAwB,CACtB5G,GAAG,CAAC,UAACwF,IAAI;UAAA,OAAKzF,SAAS,CAACoF,QAAQ,EAAEK,IAAI,EAAEuB,SAAS,CAAC;UAAC,CACnD1I,IAAI,CAAC8H,cAAc,CAAC;OAC9B,MAAM;QACL1J,KAAK,GAAGsD,SAAS,CAACoF,QAAQ,EAAEyB,UAAU,EAAEG,SAAS,CAAC;;MAGpD,OAAOtK,KAAK;KACb;IAED,IAAMA,KAAK,GAAGwK,QAAQ,CAACL,UAAU,CAAC;IAElC,IACEzB,QAAQ,CAAC,WAAW,CAAC,CAACa,IAAI,KAAK,OAAO,IACtCb,QAAQ,CAAC,WAAW,CAAC,WAAQ,KAAK0B,SAAS,IAC3CI,QAAQ,CAAC9B,QAAQ,CAAC,WAAW,CAAC,WAAQ,CAAC,KAAK1I,KAAK,EACjD;MACA;;IAGF6J,MAAM,CAACnB,QAAQ,CAAC,WAAW,CAAC,CAACa,IAAI,CAAC,CAAC1G,SAAS,CAAC,GAAG;MAC9C4H,iBAAiB,EAAE/B,QAAQ,CAAC,WAAW,CAAC,CAAC6B,eAAe,CAACG,EAAE;MAC3DxG,KAAK,EAAEwE,QAAQ,CAAC,WAAW,CAAC,CAACxE,KAAK;MAClClE,KAAK,EAALA;KACD;;EA1DH,KAAK,IAAM6C,SAAS,IAAIwG,kBAAkB,EAAE;IAAA,IAAAsB,IAAA,GAAAV,KAAA,CAAjCpH,SAAS;IAAA,IAAA8H,IAAA,iBAmDhB;;EAUJ,IAAMb,IAAI,GACR,GAAG,GACHF,QAAQ,CAAC,CAAC,CAAC,CACRpI,MAAM,CAAC,UAAAkC,KAAA;QAAGmF,aAAa,GAAAnF,KAAA,CAAbmF,aAAa;IACtB,OAAO,EACLA,aAAa,YAAbA,aAAa,CAAG,WAAW,CAAC,CAACD,QAAQ,IACrCiB,MAAM,CAACC,IAAI,CAACjB,aAAa,CAAChG,SAAS,CAAC,KAAKuH,SAAS,CACnD;GACF,CAAC,CACD7G,GAAG,CAAC,UAAAU,KAAA;QAAG4E,aAAa,GAAA5E,KAAA,CAAb4E,aAAa;MAAE5H,OAAO,GAAAgD,KAAA,CAAPhD,OAAO;MAAEC,QAAQ,GAAA+C,KAAA,CAAR/C,QAAQ;IACtC,IAAM0J,QAAQ,GAAG/B,aAAa,GAC1BgB,MAAM,CAACC,IAAI,CAACjB,aAAa,CAAChG,SAAS,CAAC,CAAC7C,KAAK,GAC1C,EAAE;IACN,OAAOiB,OAAO,GAAG2J,QAAQ,GAAG1J,QAAQ;GACrC,CAAC,CACDU,IAAI,CAAC,GAAG,CAAC;EAEd,IAAMiJ,cAAc,GAAG1F,MAAM,CAACC,IAAI,CAACyE,MAAM,CAACE,KAAK,CAAC,CAACjG,MAAM,GAAG,CAAC;EAE3D,IAAMiG,KAAK,GAAGc,cAAc,GACxBlB,qBAAqB,CAACrG,SAAS,CAACuG,MAAM,CAACE,KAAK,CAAC,GAC7CK,SAAS;EAEb,AAAa;IACX,IAAIS,cAAc,EAAE;MAClBzE,MAAM,CAAC,OAAO,EAAE,CAACA,MAAM,CAACS,IAAI,CAAC,QAAQ,EAAE,OAAO,EAAEkD,KAAK,CAAC,CAAC,CAAC;;;EAI5D,IAAMC,KAAK,GACT7E,MAAM,CAACC,IAAI,CAACyE,MAAM,CAACG,KAAK,CAAC,CAAClG,MAAM,KAAK,CAAC,GAClCsG,SAAS,GACTjF,MAAM,CAACC,IAAI,CAACyE,MAAM,CAACG,KAAK,CAAC,CAACc,MAAM,CAC9B,UAACd,KAAK,EAAE1E,GAAG;IAAA,IAAAyF,SAAA;IAAA,OAAAnD,QAAA,KACNoC,KAAK,GAAAe,SAAA,OAAAA,SAAA,CACPzF,GAAG,IAAGuE,MAAM,CAACG,KAAK,CAAC1E,GAAG,CAAC,CAACtF,KAAK,EAAA+K,SAAA;GAC9B,EACF,EAAE,CACH;EAEP,OAAO;IACLC,QAAQ,EAAE,CAACpG,OAAO,KAAK,GAAG,GAAG,EAAE,GAAGA,OAAO,IAAIkF,IAAI;IACjDA,IAAI,EAAJA,IAAI;IACJC,KAAK,EAALA,KAAK;IACLC,KAAK,EAALA;GACD;AACH;AAEA,SAAS1G,SAASA,CAChBoF,QAA0B,EAC1B1I,KAAc,EACdsK,SAAkB;EAElB,IAAMW,MAAM,GAAGvC,QAAQ,CAAC,WAAW,CAAC,CAAC6B,eAAe,CAACjH,SAAS,CAACtD,KAAK,CAAC;EAErE,AAAa;IACXoG,MAAM,CAAC,6BAA6B,EAAE,CACpCA,MAAM,CAACS,IAAI,CAAC,QAAQ,EAAE,QAAQ,EAAEoE,MAAM,CAAC,CACxC,CAAC;;EAGJ,OAAOX,SAAS,GAAG5I,kBAAkB,CAACuJ,MAAM,CAAC,GAAGA,MAAM;AACxD;;IChKaC,OAAO,GAAG;EAAEC,SAAS,EAAE;CAAe;;ACA5C,IAAMC,WAAW,GAAG;EAAEC,UAAU,EAAVA,UAAU;EAAEC,QAAQ,EAARA,QAAQ;EAAEC,UAAU,EAAVA;CAAY;AAE/D,SAASF,UAAUA,CAACrL,KAAa,EAAEwL,KAAa;EAC9C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,KAAK,CAAC1H,MAAM,EAAE2H,CAAC,EAAE,EAAE;IACrC,IAAID,KAAK,CAACC,CAAC,CAAC,KAAKzL,KAAK,CAACyL,CAAC,CAAC,EAAE;MACzB,OAAO,KAAK;;;EAGhB,OAAO,IAAI;AACb;AAEA,SAASH,QAAQA,CAACtL,KAAa,EAAE0L,GAAW;EAC1C,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIC,GAAG,CAAC5H,MAAM,EAAE2H,CAAC,EAAE,EAAE;IACpC,IAAIC,GAAG,CAACA,GAAG,CAAC5H,MAAM,GAAG2H,CAAC,CAAC,KAAKzL,KAAK,CAACA,KAAK,CAAC8D,MAAM,GAAG2H,CAAC,CAAC,EAAE;MACnD,OAAO,KAAK;;;EAGhB,OAAO,IAAI;AACb;AAEA,SAASF,UAAUA,CAACvL,KAAa,EAAEuB,KAAa;EAC9C,IAAAoK,YAAA,GAAyB3L,KAAK,CAACuB,KAAK,CAACA,KAAK,CAAC;IAApCqK,KAAK,GAAAD,YAAA;IAAKE,IAAI,GAAAF,YAAA,CAAAxD,KAAA;EACrB,OAAO,CAACyD,KAAK,EAAEC,IAAI,CAACjK,IAAI,CAACL,KAAK,CAAC,CAAU;AAC3C;;ACnBA,IAAQ+J,UAAQ,GAAiBF,WAAW,CAApCE,QAAQ;EAAED,YAAU,GAAKD,WAAW,CAA1BC,UAAU;AAE5B,SAAgBS,YAAYA,CAAA7I,IAAA;MAC1B6G,IAAI,GAAA7G,IAAA,CAAJ6G,IAAI;IACJF,QAAQ,GAAA3G,IAAA,CAAR2G,QAAQ;IACRF,cAAc,GAAAzG,IAAA,CAAdyG,cAAc;EAMd,KAAK,IAAI3C,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG6C,QAAQ,CAAC9F,MAAM,EAAEiD,KAAK,EAAE,EAAE;IACpD,IAAMkE,MAAM,GAAGc,KAAK,CAACnC,QAAQ,CAAC7C,KAAK,CAAC,CAAC;IACrC,IAAIkE,MAAM,KAAK,KAAK,EAAE;MACpB,OAAArD,QAAA,KAAYqD,MAAM;QAAEe,WAAW,EAAEjF,KAAK,KAAK;;;;EAI/C,OAAO,KAAK;EAEZ,SAASgF,KAAKA,CAAC1D,OAAgB;IAC7B,IAAMwB,MAAM,GAA4B,EAAE;IAE1C,IAAIC,IAAI,KAAK,GAAG,IAAIzB,OAAO,CAACvE,MAAM,KAAK,CAAC,EAAE;MACxC,OAAO;QAAE+F,MAAM,EAANA,MAAM;QAAEoC,mBAAmB,EAAE;OAAG;;IAG3C,IAAMC,oBAAoB,GAAGpC,IAAI,CAAChG,MAAM,GAAG,CAAC,IAAIwH,UAAQ,CAACxB,IAAI,EAAE,GAAG,CAAC;IAEnE,IAAIoC,oBAAoB,EAAE;MACxBpC,IAAI,GAAGA,IAAI,CAAC3B,KAAK,CAAC,CAAC,EAAE2B,IAAI,CAAChG,MAAM,GAAG,CAAC,CAAC;;IAGvC,IAAMqI,eAAe,GAAGrC,IAAI,CAACvI,KAAK,CAAC,GAAG,CAAC,CAAC4G,KAAK,CAAC,CAAC,CAAC;IAAC,IAAA8B,KAAA,YAAAA,MAG3CmC,YAAY;MAAA,IAAAC,sBAAA,EAAAC,sBAAA;MAIhB,IAAMC,cAAc,GAClBH,YAAY,IAAI/D,OAAO,CAACvE,MAAM,GAAG,IAAI,GAAGuE,OAAO,CAAC+D,YAAY,CAAC;MAC/D,IAAII,WAAW,GACbJ,YAAY,IAAID,eAAe,CAACrI,MAAM,GAClC,IAAI,GACJqI,eAAe,CAACC,YAAY,CAAC;MAEnC,IAAIG,cAAc,KAAK,IAAI,EAAE;QAC3B;UAAAE,CAAA,EAAO;;;MAGT,IAAMC,2BAA2B,GAAGrE,OAAO,CAACvE,MAAM,GAAG,CAAC,GAAGsI,YAAY;MAErE,IAAII,WAAW,KAAK,IAAI,EAAE;QAAA,IAAAG,qBAAA;QACxB,IACED,2BAA2B,KAAK,CAAC,IACjC,GAAAC,qBAAA,GAACJ,cAAc,CAAC1D,aAAa,aAA5B8D,qBAAA,CAA+B,WAAW,CAAC,CAAC/D,QAAQ,GACrD;UACA;YAAA6D,CAAA,EAAO;;;QAGT;;MAGF,KAAAJ,sBAAA,GAAIE,cAAc,CAAC1D,aAAa,aAA5BwD,sBAAA,CAA+B,WAAW,CAAC,CAACnL,QAAQ,EAAE;QACxDsL,WAAW,GAAGL,eAAe,CAAChE,KAAK,CAACiE,YAAY,CAAC,CAACxK,IAAI,CAAC,GAAG,CAAC;;MAG7D,IAAI,CAACyJ,YAAU,CAACmB,WAAW,EAAED,cAAc,CAACtL,OAAO,CAAC,EAAE;QACpD;UAAAwL,CAAA,EAAO;;;MAGT,IAAMG,uBAAuB,GAAGJ,WAAW,CAACrE,KAAK,CAC/CoE,cAAc,CAACtL,OAAO,CAAC6C,MAAM,CAC9B;MAED,IAAI,CAACwH,UAAQ,CAACsB,uBAAuB,EAAEL,cAAc,CAACrL,QAAQ,CAAC,EAAE;QAC/D;UAAAuL,CAAA,EAAO;;;MAGT,IAAMI,kCAAkC,GAAGD,uBAAuB,CAACzE,KAAK,CACtE,CAAC,EACDyE,uBAAuB,CAAC9I,MAAM,GAAGyI,cAAc,CAACrL,QAAQ,CAAC4C,MAAM,CAChE;MAED,IAAI,CAACyI,cAAc,CAAC1D,aAAa,EAAE;QACjC,IAAIgE,kCAAkC,KAAK,EAAE,EAAE;UAC7C;;QAGF;UAAAJ,CAAA,EAAO;;;MAGT,IAAII,kCAAkC,KAAK,EAAE,EAAE;QAC7C,IAAIN,cAAc,CAAC1D,aAAa,CAAC,WAAW,CAAC,CAACD,QAAQ,EAAE;UACtD;;QAGF;UAAA6D,CAAA,EAAO;;;MAGT,IAAMnC,SAAS,IAAAgC,sBAAA,GACbC,cAAc,CAAC1D,aAAa,CAAC,WAAW,CAAC,CAAC0B,eAAe,CAACD,SAAS,YAAAgC,sBAAA,GACnE,CAACC,cAAc,CAAC1D,aAAa,CAAC,WAAW,CAAC,CAAC3H,QAAQ;MAErD,IAAIlB,KAAK;MAET,IAAIuM,cAAc,CAAC1D,aAAa,CAAC,WAAW,CAAC,CAAC3E,KAAK,EAAE;QACnDlE,KAAK,GAAG6M,kCAAkC,CACvCtL,KAAK,CAACmI,cAAc,CAAC,CACrBnG,GAAG,CAAC,UAACwF,IAAI;;UACR,QAAA+D,sBAAA,GAAOP,cAAc,CAAC1D,aAAa,qBAA5BiE,sBAAA,CACL,WAAW,CACZ,CAACvC,eAAe,CAACwC,KAAK,CACrBzC,SAAS,GAAG0C,kBAAkB,CAACjE,IAAI,CAAC,GAAGA,IAAI,CAC5C;SACF,CAAC;QAEJ,IAAI/I,KAAK,CAACiN,IAAI,CAAC,UAAClE,IAAI;UAAA,OAAKA,IAAI,KAAKmC,OAAO;UAAC,EAAE;UAC1C;YAAAuB,CAAA,EAAO;;;OAEV,MAAM;QACLzM,KAAK,GAAGuM,cAAc,CAAC1D,aAAa,CAAC,WAAW,CAAC,CAAC0B,eAAe,CAACwC,KAAK,CACrEzC,SAAS,GACL0C,kBAAkB,CAACH,kCAAkC,CAAC,GACtDA,kCAAkC,CACvC;QAED,IAAI7M,KAAK,KAAKkL,OAAO,EAAE;UACrB;YAAAuB,CAAA,EAAO;;;;MAIX,IACEF,cAAc,CAAC1D,aAAa,CAAC,WAAW,CAAC,CAAC3H,QAAQ,IAClDgL,oBAAoB,IACpBK,cAAc,CAACrL,QAAQ,KAAK,EAAE,EAC9B;QACAlB,KAAK,GAAMA,KAAK,MAAG;;MAGrB6J,MAAM,CAAC0C,cAAc,CAAC1D,aAAa,CAAChG,SAAS,CAAC,GAAG7C,KAAK;MAEtD,IAAIuM,cAAc,CAAC1D,aAAa,CAAC,WAAW,CAAC,CAAC3H,QAAQ,EAAE;QACtD;;;IA7GJ,KACE,IAAIkL,YAAY,GAAG,CAAC,EACpBA,YAAY,GAAGc,IAAI,CAACrJ,GAAG,CAACwE,OAAO,CAACvE,MAAM,EAAEqI,eAAe,CAACrI,MAAM,CAAC,EAC/DsI,YAAY,EAAE,EACd;MAAA,IAAAzB,IAAA,GAAAV,KAAA,CAHImC,YAAY;MAAA,IAAAzB,IAAA,cA4Gd;MAAM,IAAAA,IAAA,iBAjDJ;MAAS,WAAAA,IAAA,sBAAAA,IAAA,CAAA8B,CAAA;;IAqDf,OAAO;MAAE5C,MAAM,EAANA,MAAM;MAAEoC,mBAAmB,EAAE;KAAG;;AAE7C;;SCvJgBkB,cAAcA,CAAAlK,IAAA;MAC5BmK,MAAM,GAAAnK,IAAA,CAANmK,MAAM;IACNC,SAAS,GAAApK,IAAA,CAAToK,SAAS;IACThD,gBAAgB,GAAApH,IAAA,CAAhBoH,gBAAgB;IAChBX,cAAc,GAAAzG,IAAA,CAAdyG,cAAc;EAOd,IAAMG,MAAM,GAA4B,EAAE;EAE1C,IAAMyD,cAAc,GAAGnI,MAAM,CAACC,IAAI,CAACiI,SAAS,CAAC,CAAC9J,GAAG,CAAC,UAACgB,IAAI;IACrD,OAAAqD,QAAA;MAASrD,IAAI,EAAJA;OAAS8I,SAAS,CAAC9I,IAAI,CAAC;GAClC,CAAC;EAEF,IAAMgJ,gBAAgB,GAAA3F,QAAA,KAAQwF,MAAM,CAAE;EAAC,IAAAnD,KAAA,YAAAA;IAAA,IAE5BvB,QAAQ,GAAAvB,KAAA,CAAAnH,KAAA;IACjB,IAAIwN,GAAG,GAAGJ,MAAM,CAAC1E,QAAQ,CAACnE,IAAI,CAAC;IAC/B,OAAOgJ,gBAAgB,CAAC7E,QAAQ,CAACnE,IAAI,CAAC;IAEtC,IAAIiJ,GAAG,KAAKpD,SAAS,EAAE;MACrB,IAAI1B,QAAQ,CAAC,WAAW,CAAC,CAACE,QAAQ,EAAE;QAClC;;MAGF;QAAA6D,CAAA,EAAO;;;IAGT,IAAIzM,KAAK;IAET,IAAIwN,GAAG,KAAK,IAAI,EAAE;MAChB,IAAI9E,QAAQ,CAAC,WAAW,CAAC,CAACxE,KAAK,EAAE;QAC/BlE,KAAK,GAAG,EAAE;OACX,MAAM,IAAI0I,QAAQ,CAAC,WAAW,CAAC,CAACE,QAAQ,EAAE;QACzC;OACD,MAAM;QACL;UAAA6D,CAAA,EAAO;;;KAEV,MAAM,IAAI/D,QAAQ,CAAC,WAAW,CAAC,CAACxE,KAAK,EAAE;MACtClE,KAAK,GAAGwN,GAAG,CAACjM,KAAK,CAACmI,cAAc,CAAC,CAACnG,GAAG,CAAC,UAACwF,IAAI;;QACzC,OAAOL,QAAQ,CAAC,WAAW,CAAC,CAAC6B,eAAe,CAACwC,KAAK,CAChD,EAAA7C,oBAAA,GAAAxB,QAAQ,CAAC,WAAW,CAAC,CAAC6B,eAAe,CAACD,SAAS,YAAAJ,oBAAA,GAAIG,gBAAgB,IAC/D2C,kBAAkB,CAACjE,IAAI,CAAC,GACxBA,IAAI,CACT;OACF,CAAC;MAEF,IAAI/I,KAAK,CAACiN,IAAI,CAAC,UAAClE,IAAI;QAAA,OAAKA,IAAI,KAAKmC,OAAO;QAAC,EAAE;QAC1C,IAAIxC,QAAQ,CAAC,WAAW,CAAC,CAACE,QAAQ,EAAE;UAClC;;QAGF;UAAA6D,CAAA,EAAO;;;KAEV,MAAM;MAAA,IAAAgB,qBAAA;MACLzN,KAAK,GAAG0I,QAAQ,CAAC,WAAW,CAAC,CAAC6B,eAAe,CAACwC,KAAK,CACjD,EAAAU,qBAAA,GAAA/E,QAAQ,CAAC,WAAW,CAAC,CAAC6B,eAAe,CAACD,SAAS,YAAAmD,qBAAA,GAAIpD,gBAAgB,IAC/D2C,kBAAkB,CAACQ,GAAG,CAAC,GACvBA,GAAG,CACR;MAED,IAAIxN,KAAK,KAAKkL,OAAO,EAAE;QACrB,IAAIxC,QAAQ,CAAC,WAAW,CAAC,CAACE,QAAQ,EAAE;UAClC;;QAGF;UAAA6D,CAAA,EAAO;;;;IAIX5C,MAAM,CAACnB,QAAQ,CAACnE,IAAI,CAAC,GAAGvE,KAAK;;EAtD/B,SAAAiH,SAAA,GAAAC,+BAAA,CAAuBoG,cAAc,GAAAnG,KAAA,IAAAA,KAAA,GAAAF,SAAA,IAAAG,IAAA,GAAE;IAAA,IAAAuD,IAAA,GAAAV,KAAA;IAAA,IAAAU,IAAA,iBA+C/B;IAAS,WAAAA,IAAA,sBAAAA,IAAA,CAAA8B,CAAA;;EAUjB,OAAO;IAAE5C,MAAM,EAANA,MAAM;IAAEoC,mBAAmB,EAAE9G,MAAM,CAACC,IAAI,CAACmI,gBAAgB,CAAC,CAACzJ;GAAQ;AAC9E;;SC7EgB4J,aAAaA,CAC3B1D,KAAyC,EACzCqD,SAAsC,EACtC3D,cAAsB;EAEtB,OAAOyD,cAAc,CAAC;IACpBC,MAAM,EAAEpD,KAAK,WAALA,KAAK,GAAI,EAAE;IACnBqD,SAAS,EAATA,SAAS;IACThD,gBAAgB,EAAE,KAAK;IACvBX,cAAc,EAAdA;GACD,CAAC;AACJ;;SCVgBiE,aAAaA,CAC3B5D,KAAyB,EACzBsD,SAAsC,EACtC1D,qBAA4C,EAC5CD,cAAsB;EAEtB,IAAI0D,MAAM,GAAkC,EAAE;EAE9C,IAAIrD,KAAK,EAAE;IACTqD,MAAM,GAAGzD,qBAAqB,CAACoD,KAAK,CAAChD,KAAK,CAAC;IAE3C,AAAa;MACX3D,MAAM,CAAC,+BAA+B,EAAE,CACtCA,MAAM,CAACI,gBAAgB,CACrB,CAAC,QAAQ,EAAE,MAAM,CAAC,EAClB,mBAAmB,EACnB4G,MAAM,CACP,CACF,CAAC;;;EAIN,OAAOD,cAAc,CAAC;IACpBC,MAAM,EAANA,MAAM;IACNC,SAAS,EAATA,SAAS;IACThD,gBAAgB,EAAE,IAAI;IACtBX,cAAc,EAAdA;GACD,CAAC;AACJ;;SCrBgBkE,aAAaA,CAAA3K,IAAA;MAC3B2G,QAAQ,GAAA3G,IAAA,CAAR2G,QAAQ;IACRC,MAAM,GAAA5G,IAAA,CAAN4G,MAAM;EAKN,IAAMgE,uBAAuB,GAAGzE,kBAAkB,CAAC,OAAO,EAAES,MAAM,CAAC;EACnE,IAAMiE,uBAAuB,GAAG1E,kBAAkB,CAAC,OAAO,EAAES,MAAM,CAAC;EAEnE,IAAMkE,aAAa,GAA4B,EAAE;EAEjD5I,MAAM,CAACC,IAAI,CAACyE,MAAM,CAAC,CAACxE,OAAO,CAAC,UAACxC,SAAS;IACpC,IAAMmL,KAAK,GAAGnE,MAAM,CAAChH,SAAS,CAAC;IAC/B,IAAImL,KAAK,CAAC,WAAW,CAAC,WAAQ,KAAK5D,SAAS,EAAE;MAC5C;;IAEF2D,aAAa,CAAClL,SAAS,CAAC,GAAGmL,KAAK,CAAC,WAAW,CAAC,WAAQ;GACtD,CAAC;EAEF,OAAO,UAAAtK,KAAA;QACLuK,cAAc,GAAAvK,KAAA,CAAduK,cAAc;MACdvE,cAAc,GAAAhG,KAAA,CAAdgG,cAAc;MACdC,qBAAqB,GAAAjG,KAAA,CAArBiG,qBAAqB;IAMrB,IAAIsE,cAAc,CAACnE,IAAI,KAAKM,SAAS,EAAE;MACrC,OAAO,KAAK;;IAGd,IAAM8D,SAAS,GAAGpC,YAAY,CAAC;MAC7BhC,IAAI,EAAEmE,cAAc,CAACnE,IAAI;MACzBF,QAAQ,EAARA,QAAQ;MACRF,cAAc,EAAdA;KACD,CAAC;IAEF,IAAIwE,SAAS,KAAK,KAAK,EAAE;MACvB,OAAO,KAAK;;IAGd,IAAMC,UAAU,GAAGR,aAAa,CAC9BM,cAAc,CAAClE,KAAK,EACpB8D,uBAAuB,EACvBlE,qBAAqB,EACrBD,cAAc,CACf;IACD,IAAIyE,UAAU,KAAK,KAAK,EAAE;MACxB,OAAO,KAAK;;IAGd,IAAMC,UAAU,GAAGV,aAAa,CAC9BO,cAAc,CAACjE,KAAK,EACpB8D,uBAAuB,EACvBpE,cAAc,CACf;IACD,IAAI0E,UAAU,KAAK,KAAK,EAAE;MACxB,OAAO,KAAK;;IAGd,OAAO;MACLpC,WAAW,EAAEkC,SAAS,CAAClC,WAAW;MAClCnC,MAAM,EAAAjC,QAAA,KACDmG,aAAa,EACbG,SAAS,CAACrE,MAAM,EAChBsE,UAAU,CAACtE,MAAM,EACjBuE,UAAU,CAACvE,MAAM,CACrB;MACDoC,mBAAmB,EACjBiC,SAAS,CAACjC,mBAAmB,GAC7BkC,UAAU,CAAClC,mBAAmB,GAC9BmC,UAAU,CAACnC;KACd;GACF;AACH;;SCrFgBoC,+BAA+BA,CAACC;MAAAA;IAAAA,QAAa,EAAE;;EAC7D,IAAMC,CAAC,GAAGD,KAAmB;EAC7B,IAAME,eAAe,GAAG,CAAC,EAAED,CAAC,CAACE,OAAO,IAAIF,CAAC,CAACG,MAAM,IAAIH,CAAC,CAACI,OAAO,IAAIJ,CAAC,CAACK,QAAQ,CAAC;EAE5E,IAAMC,YAAY,GAChB,CAACN,CAAC,CAACO,MAAM,IAAI,CAACP,CAAC,CAACO,MAAM,CAACA,MAAM,IAAIP,CAAC,CAACO,MAAM,CAACA,MAAM,KAAK,OAAO;EAE9D,IACED,YAAY;;EACZ,CAACN,CAAC,CAACQ,gBAAgB;;EACnBR,CAAC,CAACS,MAAM,KAAK,CAAC;;EACd,CAACR,eAAe;IAChB;IACA,IAAID,CAAC,IAAIA,CAAC,CAACU,cAAc,EAAE;MACzBV,CAAC,CAACU,cAAc,EAAE;;IAGpB,OAAO,IAAI;;EAGb,OAAO,KAAK;AACd;;ACnBA,IAAQ5D,YAAU,GAAKD,WAAW,CAA1BC,UAAU;AAElB,SAAgB6D,UAAUA,CAAAjM,IAAA;MACxB7C,SAAS,GAAA6C,IAAA,CAAT7C,SAAS;IACTyJ,MAAM,GAAA5G,IAAA,CAAN4G,MAAM;IACNsF,QAAQ,GAAAlM,IAAA,CAARkM,QAAQ;IACRC,aAAa,GAAAnM,IAAA,CAAbmM,aAAa;EAOb,IAAQC,QAAQ,GAAcD,aAAa,CAAnCC,QAAQ;IAAEC,OAAO,GAAKF,aAAa,CAAzBE,OAAO;EAEzB,IAAIC,IAAI,GAAGD,OAAO,CAACE,UAAU,CAAC;IAC5BC,QAAQ,EAAErP,SAAS,KAAK,KAAK,GAAG+O,QAAQ,CAACnE,QAAQ,GAAGmE,QAAQ,CAACrF,IAAI;IACjE4F,MAAM,EAAEP,QAAQ,CAACpF,KAAK,GAAG,GAAG,GAAGoF,QAAQ,CAACpF,KAAK,GAAG;GACjD,CAAC;EAEF,IAAIsB,YAAU,CAACkE,IAAI,EAAE,GAAG,CAAC,EAAE;IACzBA,IAAI,GAAG,GAAG,GAAGA,IAAI;;EAGnB,IAAInP,SAAS,KAAK,KAAK,IAAIgP,aAAa,CAACxK,OAAO,KAAK,GAAG,EAAE;IACxD2K,IAAI,GAAGH,aAAa,CAACxK,OAAO,GAAG2K,IAAI;;EAGrC,IAAMI,KAAK,GAAkB;IAC3BpL,IAAI,EAAEnE,SAAS;IACfyJ,MAAM,EAANA,MAAM;IACN0F,IAAI,EAAJA,IAAI;IACJK,IAAI,EAAE;MACJL,IAAI,EAAJA,IAAI;MACJM,OAAO,EAAE,SAAAA,QAACvB,KAAK;QACb,IAAID,+BAA+B,CAACC,KAAK,CAAC,EAAE;UAC1C,OAAOqB,KAAK,CAACrN,IAAI,EAAE;;;KAGxB;IACDwN,MAAM,EAAE,IAAI;IACZxN,IAAI,EAAE,SAAAA;MAAA,OAAM+M,QAAQ,CAAAzH,QAAA,KAAM+H,KAAK;QAAEG,MAAM,EAAE;UAAU,IAAI,CAAC;;IACxDhL,OAAO,EAAE,SAAAA;MAAA,OAAMuK,QAAQ,CAAAzH,QAAA,KAAM+H,KAAK;QAAEG,MAAM,EAAE;UAAa,IAAI,CAAC;;GAC/D;EAED,OAAOH,KAAK;AACd;;SCzCgBI,kBAAkBA,CAChC3P,SAAiB,EACjB4P,QAA0B,EAC1BC,gBAAqC;EAErC,IAAMrG,QAAQ,GAAGrC,aAAa,CAC5BnH,SAAS,EACTgJ,kBAAkB,CAAC,MAAM,EAAE4G,QAAQ,CAAC,WAAW,CAAC,CAACnG,MAAM,CAAC,EACxDmG,QAAQ,CAAC,WAAW,CAAC,CAAClG,IAAI,CAC3B;EAED,IAAMoG,KAAK,GAAyB,SAA9BA,KAAKA,CACTrG;QAAAA;MAAAA,SAAkC,EAAE;;IAEpC,AAAa;MACXzD,MAAM,aAAWhG,SAAS,EAAI,CAC5BgG,MAAM,CAACG,OAAO,CAAC,EAAE,CAAC4B,KAAK,CAACgI,IAAI,CAACvK,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC9CQ,MAAM,CAACS,IAAI,CAAC,QAAQ,EAAE,QAAQ,EAAEgD,MAAM,CAAC,CACxC,CAAC;MAEF,KAAK,IAAMuG,QAAQ,IAAIvG,MAAM,EAAE;QAC7B,IAAI,EAAEuG,QAAQ,IAAIJ,QAAQ,CAAC,WAAW,CAAC,CAACnG,MAAM,CAAC,EAAE;UAC/C,MAAMrJ,cAAc,CAAC2D,oDAAoD,CAACsB,MAAM,CAC9E;YACErF,SAAS,EAATA,SAAS;YACTiE,uBAAuB,EAAE+L,QAAQ;YACjC9L,qBAAqB,EAAEa,MAAM,CAACC,IAAI,CAAC4K,QAAQ,CAAC,WAAW,CAAC,CAACnG,MAAM;WAChE,CACF;;;MAIL,KAAK,IAAMuG,SAAQ,IAAIJ,QAAQ,CAAC,WAAW,CAAC,CAACnG,MAAM,EAAE;QACnD,IAAM7J,KAAK,GAAG6J,MAAM,CAACuG,SAAQ,CAAC;QAC9B,IAAM1H,QAAQ,GAAGsH,QAAQ,CAAC,WAAW,CAAC,CAACnG,MAAM,CAACuG,SAAQ,CAAC,CAAC,WAAW,CAAC;QAEpE,IAAIpQ,KAAK,KAAKoK,SAAS,EAAE;UACvB,IAAI,CAAC1B,QAAQ,CAACE,QAAQ,EAAE;YACtB,MAAMpI,cAAc,CAACgE,8CAA8C,CAACiB,MAAM,CACxE;cACErF,SAAS,EAATA,SAAS;cACTsE,oBAAoB,EAAE0L;aACvB,CACF;;UAGH;;;;IAKN,IAAMhB,aAAa,GAAGa,gBAAgB,EAAE;IAExC,IAAQvG,cAAc,GAAqC0F,aAAa,CAAhE1F,cAAc;MAAEC,qBAAqB,GAAcyF,aAAa,CAAhDzF,qBAAqB;MAAE/E,OAAO,GAAKwK,aAAa,CAAzBxK,OAAO;IAEtD,IAAMyL,iBAAiB,GAAAzI,QAAA,KAAQiC,MAAM,CAAE;IAEvC1E,MAAM,CAACC,IAAI,CAAC4K,QAAQ,CAAC,WAAW,CAAC,CAACnG,MAAM,CAAC,CAACxE,OAAO,CAAC,UAACxC,SAAS;MAC1D,IAAM6F,QAAQ,GAAGsH,QAAQ,CAAC,WAAW,CAAC,CAACnG,MAAM,CAAChH,SAAS,CAAC;MAExD,IACEwN,iBAAiB,CAACxN,SAAS,CAAC,KAAKuH,SAAS,IAC1C1B,QAAQ,CAAC,WAAW,CAAC,WAAQ,KAAK0B,SAAS,EAC3C;QACAiG,iBAAiB,CAACxN,SAAS,CAAC,GAAG6F,QAAQ,CAAC,WAAW,CAAC,WAAQ;;KAE/D,CAAC;IAEF,IAAMyG,QAAQ,GAAG3F,cAAc,CAAC;MAC9BC,eAAe,EAAEI,MAAM;MACvBR,kBAAkB,EAAE2G,QAAQ,CAAC,WAAW,CAAC,CAACnG,MAAM;MAChDH,cAAc,EAAdA,cAAc;MACdC,qBAAqB,EAArBA,qBAAqB;MACrBC,QAAQ,EAARA,QAAQ;MACRhF,OAAO,EAAPA;KACD,CAAC;IAEF,OAAOsK,UAAU,CAAC;MAChB9O,SAAS,EAATA,SAAS;MACTyJ,MAAM,EAAEwG,iBAAiB;MACzBlB,QAAQ,EAARA,QAAQ;MACRC,aAAa,EAAbA;KACD,CAAQ;GACV;EAEDjK,MAAM,CAACmL,cAAc,CAACJ,KAAK,EAAE,MAAM,EAAE;IAAElQ,KAAK,EAAEI;GAAW,CAAC;EAE1D8P,KAAK,CAAC,WAAW,CAAC,GAAG;IACnBrJ,IAAI,EAAE,cAAc;IACpBkF,KAAK,EAAE6B,aAAa,CAAC;MACnBhE,QAAQ,EAARA,QAAQ;MACRC,MAAM,EAAEmG,QAAQ,CAAC,WAAW,CAAC,CAACnG;KAC/B,CAAQ;IACTD,QAAQ,EAARA,QAAQ;IACR2G,KAAK,EAAE;GACR;EAED,OAAOL,KAAK;AACd;;SCxGgBM,2BAA2BA,CACzC7M;;MAAAA;IAAAA,OAGI,EAAE;;EAEN,IAAM8M,sBAAsB,IAAAC,qBAAA,GAC1B/M,IAAI,CAAC8M,sBAAsB,YAAAC,qBAAA,GAAI,sBAAsB;EACvD,IAAMhH,cAAc,IAAAiH,oBAAA,GAAGhN,IAAI,CAAC+F,cAAc,YAAAiH,oBAAA,GAAI,GAAG;EAEjD,IAAMC,QAAQ,GACZH,sBAAsB,KAAK,UAAU,IACrCA,sBAAsB,KAAK,qBAAqB;EAElD,IAAMI,cAAc,GAClBJ,sBAAsB,KAAK,UAAU,IACrCA,sBAAsB,KAAK,WAAW,GAClC,EAAE,GACF,IAAI;EAEV,OAAO;IACL1D,KAAK,EAAE,SAAAA,MAACS,GAAG;MACT,IAAMsD,WAAW,GAAkC,EAAE;MAErD,SAAA7J,SAAA,GAAAC,+BAAA,CAAmBsG,GAAG,CAACjM,KAAK,CAAC,GAAG,CAAC,GAAA4F,KAAA,IAAAA,KAAA,GAAAF,SAAA,IAAAG,IAAA,GAAE;QAAA,IAAxB2B,IAAI,GAAA5B,KAAA,CAAAnH,KAAA;QACb,IAAA+Q,WAAA,GAA+ChI,IAAI,CAACxH,KAAK,CAAC,GAAG,CAAC;UAAvDyP,YAAY,GAAAD,WAAA;UAAEE,aAAa,GAAAF,WAAA;UAAKlF,IAAI,GAAAkF,WAAA,CAAA5I,KAAA;QAE3C,IAAI6I,YAAY,KAAK5G,SAAS,IAAIyB,IAAI,CAAC/H,MAAM,GAAG,CAAC,EAAE;UACjD;;QAGF,IAAMwB,GAAG,GAAG0H,kBAAkB,CAC5B5B,WAAW,CAACE,QAAQ,CAAC0F,YAAY,EAAEH,cAAc,CAAC,GAC9CG,YAAY,CAAC7I,KAAK,CAAC,CAAC,EAAE6I,YAAY,CAAClN,MAAM,GAAG+M,cAAc,CAAC/M,MAAM,CAAC,GAClEkN,YAAY,CACjB;QAED,IAAIC,aAAa,KAAK7G,SAAS,EAAE;UAC/B0G,WAAW,CAACxL,GAAG,CAAC,GAAG,IAAI;SACxB,MAAM,IAAIwL,WAAW,CAACxL,GAAG,CAAC,IAAIsL,QAAQ,EAAE;UACvCE,WAAW,CAACxL,GAAG,CAAC,SAAOoE,cAAc,GAAGuH,aAAe;SACxD,MAAM;UACLH,WAAW,CAACxL,GAAG,CAAC,GAAG2L,aAAa;;;MAIpC,OAAOH,WAAW;KACnB;IAEDxN,SAAS,EAAE,SAAAA,UAACwN,WAAW;MACrB,OAAO3L,MAAM,CAACC,IAAI,CAAC0L,WAAW,CAAC,CAC5BvN,GAAG,CAAC,UAACgB,IAAI;QACR,IAAM2M,WAAW,GAAGxP,kBAAkB,CAAC6C,IAAI,CAAC;QAC5C,IAAMe,GAAG,GAAGwL,WAAW,CAACvM,IAAI,CAAC,CAACL,KAAK,QAC5BgN,WAAW,GAAGL,cAAc,GAC/BK,WAAW;QACf,IAAMlR,KAAK,GAAG8Q,WAAW,CAACvM,IAAI,CAAC,CAACvE,KAAK;QAErC,IAAIA,KAAK,KAAK,IAAI,EAAE;UAClB,OAAOsF,GAAG;;QAGZ,IAAIwL,WAAW,CAACvM,IAAI,CAAC,CAACL,KAAK,IAAI0M,QAAQ,EAAE;UACvC,IAAMO,UAAU,GAAGnR,KAAK,CAACuB,KAAK,CAACmI,cAAc,CAAC;UAC9C,OAAOyH,UAAU,CAAC5N,GAAG,CAAC,UAACwF,IAAI;YAAA,OAAQzD,GAAG,SAAIyD,IAAI;WAAE,CAAC,CAACnH,IAAI,CAAC,GAAG,CAAC;;QAG7D,OAAU0D,GAAG,SAAItF,KAAK;OACvB,CAAC,CACD4B,IAAI,CAAC,GAAG,CAAC;;GAEf;AACH;;SCxEgBwP,gBAAgBA,CAC9BjC,QAAwB,EACxBC,aAA4B;EAE5B,IAAQiC,SAAS,GAA4CjC,aAAa,CAAlEiC,SAAS;IAAE1H,qBAAqB,GAAqByF,aAAa,CAAvDzF,qBAAqB;IAAED,cAAc,GAAK0F,aAAa,CAAhC1F,cAAc;EAExD,IAAM4H,MAAM,GAAGD,SAAS,EAAE;EAE1B,IAAIE,aAAa,GAA4C,KAAK;EAElE,KAAK,IAAMnR,SAAS,IAAIkR,MAAM,EAAE;IAC9B,IAAMvF,KAAK,GAAGuF,MAAM,CAAClR,SAAS,CAAC,CAAC,WAAW,CAAC,CAAC2L,KAAK,CAAC;MACjDkC,cAAc,EAAEkB,QAAQ;MACxBxF,qBAAqB,EAArBA,qBAAqB;MACrBD,cAAc,EAAdA;KACD,CAAC;IAEF,IAAIqC,KAAK,KAAK,KAAK,EAAE;MACnB;;IAGF,IAAIA,KAAK,CAACE,mBAAmB,KAAK,CAAC,EAAE;MACnC,OAAO;QACL0D,KAAK,EAAE2B,MAAM,CAAClR,SAAS,CAAC,CAAC2L,KAAK,CAAClC,MAAM,CAAC;QACtCmC,WAAW,EAAED,KAAK,CAACC;OACpB;;IAGH,IACEuF,aAAa,KAAK,KAAK,IACvBxF,KAAK,CAACE,mBAAmB,GAAGsF,aAAa,CAACtF,mBAAmB,EAC7D;MACAsF,aAAa,GAAA3J,QAAA,KAAQmE,KAAK;QAAE3L,SAAS,EAATA;QAAW;;;EAI3C,IAAImR,aAAa,EAAE;IACjB,OAAO;MACL5B,KAAK,EAAE2B,MAAM,CAACC,aAAa,CAACnR,SAAS,CAAC,CAACmR,aAAa,CAAC1H,MAAM,CAAC;MAC5DmC,WAAW,EAAEuF,aAAa,CAACvF;KAC5B;;EAGH,OAAO;IACL2D,KAAK,EAAET,UAAU,CAAC;MAChB9O,SAAS,EAAE,KAAK;MAChByJ,MAAM,EAAE,EAAE;MACVsF,QAAQ,EAARA,QAAQ;MACRC,aAAa,EAAbA;KACD,CAAC;IACFpD,WAAW,EAAE;GACd;AACH;;ACnDA,IAAQX,YAAU,GAAKD,WAAW,CAA1BC,UAAU;AAElB,SAAgBmG,0CAA0CA,CACxDC,WAAmE,EACnE7M,OAAe;EAEf,OAAO;IACLoG,QAAQ,EAAEyG,WAAW,CAAChC,QAAQ;IAC9B3F,IAAI,EAAEuB,YAAU,CAACoG,WAAW,CAAChC,QAAQ,EAAE7K,OAAO,CAAC,GAC3CA,OAAO,KAAK,GAAG,GACb6M,WAAW,CAAChC,QAAQ,CAAC3K,OAAO,CAACF,OAAO,EAAE,EAAE,CAAC,GACzC6M,WAAW,CAAChC,QAAQ,GACtBrF,SAAS;IACbL,KAAK,EAAE0H,WAAW,CAAC/B,MAAM,GACrBrE,YAAU,CAACoG,WAAW,CAAC/B,MAAM,EAAE,GAAG,CAAC,GACjC+B,WAAW,CAAC/B,MAAM,CAACvH,KAAK,CAAC,CAAC,CAAC,GAC3BsJ,WAAW,CAAC/B,MAAM,GACpBtF,SAAS;IACbJ,KAAK,EACH,OAAOyH,WAAW,CAACzH,KAAK,KAAK,QAAQ,IAAIyH,WAAW,CAACzH,KAAK,KAAK,IAAI,GAC9DyH,WAAW,CAACzH,KAA4C,CAACA,KAAK,GAC/DI;GACP;AACH;;ACtBA,IAAQmB,YAAU,GAAKH,WAAW,CAA1BG,UAAU;AAElB,SAAgBmG,cAAcA,CAC5BnC,IAAY,EACZvF,KAAU,EACVoF,aAA4B;EAE5B,IAAAuC,WAAA,GAA2BpG,YAAU,CAACgE,IAAI,EAAE,GAAG,CAAC;IAAzCE,QAAQ,GAAAkC,WAAA;IAAEjC,MAAM,GAAAiC,WAAA;EAEvB,IAAMxC,QAAQ,GAAGqC,0CAA0C,CACzD;IACE/B,QAAQ,EAARA,QAAQ;IACRC,MAAM,EAANA,MAAM;IACN1F,KAAK,EAALA;GACD,EACDoF,aAAa,CAACxK,OAAO,CACtB;EAED,OAAOwM,gBAAgB,CAACjC,QAAQ,EAAEC,aAAa,CAAC;AAClD;;SCtBgBwC,8BAA8BA,CAAA3O,IAAA;MAC5C4O,cAAc,GAAA5O,IAAA,CAAd4O,cAAc;IACdC,aAAa,GAAA7O,IAAA,CAAb6O,aAAa;EAKb,IAAMC,aAAa,GAGb,EAAE;EACR,IAAIC,SAAS,GAAG,CAAC;EAEjB,OAAO;IAAEC,GAAG,EAAHA,GAAG;IAAEC,WAAW,EAAXA;GAAa;EAE3B,SAASA,WAAWA;IAClB,OAAOH,aAAa,CAACxO,GAAG,CAAC,UAAAG,KAAA;MAAA,IAAGyO,OAAO,GAAAzO,KAAA,CAAPyO,OAAO;MAAA,OAAOA,OAAO;MAAC;;EAGpD,SAASF,GAAGA,CAACE,OAAkC;IAC7C,IAAMzH,EAAE,GAAGsH,SAAS,EAAE;IACtBD,aAAa,CAACzP,IAAI,CAAC;MAAEoI,EAAE,EAAFA,EAAE;MAAEyH,OAAO,EAAPA;KAAS,CAAC;IAEnC,IAAIJ,aAAa,CAACjO,MAAM,KAAK,CAAC,EAAE;MAC9B+N,cAAc,EAAE;;IAGlB,OAAOO,MAAM;IAEb,SAASA,MAAMA;MACb,IAAMrL,KAAK,GAAGgL,aAAa,CAACxO,GAAG,CAAC,UAAAU,KAAA;QAAA,IAAGyG,EAAE,GAAAzG,KAAA,CAAFyG,EAAE;QAAA,OAAOA,EAAE;QAAC,CAAC5C,OAAO,CAAC4C,EAAE,CAAC;MAC3D,IAAI3D,KAAK,IAAI,CAAC,EAAE;QACdgL,aAAa,CAACM,MAAM,CAACtL,KAAK,EAAE,CAAC,CAAC;QAC9B,IAAIgL,aAAa,CAACjO,MAAM,KAAK,CAAC,EAAE;UAC9BgO,aAAa,EAAE;;;;;AAKzB;;SCvCgBQ,kBAAkBA,CAChC3C,KAAoB;EAEpB,IACEA,KAAK,CAACG,MAAM,KAAK,MAAM,IACvB,OAAOyC,MAAM,KAAK,QAAQ,IAC1BA,MAAM,KAAK,IAAI,IACf,OAAOA,MAAM,CAACC,MAAM,KAAK,UAAU,IACnC,OAAOC,SAAS,KAAK,QAAQ,IAC7BA,SAAS,KAAK,IAAI,IAClB,OAAOA,SAAS,CAACC,SAAS,KAAK,QAAQ,IACvC,EACED,SAAS,CAACC,SAAS,CAAC5K,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,IAC1C2K,SAAS,CAACC,SAAS,CAAC5K,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CACzC,EACD;IACA,IAAI;MACFyK,MAAM,CAACC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;KACpB,CAAC,OAAAG,OAAA,EAAM;;AAEZ;;SCpBgBC,oBAAoBA,CAClCjD,KAAoB,EACpBkD,SAAqC;EAErC,IAAM7I,KAAK,GAA2B,EAAE;EAExC,IAAI2F,KAAK,CAACpL,IAAI,EAAE;IACd,IAAMuO,YAAY,GAAG3N,MAAM,CAACC,IAAI,CAACuK,KAAK,CAAC9F,MAAM,CAAC,CAACkJ,IAAI,EAAE;IACrD,SAAA9L,SAAA,GAAAC,+BAAA,CAAwB4L,YAAY,GAAA3L,KAAA,IAAAA,KAAA,GAAAF,SAAA,IAAAG,IAAA,GAAE;MAAA,IAA3BvE,SAAS,GAAAsE,KAAA,CAAAnH,KAAA;MAClB,IAAM0I,QAAQ,GACZmK,SAAS,CAAClD,KAAK,CAACpL,IAAI,CAAC,CAAC,WAAW,CAAC,CAACsF,MAAM,CAAChH,SAAS,CAAC,CAAC,WAAW,CAAC;MAEnE,IAAI6F,QAAQ,CAACa,IAAI,KAAK,OAAO,EAAE;QAC7B,IAAMvJ,KAAK,GAAG2P,KAAK,CAAC9F,MAAM,CAAChH,SAAS,CAAC;QACrCmH,KAAK,CAACnH,SAAS,CAAC,GAAG6F,QAAQ,CAAC6B,eAAe,CAACjH,SAAS,CAACtD,KAAK,CAAC;;;;EAKlE,OAAOgK,KAAK;AACd;;ACQA,IAAQqB,YAAU,GAAiBD,WAAW,CAAtCC,UAAU;EAAEE,YAAU,GAAKH,WAAW,CAA1BG,UAAU;AAW9B,SAAgByH,YAAYA;;oCAAIrP,IAAW,OAAA1D,KAAA,CAAAyF,IAAA,GAAAC,IAAA,MAAAA,IAAA,GAAAD,IAAA,EAAAC,IAAA;IAAXhC,IAAW,CAAAgC,IAAA,IAAAC,SAAA,CAAAD,IAAA;;EACzC,IAAAsN,UAAA,GAA4BC,SAAS,CAACvP,IAAI,CAAC;IAAnCkP,SAAS,GAAAI,UAAA,CAATJ,SAAS;IAAEM,IAAI,GAAAF,UAAA,CAAJE,IAAI;EAEvB,IAAMC,wBAAwB,GAAGxB,8BAA8B,CAAC;IAC9DC,cAAc,EAAE,SAAAA;MACdwB,QAAQ,GAAG/D,SAAO,CAACgE,MAAM,CAAC,UAACC,MAAM;QAC/B,IAAIC,sCAAsC,EAAE;UAC1CA,sCAAsC,GAAG,KAAK;UAC9C;;QAGF,IAAMrE,QAAQ,GAAGqC,0CAA0C,CACzD+B,MAAM,CAACpE,QAAQ,EACfvK,OAAO,CACR;QACD,IAAMkL,MAAM,GAAGyD,MAAM,CAACzD,MAAM,CAAC2D,WAAW,EAAY;QACpD,IAAAC,iBAAA,GAA+BtC,gBAAgB,CAC7CjC,QAAQ,EACRc,gBAAgB,EAAE,CACnB;UAHON,KAAK,GAAA+D,iBAAA,CAAL/D,KAAK;UAAE3D,WAAW,GAAA0H,iBAAA,CAAX1H,WAAW;QAK1B2H,gBAAgB,CAAA/L,QAAA,KAAM+H,KAAK;UAAEG,MAAM,EAANA;YAAU9D,WAAW,CAAC;OACpD,CAAC;KACH;IACD8F,aAAa,EAAE,SAAAA;MAAA,OAAMuB,QAAQ,oBAARA,QAAQ,EAAI;;GAClC,CAAC;EAEF,IAAMzO,OAAO,IAAAgP,aAAA,GAAGT,IAAI,CAACvO,OAAO,YAAAgP,aAAA,GAAI,GAAG;EACnC,IAAMlK,cAAc,IAAAmK,qBAAA,IAAAC,iBAAA,GAAGX,IAAI,CAACY,WAAW,qBAAhBD,iBAAA,CAAkBE,SAAS,YAAAH,qBAAA,GAAI,GAAG;EACzD,IAAMlK,qBAAqB,IAAAsK,qBAAA,GACzBd,IAAI,CAACxJ,qBAAqB,YAAAsK,qBAAA,GAC1BzD,2BAA2B,CAAC;IAC1BC,sBAAsB,GAAAyD,kBAAA,GAAEf,IAAI,CAACY,WAAW,qBAAhBG,kBAAA,CAAkBC,WAAW;IACrDzK,cAAc,EAAdA;GACD,CAAC;EAEJ,IAAI4F,SAAgB;EACpB,IAAI+D,QAAkC;EACtC,IAAIG,sCAAsC,GAAG,KAAK;EAClD,IAAIY,8CAA8C,GAAG,KAAK;EAC1D,IAAIC,YAAY,GAAyB,IAAI;EAC7C,IAAIC,aAAa,GAAyB,IAAI;EAC9C,IAAIC,iBAAiB,GAAsB,EAAE;EAE7CC,gBAAgB,CAACrB,IAAI,CAACsB,OAAO,CAAC;EAE9B,IAAMnD,MAAM,GAAGoD,4BAA4B,CAACzE,gBAAgB,CAAC;EAE7D,IAAMwE,OAAO,GAAkC;IAE3CnS,IAAI,WAAAA,KAACiN,IAAI,EAAEvF,KAAK;MACd,AAAa;QACX5D,MAAM,CAAC,6BAA6B,EAAE,CACpCA,MAAM,CAACG,OAAO,CAAC,EAAE,CAAC4B,KAAK,CAACgI,IAAI,CAACvK,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC9CQ,MAAM,CAACS,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE0I,IAAI,CAAC,EACnCnJ,MAAM,CAACS,IAAI,CAAC,CAAC,QAAQ,EAAE,WAAW,CAAC,EAAE,OAAO,EAAEmD,KAAK,CAAC,CACrD,CAAC;;MAGJ,IAAA2K,eAAA,GAA+BjD,cAAc,CAC3CnC,IAAI,EACJvF,KAAK,EACLiG,gBAAgB,EAAE,CACnB;QAJON,KAAK,GAAAgF,eAAA,CAALhF,KAAK;QAAE3D,WAAW,GAAA2I,eAAA,CAAX3I,WAAW;MAM1B,OAAOqD,QAAQ,CAAAzH,QAAA,KAAM+H,KAAK;QAAEG,MAAM,EAAE;UAAU9D,WAAW,CAAC;KAC3D;IACDlH,OAAO,WAAAA,QAACyK,IAAI,EAAEvF,KAAK;MACjB,AAAa;QACX5D,MAAM,CAAC,gCAAgC,EAAE,CACvCA,MAAM,CAACG,OAAO,CAAC,EAAE,CAAC4B,KAAK,CAACgI,IAAI,CAACvK,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC9CQ,MAAM,CAACS,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE0I,IAAI,CAAC,EACnCnJ,MAAM,CAACS,IAAI,CAAC,CAAC,QAAQ,EAAE,WAAW,CAAC,EAAE,OAAO,EAAEmD,KAAK,CAAC,CACrD,CAAC;;MAGJ,IAAA4K,gBAAA,GAA+BlD,cAAc,CAC3CnC,IAAI,EACJvF,KAAK,EACLiG,gBAAgB,EAAE,CACnB;QAJON,KAAK,GAAAiF,gBAAA,CAALjF,KAAK;QAAE3D,WAAW,GAAA4I,gBAAA,CAAX5I,WAAW;MAM1B,OAAOqD,QAAQ,CAAAzH,QAAA,KAAM+H,KAAK;QAAEG,MAAM,EAAE;UAAa9D,WAAW,CAAC;KAC9D;IACD6I,IAAI,WAAAA,KAACC,MAAM;UAANA,MAAM;QAANA,MAAM,GAAG,CAAC;;MACb,AAAa;QACX1O,MAAM,CAAC,6BAA6B,EAAE,CACpCA,MAAM,CAACG,OAAO,CAAC,EAAE,CAAC4B,KAAK,CAACgI,IAAI,CAACvK,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC9CQ,MAAM,CAACS,IAAI,CAAC,QAAQ,EAAE,QAAQ,EAAEiO,MAAM,CAAC,CACxC,CAAC;;MAGJxF,SAAO,CAACyF,EAAE,CAAC,CAACD,MAAM,CAAC;KACpB;IACDE,OAAO,WAAAA,QAACF,MAAM;UAANA,MAAM;QAANA,MAAM,GAAG,CAAC;;MAChB,AAAa;QACX1O,MAAM,CAAC,gCAAgC,EAAE,CACvCA,MAAM,CAACG,OAAO,CAAC,EAAE,CAAC4B,KAAK,CAACgI,IAAI,CAACvK,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC9CQ,MAAM,CAACS,IAAI,CAAC,QAAQ,EAAE,QAAQ,EAAEiO,MAAM,CAAC,CACxC,CAAC;;MAGJxF,SAAO,CAACyF,EAAE,CAACD,MAAM,CAAC;KACnB;IACDG,eAAe,WAAAA;MACb,AAAa;QACX7O,MAAM,CAAC,wCAAwC,EAAE,CAC/CA,MAAM,CAACG,OAAO,CAAC,EAAE,CAAC4B,KAAK,CAACgI,IAAI,CAACvK,SAAS,CAAC,EAAE,CAAC,CAAC,CAC5C,CAAC;;MAGJ,IAAI,CAACyO,YAAY,EAAE;QACjB,IAAIpJ,MAAM,GAAGmG,gBAAgB,CAC3BI,0CAA0C,CACxClC,SAAO,CAACH,QAAQ,EAChBvK,OAAO,CACR,EACDqL,gBAAgB,EAAE,CACnB;QAED,IAAI,CAAChF,MAAM,CAACe,WAAW,EAAE;UACvBoI,8CAA8C,GAAG,IAAI;UACrDnJ,MAAM,CAAC0E,KAAK,CAAC7K,OAAO,EAAE;UACtBmG,MAAM,GAAGmG,gBAAgB,CACvBI,0CAA0C,CACxClC,SAAO,CAACH,QAAQ,EAChBvK,OAAO,CACR,EACDqL,gBAAgB,EAAE,CACnB;;QAEHoE,YAAY,GAAGpJ,MAAM,CAAC0E,KAAK;;MAG7B,OAAO0E,YAAY;KACpB;IACDa,KAAK,WAAAA,MAACT,OAAO;MACX,AAAa;QACXrO,MAAM,CAAC,8BAA8B,EAAE,CACrCA,MAAM,CAACG,OAAO,CAAC,EAAE,CAAC4B,KAAK,CAACgI,IAAI,CAACvK,SAAS,CAAC,EAAE,CAAC,CAAC,EAC3CQ,MAAM,CAACS,IAAI,CAAC,QAAQ,EAAE,SAAS,EAAE4N,OAAO,CAAC,CAC1C,CAAC;;MAGJ,OAAOD,gBAAgB,CAACC,OAAO,CAAC;KACjC;IACDU,KAAK,WAAAA,MAACC,OAAO;MACXb,iBAAiB,CAACjS,IAAI,CAAC8S,OAAO,CAAC;MAE/B,IAAMC,OAAO,GAAG/F,SAAO,CAAC6F,KAAK,CAAC,UAAC5B,MAAM;QACnC,IAAA+B,kBAAA,GAAkBlE,gBAAgB,CAChCI,0CAA0C,CACxC+B,MAAM,CAACpE,QAAQ,EACfvK,OAAO,CACR,EACDqL,gBAAgB,EAAE,CACnB;UANON,KAAK,GAAA2F,kBAAA,CAAL3F,KAAK;QAQb,IAAMG,MAAM,GAAGyD,MAAM,CAACzD,MAAM,CAAC2D,WAAW,EAAY;QAEpD2B,OAAO,CAAC;UAAEzF,KAAK,EAAA/H,QAAA,KAAO+H,KAAK;YAAEG,MAAM,EAANA;YAAQ;UAAEyF,KAAK,EAAEhC,MAAM,CAACgC;SAAO,CAAC;OAC9D,CAAC;MAEF,OAAO;QACLhB,iBAAiB,CAAClC,MAAM,CACtBkC,iBAAiB,CAACiB,SAAS,CAAC,UAACC,IAAI;UAAA,OAAKA,IAAI,KAAKL,OAAO;UAAC,EACvD,CAAC,CACF;QAEDC,OAAO,EAAE;OACV;KACF;IACD/B,MAAM,EAAE,SAAAA,OAACnB,OAAO;MAAA,OAAKiB,wBAAwB,CAACnB,GAAG,CAACE,OAAO,CAAC;;GAE7D;EAED,IAAAlP,IAAA,GAAsB;MACpB,IAAIyS,aAAa,GAAGjB,OAAO,CAACQ,eAAe,EAAE;MAE7CR,OAAO,CAACnB,MAAM,CAAC,UAAA3D,KAAK;QAAA,OAAK+F,aAAa,GAAG/F,KAAK;OAAC,CAAC;MAEhD,SAASgG,QAAQA;QACb,OAAOD,aAAa;;MAGxB,OAAO;QAAEC,QAAQ,EAARA;OAAU;KACpB,EAAG;IAVIA,QAAQ,GAAA1S,IAAA,CAAR0S,QAAQ;EAYhB,IAAMC,MAAM,GAAuB;IACjCtE,MAAM,EAANA,MAAM;IACNmD,OAAO,EAAPA,OAAO;IACP3C,aAAa,EAAE,SAAAA;MAAA,OAAKuB,QAAQ,oBAARA,QAAQ,EAAI;;IAChCsC,QAAQ,EAARA;GACD;EAED,OAAOC,MAAM;EAEb,SAASpB,gBAAgBA,CACvBqB;QAAAA;MAAAA,cAA2B;QACzBhP,IAAI,EACF,OAAO0L,MAAM,KAAK,WAAW,IAAI,OAAOA,MAAM,CAACuD,QAAQ,KAAK,WAAW,GACnE,SAAS,GACT;OACP;;IAEDzB,YAAY,GAAG,IAAI;IACnB,IAAIwB,WAAW,CAAChP,IAAI,KAAK,QAAQ,EAAE;MACjCyI,SAAO,GAAGyG,2BAAmB,CAAC;QAC5BC,cAAc,EAAEH,WAAW,CAACG,cAAc;QAC1CC,YAAY,EAAEJ,WAAW,CAACI;OAC3B,CAAC;KACH,MAAM,IAAIJ,WAAW,CAAChP,IAAI,KAAK,MAAM,EAAE;MACtCyI,SAAO,GAAG4G,yBAAiB,CAAC;QAC1B3D,MAAM,EAAEsD,WAAW,CAACtD;OACrB,CAAC;KACH,MAAM;MACLjD,SAAO,GAAG6G,4BAAoB,CAAC;QAC7B5D,MAAM,EAAEsD,WAAW,CAACtD;OACrB,CAAC;;;EAIN,SAASlD,QAAQA,CAACM,KAAoB,EAAE3D,WAAoB;;IAC1D,IAAIuI,iBAAiB,CAACzQ,MAAM,GAAG,CAAC,EAAE;MAChCyQ,iBAAiB,CAAClP,OAAO,CAAC,UAAC+P,OAAO;QAChCA,OAAO,CAAC;UACNzF,KAAK,EAALA,KAAK;UACL4F,KAAK,EAAE,SAAAA;YACL5F,KAAK,CAACA,KAAK,CAACG,MAAM,KAAK,MAAM,GAAG,MAAM,GAAG,SAAS,CAAC,EAAE;;SAExD,CAAC;OACH,CAAC;MAEF;;IAGF,IAAM9F,KAAK,GAAG4I,oBAAoB,CAACjD,KAAK,EAAEkD,SAAS,CAAC;IAEpD,IACE,EAAAuD,cAAA,GAAA9B,aAAa,qBAAb8B,cAAA,CAAe7G,IAAI,MAAKI,KAAK,CAACJ,IAAI,IAClClM,IAAI,CAACC,SAAS,CAACsP,oBAAoB,CAAC0B,aAAa,EAAEzB,SAAS,CAAC,CAAC,KAC5DxP,IAAI,CAACC,SAAS,CAAC0G,KAAK,CAAC,EACvB;MACA;;IAGF,IAAIoK,8CAA8C,EAAE;MAClDA,8CAA8C,GAAG,KAAK;KACvD,MAAM;MACLT,gBAAgB,CAAChE,KAAK,EAAE3D,WAAW,CAAC;;IAGtCwH,sCAAsC,GAAG,IAAI;IAE7C,IAAA7B,WAAA,GAA2BpG,YAAU,CAACoE,KAAK,CAACJ,IAAI,EAAE,GAAG,CAAC;MAA/CE,QAAQ,GAAAkC,WAAA;MAAEjC,MAAM,GAAAiC,WAAA;IAEvBrC,SAAO,CAACK,KAAK,CAACG,MAAM,KAAK,SAAS,GAAG,SAAS,GAAG,MAAM,CAAC,CACtD;MACEL,QAAQ,EAARA,QAAQ;MACRC,MAAM,EAAEA,MAAM,SAAOA,MAAM,GAAK,EAAE;MAClC2G,IAAI,EAAE;KACP,EACDrM,KAAK,GAAG;MAAEA,KAAK,EAALA;KAAO,GAAGI,SAAS,CAC9B;;EAGH,SAASuJ,gBAAgBA,CAAChE,KAAoB,EAAE3D,WAAoB;IAClE,IAAI,CAACA,WAAW,EAAE;MAChB2D,KAAK,CAAC7K,OAAO,EAAE;MACf;;IAGF,SAAAmC,SAAA,GAAAC,+BAAA,CAAsBkM,wBAAwB,CAAClB,WAAW,EAAE,GAAA/K,KAAA,IAAAA,KAAA,GAAAF,SAAA,IAAAG,IAAA,GAAE;MAAA,IAAnD+K,OAAO,GAAAhL,KAAA,CAAAnH,KAAA;MAChBmS,OAAO,CAACxC,KAAK,CAAC;;IAGhB,IAAIwD,IAAI,CAACmD,WAAW,KAAK,IAAI,EAAC;MAC5BhE,kBAAkB,CAAC3C,KAAK,CAAC;;IAG3B2E,aAAa,GAAG3E,KAAK;;EAGvB,SAASM,gBAAgBA;IACvB,OAAO;MACLtG,qBAAqB,EAArBA,qBAAqB;MACrBD,cAAc,EAAdA,cAAc;MACd2F,QAAQ,EAARA,QAAQ;MACRC,OAAO,EAAPA,SAAO;MACPuD,SAAS,EAATA,SAAS;MACTxB,SAAS,EAAE,SAAAA;QAAA,OAAMC,MAAM;;MACvB1M,OAAO,EAAPA;KACD;;AAEL;AAEA,SAAgBsO,SAASA,CAACvP,IAAW;EACnC,IAAMkP,SAAS,GACblP,IAAI,CAACG,MAAM,KAAK,CAAC,GAAGH,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;EACvC,IAAMwP,IAAI,GAAexP,IAAI,CAACG,MAAM,KAAK,CAAC,GAAG,EAAE,GAAGH,IAAI,CAAC,CAAC,CAAC;EAEzD,AAAa;IAAA,IAAA4S,kBAAA;IACXnQ,MAAM,CAAC,cAAc,EAAE,CACrBA,MAAM,CAACG,OAAO,CAAC5C,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,EAC1ByC,MAAM,CAACI,gBAAgB,CAAC,UAAU,EAAE,WAAW,EAAEqM,SAAS,CAAC,EAC3DzM,MAAM,CAACS,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAEsM,IAAI,CAAC,CACpC,CAAC;IAEF,IAAI,CAAAoD,kBAAA,GAAApD,IAAI,CAACY,WAAW,aAAhBwC,kBAAA,CAAkBpC,WAAW,IAAIhB,IAAI,CAACxJ,qBAAqB,EAAE;MAC/D,MAAMnJ,cAAc,CAACuD,qFAAqF,CAAC0B,MAAM,EAAE;;IAGrH,IAAI,OAAO0N,IAAI,CAACvO,OAAO,KAAK,QAAQ,EAAE;MACpC,IAAI,CAACyG,YAAU,CAAC8H,IAAI,CAACvO,OAAO,EAAE,GAAG,CAAC,EAAE;QAClC,MAAMpE,cAAc,CAACmE,wCAAwC,CAACc,MAAM,CAClE0N,IAAI,CAACvO,OAAO,CACb;;MAGH,IACEuO,IAAI,CAACvO,OAAO,CACTrD,KAAK,CAAC,GAAG,CAAC,CACV0L,IAAI,CAAC,UAAClE,IAAI;QAAA,OAAKrH,kBAAkB,CAACqH,IAAI,CAAC,KAAKA,IAAI;QAAC,EACpD;QACA,MAAMvI,cAAc,CAACqE,iEAAiE,CAACY,MAAM,CAC3F0N,IAAI,CAACvO,OAAO,CACb;;;;EAKP,OAAO;IAAEiO,SAAS,EAATA,SAAS;IAAEM,IAAI,EAAJA;GAAM;AAC5B;AAEA,SAASuB,4BAA4BA,CAACzE,gBAAqC;EACzE,IAAMqB,MAAM,GAAyC,EAAE;EACvD,IAAAkF,iBAAA,GAAsBvG,gBAAgB,EAAE;IAAhC4C,SAAS,GAAA2D,iBAAA,CAAT3D,SAAS;EAEjB,KAAK,IAAMzS,SAAS,IAAIyS,SAAS,EAAE;IACjC,IAAM7C,QAAQ,GAAG6C,SAAS,CAACzS,SAAS,CAAC;IACrCkR,MAAM,CAAClR,SAAS,CAAC,GAAG2P,kBAAkB,CACpC3P,SAAS,EACT4P,QAAQ,EACRC,gBAAgB,CACjB;;EAGH,OAAOqB,MAAM;AACf;;SCtXgBmF,WAAWA;oCAAI9S,IAAW,OAAA1D,KAAA,CAAAyF,IAAA,GAAAC,IAAA,MAAAA,IAAA,GAAAD,IAAA,EAAAC,IAAA;IAAXhC,IAAW,CAAAgC,IAAA,IAAAC,SAAA,CAAAD,IAAA;;EACxC+Q,6BAA6B,CAAC,aAAa,EAAE/S,IAAI,CAAC;EAElD,IAAMgT,MAAM,GAAGzD,WAAS,CAACvP,IAAI,CAAC;EAE9B,IAAMqM,QAAQ,GAAqB;IACjC,WAAW,EAAE;MACXnJ,IAAI,EAAE,UAAU;MAChBgD,MAAM,EAAE8M,MAAM,CAAC9M,MAAM;MACrBC,IAAI,EAAE6M,MAAM,CAAC7M;KACd;IACD8M,MAAM,WAAAA;yCAAIjT,IAAW,OAAA1D,KAAA,CAAA4W,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAXnT,IAAW,CAAAmT,KAAA,IAAAlR,SAAA,CAAAkR,KAAA;;MACnBJ,6BAA6B,CAAC,QAAQ,EAAE/S,IAAI,CAAC;MAE7C,IAAAsP,UAAA,GAAyBC,WAAS,CAACvP,IAAI,CAAC;QAAhCkG,MAAM,GAAAoJ,UAAA,CAANpJ,MAAM;QAAEC,IAAI,GAAAmJ,UAAA,CAAJnJ,IAAI;MAEpB,IAAMiN,gBAAgB,GAAG5R,MAAM,CAACC,IAAI,CAACuR,MAAM,CAAC9M,MAAM,CAAC;MACnD,IAAMmN,mBAAmB,GAAG7R,MAAM,CAACC,IAAI,CAACyE,MAAM,CAAC;MAE/C,IAAMoN,mBAAmB,GAAGF,gBAAgB,CAACvV,MAAM,CACjD,UAAC+C,IAAI;QAAA,OAAKyS,mBAAmB,CAAClP,OAAO,CAACvD,IAAI,CAAC,IAAI,CAAC;QACjD;MAED,AAAa;QACX,IAAI0S,mBAAmB,CAACnT,MAAM,GAAG,CAAC,EAAE;UAClC,MAAMtD,cAAc,CAACsC,uGAAuG,CAAC2C,MAAM,CACjIwR,mBAAmB,CACpB;;;MAIL,OAAOR,WAAW,CAAA7O,QAAA,KAEXiC,MAAM,EACN8M,MAAM,CAAC9M,MAAM,GAElB,UAACqN,CAAC;;QACA,IAAMC,eAAe,GAAGhR,OAAO,CAC7BwQ,MAAM,CAAC7M,IAAI,CAACtI,MAAM,CAACuV,gBAAgB,CAAC,CAAC,CACtC;QACD,IAAMK,cAAc,GAAGjR,OAAO,CAAC2D,IAAI,CAACtI,MAAM,CAACwV,mBAAmB,CAAC,CAAC,CAAC;QAEjE,OAAQ,CAAA/T,IAAA,KAAe,EAACtB,MAAM,CAAAoE,KAAA,CAAA9C,IAAA,EACzBkU,eAAe,CAAC5T,GAAG,CAAC,UAAC8T,UAAU;UAAA,OAChCD,cAAc,CAAC7T,GAAG,CAAC,UAAC+T,SAAS;YAC3B,IAAID,UAAU,KAAK,GAAG,EAAE;cACtB,OAAOC,SAAS;;YAGlB,OAAOD,UAAU,IAAIC,SAAS,KAAK,GAAG,GAAG,EAAE,GAAGA,SAAS,CAAC;WACzD,CAAC;UACH,CACF;QAED,SAAS9V,MAAMA,CAAC+V,WAAqB;UACnC,IAAMC,SAAS,GAA2B,EAAE;UAE5CD,WAAW,CAAClS,OAAO,CAAC,UAACC,GAAG;YACtBkS,SAAS,CAAClS,GAAG,CAAC,GAAI4R,CAA4B,CAAC5R,GAAG,CAAC;WACpD,CAAC;UAEF,OAAOkS,SAAS;;OAEnB,CACF;;GAEJ;EAED,OAAOxH,QAAQ;AACjB;AAEA,SAAS0G,6BAA6BA,CAACe,YAAoB,EAAE9T,IAAW;EACtE,AAAa;IACX,IAAIA,IAAI,CAACG,MAAM,KAAK,CAAC,EAAE;MACrB,IAAI7D,KAAK,CAACC,OAAO,CAACyD,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;QAC1ByC,MAAM,CAACqR,YAAY,EAAE,CAACrR,MAAM,CAACU,WAAW,CAAC,QAAQ,EAAE,MAAM,EAAEnD,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;OACtE,MAAM;QACLyC,MAAM,CAACqR,YAAY,EAAE,CAACrR,MAAM,CAACS,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAElD,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;KAEjE,MAAM;MACLyC,MAAM,CAACqR,YAAY,EAAE,CACnBrR,MAAM,CAACG,OAAO,CAAC5C,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,EAC1ByC,MAAM,CAACI,gBAAgB,CAAC,UAAU,EAAE,QAAQ,EAAE7C,IAAI,CAAC,CAAC,CAAC,CAAC,EACtDyC,MAAM,CAACS,IAAI,CAAC,UAAU,EAAE,MAAM,EAAElD,IAAI,CAAC,CAAC,CAAC,CAAC,CACzC,CAAC;;;AAGR;AAEA,SAASuP,WAASA,CAACvP,IAAW;EAI5B,OAAOA,IAAI,CAACG,MAAM,KAAK,CAAC,GACpB;IACE+F,MAAM,EAAE,EAAE;IACVC,IAAI,EAAE,SAAAA;MAAA,OAAMnG,IAAI,CAAC,CAAC,CAAC;;GACpB,GACD;IACEkG,MAAM,EAAElG,IAAI,CAAC,CAAC,CAAC;IACfmG,IAAI,EAAEnG,IAAI,CAAC,CAAC;GACb;AACP;;ACjHA,IAAM+T,QAAO,GAA6B;EACxChN,EAAE,EAAE,SAAS;EACbqC,KAAK,EAAE,SAAAA,MAACS,GAAG;IAAA,OAAMA,GAAG,KAAK,MAAM,GAAG,IAAI,GAAGA,GAAG,KAAK,OAAO,GAAG,KAAK,GAAGtC,OAAO;GAAC;EAC3E5H,SAAS,EAAE,SAAAA,UAACtD,KAAK;IAAA,OAAMA,KAAK,GAAG,MAAM,GAAG,OAAO;;CAChD;AAED,IAAM2X,MAAM,GAA4B;EACtCjN,EAAE,EAAE,QAAQ;EACZqC,KAAK,EAAE,SAAAA,MAACS,GAAG;IACT,IAAI,CAACoK,SAAS,CAACpK,GAAG,CAAC,EAAE;MACnB,OAAOtC,OAAO;;IAGhB,OAAO2M,UAAU,CAACrK,GAAG,CAAC;GACvB;EACDlK,SAAS,EAAE,SAAAA,UAACtD,KAAK;IAAA,OAAKA,KAAK,CAAC8X,QAAQ,EAAE;;CACvC;AAED,SAASF,SAASA,CAAC5X,KAAa;EAC9B,OAAO,CAAC+X,KAAK,CAACF,UAAU,CAAC7X,KAAK,CAAC,CAAC,IAAI,eAAe,CAACgY,IAAI,CAAChY,KAAK,CAAC;AACjE;AAEA,IAAMiY,MAAM,GAA4B;EACtCvN,EAAE,EAAE,QAAQ;EACZqC,KAAK,EAAE,SAAAA,MAACS,GAAG;IAAA,OAAKA,GAAG;;EACnBlK,SAAS,EAAE,SAAAA,UAACtD,KAAK;IAAA,OAAKA,KAAK;;CAC5B;AAED,IAAMkY,IAAI,GAAG,SAAPA,IAAIA;EACR,IAAM3N,eAAe,GAA4B;IAC/CG,EAAE,EAAE,MAAM;IACVqC,KAAK,EAAE,SAAAA,MAACS,GAAG;MACT,IAAIxN,KAAa;MAEjB,IAAI;QACFA,KAAK,GAAGqD,IAAI,CAAC0J,KAAK,CAACS,GAAG,CAAC;OACxB,CAAC,OAAAmF,OAAA,EAAM;QACN,OAAOzH,OAAO;;MAGhB,OAAOlL,KAAK;KACb;IACDsD,SAAS,EAAE,SAAAA,UAACtD,KAAK;MAAA,OAAKqD,IAAI,CAACC,SAAS,CAACtD,KAAK,CAAC;;GAC5C;EAED,OAAOuK,eAAe;AACxB,CAAC;AAED,IAAayD,KAAK,GAAG;EACnBlE,IAAI,eAAAlC,QAAA,kBACCuQ,sBAAsB,CAAC,MAAM,EAAE,KAAK,CAAC;IACxCjX,QAAQ,eAAEiX,sBAAsB,CAAC,MAAM,EAAE,IAAI;IAC9C;EACDpO,KAAK,eAAEoO,sBAAsB,CAAC,OAAO,EAAE,KAAK,CAAC;EAC7CnO,KAAK,eAAEmO,sBAAsB,CAAC,OAAO,EAAE,KAAK;CAC7C;AAED,SAASA,sBAAsBA,CAG7B5O,IAAW,EAAErI,QAAmB;EAChC,OAAA0G,QAAA,KACKwQ,6BAA6B,CAAC,KAAK,EAAE,KAAK,CAAC;IAC9ClU,KAAK,EAAEkU,6BAA6B,CAAC,KAAK,EAAE,IAAI,CAAC;IACjDxP,QAAQ,EAAAhB,QAAA,KACHwQ,6BAA6B,CAAC,IAAI,EAAE,KAAK,CAAC;MAC7ClU,KAAK,EAAEkU,6BAA6B,CAAC,IAAI,EAAE,IAAI;;;EAInD,SAASA,6BAA6BA,CAGpCxP,QAAmB,EAAE1E,KAAa;IAClC,OAAO;MACL+T,MAAM,EAAEI,WAAW,CAAC;QAClB,WAAW,EAAE;UACXxR,IAAI,EAAE,UAAU;UAChB3C,KAAK,EAALA,KAAK;UACLqF,IAAI,EAAJA,IAAI;UACJX,QAAQ,EAARA,QAAQ;UACR2B,eAAe,EAAE0N,MAAM;UACvB/W,QAAQ,EAARA,QAAQ;UACR,WAASkJ;;OAEZ,CAAC;MAEFuN,MAAM,EAAEU,WAAW,CAAC;QAClB,WAAW,EAAE;UACXxR,IAAI,EAAE,UAAU;UAChB3C,KAAK,EAALA,KAAK;UACLqF,IAAI,EAAJA,IAAI;UACJX,QAAQ,EAARA,QAAQ;UACR2B,eAAe,EAAEoN,MAAM;UACvBzW,QAAQ,EAARA,QAAQ;UACR,WAASkJ;;OAEZ,CAAC;MAEF,WAASiO,WAAW,CAAC;QACnB,WAAW,EAAE;UACXxR,IAAI,EAAE,UAAU;UAChB3C,KAAK,EAALA,KAAK;UACLqF,IAAI,EAAJA,IAAI;UACJX,QAAQ,EAARA,QAAQ;UACR2B,eAAe,EAAEmN,QAAO;UACxBxW,QAAQ,EAARA,QAAQ;UACR,WAASkJ;;OAEZ,CAAC;MAEFkO,MAAM,WAAAA,OACJ/N;YAAAA;UAAAA,kBAA2C2N,IAAI,EAAU;;QAEzD,AAAa;UACX9R,MAAM,CAAC,mBAAmB,EAAE,CAC1BA,MAAM,CAACG,OAAO,CAAC,EAAE,CAAC4B,KAAK,CAACgI,IAAI,CAACvK,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC9CQ,MAAM,CAACS,IAAI,CAAC,QAAQ,EAAE,iBAAiB,EAAE0D,eAAe,CAAC,CAC1D,CAAC;;QAGJ,OAAO8N,WAAW,CAAC;UACjB,WAAW,EAAE;YACXxR,IAAI,EAAE,UAAU;YAChB3C,KAAK,EAALA,KAAK;YACLqF,IAAI,EAAJA,IAAI;YACJX,QAAQ,EAARA,QAAQ;YACR2B,eAAe,EAAfA,eAAe;YACfrJ,QAAQ,EAARA,QAAQ;YACR,WAASkJ;;SAEZ,CAAC;;KAEL;;EAqBH,SAASiO,WAAWA,CAAApV,IAAA;QACLsV,QAAQ,GAAAtV,IAAA,CAArB,WAAW;IAEX,IAAI,CAACsV,QAAQ,CAAC3P,QAAQ,EAAE;MACtB,OAAO;QAAE,WAAW,EAAE2P;OAAiB;;IAGzC,OAAO;MACL,WAAW,EAAEA,QAAQ;MAAA,oBAAAC,SACbxY,KAAU;QAChB,AAAa;UACXoG,MAAM,CAAC,oBAAoB,EAAE,CAC3BA,MAAM,CAACG,OAAO,CAAC,EAAE,CAAC4B,KAAK,CAACgI,IAAI,CAACvK,SAAS,CAAC,EAAE,CAAC,CAAC,CAC5C,CAAC;;QAGJ,OAAO;UACL,WAAW,EAAAgC,QAAA,KAAO2Q,QAAQ;YAAE,WAASvY;;SACtC;;KAEG;;AAEZ;;AChLA,SAASyY,qBAAqBA,CAAkBC,UAAa;EAC3D,AAAa;IACXtS,MAAM,CAAC,aAAa,EAAE,CACpBA,MAAM,CAACG,OAAO,CAAC,EAAE,CAAC4B,KAAK,CAACgI,IAAI,CAACvK,SAAS,CAAC,EAAE,CAAC,CAAC,EAC3CQ,MAAM,CAACU,WAAW,CAChB,CAAC,YAAY,EAAE,cAAc,CAAC,EAC9B,YAAY,EACZ4R,UAAU,CACX,CACF,CAAC;;EAGJ,IAAMC,UAAU,GAAyB,EAAE;EAE3CD,UAAU,CAACrT,OAAO,CAAC,UAACoQ,IAAI;IACtB,IAAImD,YAAY,CAACnD,IAAI,CAAC,EAAE;MACtBA,IAAI,CAACkD,UAAU,CAACtT,OAAO,CAAC,UAACd,IAAI;QAC3BoU,UAAU,CAACpU,IAAI,CAAC,GAAG,IAAI;OACxB,CAAC;KACH,MAAM;MACLoU,UAAU,CAAClD,IAAI,CAAClR,IAAI,CAAC,GAAG,IAAI;;GAE/B,CAAC;EAEF,OAAO;IACL,WAAW,EAAE;MACXsC,IAAI,EAAE,YAAY;MAClB0J,KAAK,EAAE;KACR;IACDoI,UAAU,EAAExT,MAAM,CAACC,IAAI,CAACuT,UAAU,CAAC;IACnCE,GAAG,WAAAA,IAAClJ,KAAoB;MACtB,AAAa;QACXvJ,MAAM,CAAC,kBAAkB,EAAE,CACzBA,MAAM,CAACG,OAAO,CAAC,EAAE,CAAC4B,KAAK,CAACgI,IAAI,CAACvK,SAAS,CAAC,EAAE,CAAC,CAAC,EAC3CQ,MAAM,CAACS,IAAI,CAAC,QAAQ,EAAE,OAAO,EAAE8I,KAAK,CAAC,CACtC,CAAC;;MAGJ,IAAIA,KAAK,CAACpL,IAAI,KAAK,KAAK,EAAE;QACxB,OAAO,KAAK;;MAGd,OAAO,CAAC,CAACoU,UAAU,CAAChJ,KAAK,CAACpL,IAAI,CAAC;;GAElC;AACH;AAEA,SAASqU,YAAYA,CACnB5Y,KAAwC;EAExC,OAAO,CAAC,CAAEA,KAAoB,CAAC2Y,UAAU;AAC3C;AAEA,SAAgBG,yBAAyBA,CAGvCjG,SAA8B;EAI9B,IAAMkG,IAAI,GAAGC,YAAgB,CAACnG,SAAS,CAAC;EAExC,IAAMoG,KAAK,GAAER,qBAAqB,CAChCtT,MAAM,CAAC+T,MAAM,CAACH,IAAI,CAACzH,MAAM,CAAC,CAC3B;EAEDyH,IAAI,CAACjH,aAAa,EAAE;EAEpB,OAAOmH,KAAK;AACd;AAUA,SAAgBE,WAAWA,CACzBC,GAAoC;EAEpC,OAAOA,GAAG,YAAYnZ,KAAK,GACvBwY,qBAAqB,CAACW,GAAG,CAAC,GAC1BN,yBAAyB,CAACM,GAAG,CAAC;AACpC;;;;;;;;;"}
\ No newline at end of file
diff --git a/node_modules/type-route/core/type-route.cjs.production.min.js b/node_modules/type-route/core/type-route.cjs.production.min.js
index 3792670..500c90c 100644
--- a/node_modules/type-route/core/type-route.cjs.production.min.js
+++ b/node_modules/type-route/core/type-route.cjs.production.min.js
@@ -1,2 +1,2 @@
-"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var r=require("history");function e(){return(e=Object.assign||function(r){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(r[a]=n[a])}return r}).apply(this,arguments)}function n(r,e){(null==e||e>r.length)&&(e=r.length);for(var n=0,a=new Array(e);n<e;n++)a[n]=r[n];return a}function a(r,e){var a="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(a)return(a=a.call(r)).next.bind(a);if(Array.isArray(r)||(a=function(r,e){if(r){if("string"==typeof r)return n(r,void 0);var a=Object.prototype.toString.call(r).slice(8,-1);return"Object"===a&&r.constructor&&(a=r.constructor.name),"Map"===a||"Set"===a?Array.from(r):"Arguments"===a||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)?n(r,void 0):void 0}}(r))||e&&r&&"number"==typeof r.length){a&&(r=a);var t=0;return function(){return t>=r.length?{done:!0}:{done:!1,value:r[t++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function t(r){return Array.isArray(r)?r:[r]}function i(r){return"${p."+r+"}"}function o(r,e){var n={};return Object.keys(e).forEach((function(a){var t=e[a];t["~internal"].kind===r&&(n[a]=t)})),n}function u(r,e,n){var a=r["~internal"].valueSerializer.stringify(e);return n?encodeURIComponent(a):a}var l={__noMatch:!0},f=function(r,e){for(var n=0;n<e.length;n++)if(e[n]!==r[n])return!1;return!0},c=function(r,e){for(var n=1;n<=e.length;n++)if(e[e.length-n]!==r[r.length-n])return!1;return!0},s=function(r,e){var n=r.split(e);return[n[0],n.slice(1).join(e)]},p=c,m=f;function v(r){for(var n,t=r.object,i=r.paramDefs,o=r.urlEncodeDefault,u=r.arraySeparator,f={},c=Object.keys(i).map((function(r){return e({name:r},i[r])})),s=e({},t),p=function(){var r=n.value,e=t[r.name];if(delete s[r.name],void 0===e)return r["~internal"].optional?"continue":{v:!1};var a=void 0;if(null===e){if(!r["~internal"].array)return r["~internal"].optional?"continue":{v:!1};a=[]}else if(r["~internal"].array){if((a=e.split(u).map((function(e){var n;return r["~internal"].valueSerializer.parse((null!=(n=r["~internal"].valueSerializer.urlEncode)?n:o)?decodeURIComponent(e):e)}))).some((function(r){return r===l})))return r["~internal"].optional?"continue":{v:!1}}else{var i;if((a=r["~internal"].valueSerializer.parse((null!=(i=r["~internal"].valueSerializer.urlEncode)?i:o)?decodeURIComponent(e):e))===l)return r["~internal"].optional?"continue":{v:!1}}f[r.name]=a},m=a(c);!(n=m()).done;){var v=p();if("continue"!==v&&"object"==typeof v)return v.v}return{params:f,numExtraneousParams:Object.keys(s).length}}function d(r){var n=r.pathDefs,a=r.params,t=o("query",a),i=o("state",a),u={};return Object.keys(a).forEach((function(r){var e=a[r];void 0!==e["~internal"].default&&(u[r]=e["~internal"].default)})),function(r){var a=r.routerLocation,o=r.arraySeparator,f=r.queryStringSerializer;if(void 0===a.path)return!1;var c=function(r){for(var n=r.path,a=r.pathDefs,t=r.arraySeparator,i=0;i<a.length;i++){var o=u(a[i]);if(!1!==o)return e({},o,{primaryPath:0===i})}return!1;function u(r){var e={};if("/"===n&&0===r.length)return{params:e,numExtraneousParams:0};var a=n.length>1&&p(n,"/");a&&(n=n.slice(0,n.length-1));for(var i=n.split("/").slice(1),o=function(n){var o,u,f,c=n>=r.length?null:r[n],s=n>=i.length?null:i[n];if(null===c)return{v:!1};if(null===s)return 0==r.length-1-n&&null!=(f=c.namedParamDef)&&f["~internal"].optional?"break":{v:!1};if(null!=(o=c.namedParamDef)&&o["~internal"].trailing&&(s=i.slice(n).join("/")),!m(s,c.leading))return{v:!1};var v=s.slice(c.leading.length);if(!p(v,c.trailing))return{v:!1};var d=v.slice(0,v.length-c.trailing.length);if(!c.namedParamDef)return""===d?"continue":{v:!1};if(""===d)return c.namedParamDef["~internal"].optional?"continue":{v:!1};var y=null!=(u=c.namedParamDef["~internal"].valueSerializer.urlEncode)?u:!c.namedParamDef["~internal"].trailing,h=void 0;if(c.namedParamDef["~internal"].array){if((h=d.split(t).map((function(r){var e;return null==(e=c.namedParamDef)?void 0:e["~internal"].valueSerializer.parse(y?decodeURIComponent(r):r)}))).some((function(r){return r===l})))return{v:!1}}else if((h=c.namedParamDef["~internal"].valueSerializer.parse(y?decodeURIComponent(d):d))===l)return{v:!1};return c.namedParamDef["~internal"].trailing&&a&&""===c.trailing&&(h+="/"),e[c.namedParamDef.paramName]=h,c.namedParamDef["~internal"].trailing?"break":void 0},u=0;u<Math.max(r.length,i.length);u++){var f=o(u);if("break"===f)break;if("continue"!==f&&"object"==typeof f)return f.v}return{params:e,numExtraneousParams:0}}}({path:a.path,pathDefs:n,arraySeparator:o});if(!1===c)return!1;var s=function(r,e,n,a){var t={};return r&&(t=n.parse(r)),v({object:t,paramDefs:e,urlEncodeDefault:!0,arraySeparator:a})}(a.query,t,f,o);if(!1===s)return!1;var d=function(r,e,n){return v({object:null!=r?r:{},paramDefs:e,urlEncodeDefault:!1,arraySeparator:n})}(a.state,i,o);return!1!==d&&{primaryPath:c.primaryPath,params:e({},u,c.params,s.params,d.params),numExtraneousParams:c.numExtraneousParams+s.numExtraneousParams+d.numExtraneousParams}}}function y(r){return void 0===r&&(r={}),!(r.target&&r.target.target&&"_self"!==r.target.target||r.defaultPrevented||0!==r.button||r.metaKey||r.altKey||r.ctrlKey||r.shiftKey||(r&&r.preventDefault&&r.preventDefault(),0))}var h=f;function g(r){var n=r.routeName,a=r.params,t=r.location,i=r.routerContext,o=i.navigate,u=i.history.createHref({pathname:!1===n?t.fullPath:t.path,search:t.query?"?"+t.query:""});h(u,"#")&&(u="/"+u),!1!==n&&"/"!==i.baseUrl&&(u=i.baseUrl+u);var l={name:n,params:a,href:u,link:{href:u,onClick:function(r){if(y(r))return l.push()}},action:null,push:function(){return o(e({},l,{action:"push"}),!0)},replace:function(){return o(e({},l,{action:"replace"}),!0)}};return l}function S(r,n,l){var f,c,s,p,m=(f=o("path",n["~internal"].params),c=n["~internal"].path,s=Object.keys(f).map((function(r){return e({paramName:r},f[r])})),p={},s.forEach((function(r){var e=r.paramName;p[e]=i(e)})),t(c(p)).map((function(r){if(1===r.length)return[];for(var e,n=r.split("/").slice(1),t={},o=[],u=a(n);!(e=u()).done;){for(var l,f=e.value,c=null,p=a(s);!(l=p()).done;){var m=l.value;f.indexOf(i(m.paramName))>=0&&(c=m,t[m.paramName]=!0)}if(c){var v=f.split(i(c.paramName));o.push({leading:v[0],trailing:v[1],namedParamDef:c})}else o.push({leading:f,trailing:"",namedParamDef:null})}return s.map((function(r){return r.paramName})).filter((function(r){return!t[r]})),o}))),v=function(a){void 0===a&&(a={});var t=l(),i=t.arraySeparator,o=t.queryStringSerializer,f=t.baseUrl,c=e({},a);Object.keys(n["~internal"].params).forEach((function(r){var e=n["~internal"].params[r];void 0===c[r]&&void 0!==e["~internal"].default&&(c[r]=e["~internal"].default)}));var s=function(r){var n=r.paramCollection,a=r.paramDefCollection,t=r.arraySeparator,i=r.queryStringSerializer,o=r.pathDefs,l=r.baseUrl,f={path:{},query:{},state:{}},c=function(r){var e,i=n[r];if(void 0===i)return"continue";var o=a[r],l=null!=(e=o["~internal"].valueSerializer.urlEncode)?e:"state"!==o["~internal"].kind&&!o["~internal"].trailing,c=function(r){return o["~internal"].array?0===r.length?null:r.map((function(r){return u(o,r,l)})).join(t):u(o,r,l)},s=c(i);if("query"===o["~internal"].kind&&void 0!==o["~internal"].default&&c(o["~internal"].default)===s)return"continue";f[o["~internal"].kind][r]={valueSerializerId:o["~internal"].valueSerializer.id,array:o["~internal"].array,value:s}};for(var s in a)c(s);var p="/"+o[0].filter((function(r){var e=r.namedParamDef;return!(null!=e&&e["~internal"].optional&&void 0===f.path[e.paramName])})).map((function(r){var e=r.namedParamDef;return r.leading+(e?f.path[e.paramName].value:"")+r.trailing})).join("/");return{fullPath:("/"===l?"":l)+p,path:p,query:Object.keys(f.query).length>0?i.stringify(f.query):void 0,state:0===Object.keys(f.state).length?void 0:Object.keys(f.state).reduce((function(r,n){var a;return e({},r,((a={})[n]=f.state[n].value,a))}),{})}}({paramCollection:a,paramDefCollection:n["~internal"].params,arraySeparator:i,queryStringSerializer:o,pathDefs:m,baseUrl:f});return g({routeName:r,params:c,location:s,routerContext:t})};return Object.defineProperty(v,"name",{value:r}),v["~internal"]={type:"RouteBuilder",match:d({pathDefs:m,params:n["~internal"].params}),pathDefs:m,Route:null},v}function b(r){var e,n;void 0===r&&(r={});var t=null!=(e=r.queryStringArrayFormat)?e:"singleKeyWithBracket",i=null!=(n=r.arraySeparator)?n:",",o="multiKey"===t||"multiKeyWithBracket"===t,u="multiKey"===t||"singleKey"===t?"":"[]";return{parse:function(r){for(var e,n={},t=a(r.split("&"));!(e=t()).done;){var l=e.value.split("="),f=l[0],s=l[1],p=l.slice(2);if(!(void 0===f||p.length>0)){var m=decodeURIComponent(c(f,u)?f.slice(0,f.length-u.length):f);void 0===s?n[m]=null:n[m]&&o?n[m]+=""+i+s:n[m]=s}}return n},stringify:function(r){return Object.keys(r).map((function(e){var n=encodeURIComponent(e),a=r[e].array?""+n+u:n,t=r[e].value;return null===t?a:r[e].array&&o?t.split(i).map((function(r){return a+"="+r})).join("&"):a+"="+t})).join("&")}}}function P(r,n){var a=n.queryStringSerializer,t=n.arraySeparator,i=(0,n.getRoutes)(),o=!1;for(var u in i){var l=i[u]["~internal"].match({routerLocation:r,queryStringSerializer:a,arraySeparator:t});if(!1!==l){if(0===l.numExtraneousParams)return{route:i[u](l.params),primaryPath:l.primaryPath};(!1===o||l.numExtraneousParams<o.numExtraneousParams)&&(o=e({},l,{routeName:u}))}}return o?{route:i[o.routeName](o.params),primaryPath:o.primaryPath}:{route:g({routeName:!1,params:{},location:r,routerContext:n}),primaryPath:!0}}var D=f;function j(r,e){return{fullPath:r.pathname,path:D(r.pathname,e)?"/"!==e?r.pathname.replace(e,""):r.pathname:void 0,query:r.search?D(r.search,"?")?r.search.slice(1):r.search:void 0,state:"object"==typeof r.state&&null!==r.state?r.state.state:void 0}}var k=s;function w(r,e,n){var a=k(r,"?");return P(j({pathname:a[0],search:a[1],state:e},n.baseUrl),n)}function x(r){var e=r.startListening,n=r.stopListening,a=[],t=0;return{add:function(r){var i=t++;return a.push({id:i,handler:r}),1===a.length&&e(),function(){var r=a.map((function(r){return r.id})).indexOf(i);r>=0&&(a.splice(r,1),0===a.length&&n())}},getHandlers:function(){return a.map((function(r){return r.handler}))}}}function O(r,e){if("push"===r.action&&"object"==typeof window&&null!==window&&"function"==typeof window.scroll&&!1!==e&&"object"==typeof navigator&&null!==navigator&&"string"==typeof navigator.userAgent&&!(navigator.userAgent.indexOf("Node.js")>0||navigator.userAgent.indexOf("jsdom")>0))try{window.scroll(0,0)}catch(r){}}function E(r,e){var n={};if(r.name)for(var t,i=a(Object.keys(r.params).sort());!(t=i()).done;){var o=t.value,u=e[r.name]["~internal"].params[o]["~internal"];"state"===u.kind&&(n[o]=u.valueSerializer.stringify(r.params[o]))}return n}var q=s;function z(r){return{routeDefs:1===r.length?r[0]:r[1],opts:1===r.length?{}:r[0]}}function N(r){var e={},n=r().routeDefs;for(var a in n)e[a]=S(a,n[a],r);return e}function C(r){return 1===r.length?{params:{},path:function(){return r[0]}}:{params:r[0],path:r[1]}}var R={id:"boolean",parse:function(r){return"true"===r||"false"!==r&&l},stringify:function(r){return r?"true":"false"}},A={id:"number",parse:function(r){return e=r,isNaN(parseFloat(e))||!/^-?\d*\.?\d*$/.test(e)?l:parseFloat(r);var e},stringify:function(r){return r.toString()}},U={id:"string",parse:function(r){return r},stringify:function(r){return r}},I={path:e({},K("path",!1),{trailing:K("path",!0)}),query:K("query",!1),state:K("state",!1)};function K(r,n){return e({},a(!1,!1),{array:a(!1,!0),optional:e({},a(!0,!1),{array:a(!0,!0)})});function a(e,a){return{string:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:e,valueSerializer:U,trailing:n,default:void 0}}),number:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:e,valueSerializer:A,trailing:n,default:void 0}}),boolean:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:e,valueSerializer:R,trailing:n,default:void 0}}),ofType:function(i){return void 0===i&&(i={id:"json",parse:function(r){var e;try{e=JSON.parse(r)}catch(r){return l}return e},stringify:function(r){return JSON.stringify(r)}}),t({"~internal":{type:"ParamDef",array:a,kind:r,optional:e,valueSerializer:i,trailing:n,default:void 0}})}}}function t(r){var n=r["~internal"];return n.optional?{"~internal":n,default:function(r){return{"~internal":e({},n,{default:r})}}}:{"~internal":n}}}exports.createGroup=function(r){var e={};return r.forEach((function(r){r.routeNames?r.routeNames.forEach((function(r){e[r]=!0})):e[r.name]=!0})),{"~internal":{type:"RouteGroup",Route:null},routeNames:Object.keys(e),has:function(r){return!1!==r.name&&!!e[r.name]}}},exports.createRouter=function(){for(var n,t,i,o,u,l=arguments.length,f=new Array(l),c=0;c<l;c++)f[c]=arguments[c];var s,p,m=z(f),v=m.routeDefs,d=m.opts,y=x({startListening:function(){p=s.listen((function(r){if(D)D=!1;else{var n=j(r.location,h),a=r.action.toLowerCase(),t=P(n,F()),i=t.primaryPath;H(e({},t.route,{action:a}),i)}}))},stopListening:function(){return null==p?void 0:p()}}),h=null!=(n=d.baseUrl)?n:"/",g=null!=(t=null==(i=d.arrayFormat)?void 0:i.separator)?t:",",S=null!=(o=d.queryStringSerializer)?o:b({queryStringArrayFormat:null==(u=d.arrayFormat)?void 0:u.queryString,arraySeparator:g}),D=!1,k=!1,C=null,R=null,A=[];K(d.session);var U=N(F),I={routes:U,session:{push:function(r,n){var a=w(r,n,F()),t=a.primaryPath;return L(e({},a.route,{action:"push"}),t)},replace:function(r,n){var a=w(r,n,F()),t=a.primaryPath;return L(e({},a.route,{action:"replace"}),t)},back:function(r){void 0===r&&(r=1),s.go(-r)},forward:function(r){void 0===r&&(r=1),s.go(r)},getInitialRoute:function(){if(!C){var r=P(j(s.location,h),F());r.primaryPath||(k=!0,r.route.replace(),r=P(j(s.location,h),F())),C=r.route}return C},reset:function(r){return K(r)},block:function(r){A.push(r);var n=s.block((function(n){var a=P(j(n.location,h),F()).route,t=n.action.toLowerCase();r({route:e({},a,{action:t}),retry:n.retry})}));return function(){A.splice(A.findIndex((function(e){return e===r})),1),n()}},listen:function(r){return y.add(r)}}};return I;function K(e){void 0===e&&(e={type:"undefined"!=typeof window&&void 0!==window.document?"browser":"memory"}),C=null,s="memory"===e.type?r.createMemoryHistory({initialEntries:e.initialEntries,initialIndex:e.initialIndex}):"hash"===e.type?r.createHashHistory({window:e.window}):r.createBrowserHistory({window:e.window})}function L(r,e){var n;if(A.length>0)A.forEach((function(e){e({route:r,retry:function(){r["push"===r.action?"push":"replace"]()}})}));else{var a=E(r,v);if((null==(n=R)?void 0:n.href)!==r.href||JSON.stringify(E(R,v))!==JSON.stringify(a)){k?k=!1:H(r,e),D=!0;var t=q(r.href,"?"),i=t[1];s["replace"===r.action?"replace":"push"]({pathname:t[0],search:i?"?"+i:"",hash:""},a?{state:a}:void 0)}}}function H(r,e){if(e){for(var n,t=a(y.getHandlers());!(n=t()).done;)(0,n.value)(r);O(r,d.scrollToTop),R=r}else r.replace()}function F(){return{queryStringSerializer:S,arraySeparator:g,navigate:L,history:s,routeDefs:v,getRoutes:function(){return U},baseUrl:h}}},exports.defineRoute=function r(){for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];var o=C(a),u={"~internal":{type:"RouteDef",params:o.params,path:o.path},extend:function(){for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];var u=C(a),l=u.params,f=u.path,c=Object.keys(o.params),s=Object.keys(l);return c.filter((function(r){return s.indexOf(r)>=0})),r(e({},l,o.params),(function(r){var e,n=t(o.path(i(c))),a=t(f(i(s)));return(e=[]).concat.apply(e,n.map((function(r){return a.map((function(e){return"/"===r?e:r+("/"===e?"":e)}))})));function i(e){var n={};return e.forEach((function(e){n[e]=r[e]})),n}}))}};return u},exports.noMatch=l,exports.param=I,exports.preventDefaultLinkClickBehavior=y;
+"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var r=require("history");function e(){return(e=Object.assign||function(r){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(r[a]=n[a])}return r}).apply(this,arguments)}function n(r,e){(null==e||e>r.length)&&(e=r.length);for(var n=0,a=new Array(e);n<e;n++)a[n]=r[n];return a}function a(r,e){var a="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(a)return(a=a.call(r)).next.bind(a);if(Array.isArray(r)||(a=function(r,e){if(r){if("string"==typeof r)return n(r,void 0);var a=Object.prototype.toString.call(r).slice(8,-1);return"Object"===a&&r.constructor&&(a=r.constructor.name),"Map"===a||"Set"===a?Array.from(r):"Arguments"===a||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)?n(r,void 0):void 0}}(r))||e&&r&&"number"==typeof r.length){a&&(r=a);var t=0;return function(){return t>=r.length?{done:!0}:{done:!1,value:r[t++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function t(r){return Array.isArray(r)?r:[r]}function i(r){return"${p."+r+"}"}function o(r,e){var n={};return Object.keys(e).forEach((function(a){var t=e[a];t["~internal"].kind===r&&(n[a]=t)})),n}function u(r,e,n){var a=r["~internal"].valueSerializer.stringify(e);return n?encodeURIComponent(a):a}var l={__noMatch:!0},f=function(r,e){for(var n=0;n<e.length;n++)if(e[n]!==r[n])return!1;return!0},c=function(r,e){for(var n=1;n<=e.length;n++)if(e[e.length-n]!==r[r.length-n])return!1;return!0},s=function(r,e){var n=r.split(e);return[n[0],n.slice(1).join(e)]},p=c,m=f;function v(r){for(var n,t=r.object,i=r.paramDefs,o=r.urlEncodeDefault,u=r.arraySeparator,f={},c=Object.keys(i).map((function(r){return e({name:r},i[r])})),s=e({},t),p=function(){var r=n.value,e=t[r.name];if(delete s[r.name],void 0===e)return r["~internal"].optional?"continue":{v:!1};var a=void 0;if(null===e){if(!r["~internal"].array)return r["~internal"].optional?"continue":{v:!1};a=[]}else if(r["~internal"].array){if((a=e.split(u).map((function(e){var n;return r["~internal"].valueSerializer.parse((null!=(n=r["~internal"].valueSerializer.urlEncode)?n:o)?decodeURIComponent(e):e)}))).some((function(r){return r===l})))return r["~internal"].optional?"continue":{v:!1}}else{var i;if((a=r["~internal"].valueSerializer.parse((null!=(i=r["~internal"].valueSerializer.urlEncode)?i:o)?decodeURIComponent(e):e))===l)return r["~internal"].optional?"continue":{v:!1}}f[r.name]=a},m=a(c);!(n=m()).done;){var v=p();if("continue"!==v&&"object"==typeof v)return v.v}return{params:f,numExtraneousParams:Object.keys(s).length}}function d(r){var n=r.pathDefs,a=r.params,t=o("query",a),i=o("state",a),u={};return Object.keys(a).forEach((function(r){var e=a[r];void 0!==e["~internal"].default&&(u[r]=e["~internal"].default)})),function(r){var a=r.routerLocation,o=r.arraySeparator,f=r.queryStringSerializer;if(void 0===a.path)return!1;var c=function(r){for(var n=r.path,a=r.pathDefs,t=r.arraySeparator,i=0;i<a.length;i++){var o=u(a[i]);if(!1!==o)return e({},o,{primaryPath:0===i})}return!1;function u(r){var e={};if("/"===n&&0===r.length)return{params:e,numExtraneousParams:0};var a=n.length>1&&p(n,"/");a&&(n=n.slice(0,n.length-1));for(var i=n.split("/").slice(1),o=function(n){var o,u,f,c=n>=r.length?null:r[n],s=n>=i.length?null:i[n];if(null===c)return{v:!1};if(null===s)return 0==r.length-1-n&&null!=(f=c.namedParamDef)&&f["~internal"].optional?"break":{v:!1};if(null!=(o=c.namedParamDef)&&o["~internal"].trailing&&(s=i.slice(n).join("/")),!m(s,c.leading))return{v:!1};var v=s.slice(c.leading.length);if(!p(v,c.trailing))return{v:!1};var d=v.slice(0,v.length-c.trailing.length);if(!c.namedParamDef)return""===d?"continue":{v:!1};if(""===d)return c.namedParamDef["~internal"].optional?"continue":{v:!1};var y=null!=(u=c.namedParamDef["~internal"].valueSerializer.urlEncode)?u:!c.namedParamDef["~internal"].trailing,h=void 0;if(c.namedParamDef["~internal"].array){if((h=d.split(t).map((function(r){var e;return null==(e=c.namedParamDef)?void 0:e["~internal"].valueSerializer.parse(y?decodeURIComponent(r):r)}))).some((function(r){return r===l})))return{v:!1}}else if((h=c.namedParamDef["~internal"].valueSerializer.parse(y?decodeURIComponent(d):d))===l)return{v:!1};return c.namedParamDef["~internal"].trailing&&a&&""===c.trailing&&(h+="/"),e[c.namedParamDef.paramName]=h,c.namedParamDef["~internal"].trailing?"break":void 0},u=0;u<Math.max(r.length,i.length);u++){var f=o(u);if("break"===f)break;if("continue"!==f&&"object"==typeof f)return f.v}return{params:e,numExtraneousParams:0}}}({path:a.path,pathDefs:n,arraySeparator:o});if(!1===c)return!1;var s=function(r,e,n,a){var t={};return r&&(t=n.parse(r)),v({object:t,paramDefs:e,urlEncodeDefault:!0,arraySeparator:a})}(a.query,t,f,o);if(!1===s)return!1;var d=function(r,e,n){return v({object:null!=r?r:{},paramDefs:e,urlEncodeDefault:!1,arraySeparator:n})}(a.state,i,o);return!1!==d&&{primaryPath:c.primaryPath,params:e({},u,c.params,s.params,d.params),numExtraneousParams:c.numExtraneousParams+s.numExtraneousParams+d.numExtraneousParams}}}function y(r){return void 0===r&&(r={}),!(r.target&&r.target.target&&"_self"!==r.target.target||r.defaultPrevented||0!==r.button||r.metaKey||r.altKey||r.ctrlKey||r.shiftKey||(r&&r.preventDefault&&r.preventDefault(),0))}var h=f;function g(r){var n=r.routeName,a=r.params,t=r.location,i=r.routerContext,o=i.navigate,u=i.history.createHref({pathname:!1===n?t.fullPath:t.path,search:t.query?"?"+t.query:""});h(u,"#")&&(u="/"+u),!1!==n&&"/"!==i.baseUrl&&(u=i.baseUrl+u);var l={name:n,params:a,href:u,link:{href:u,onClick:function(r){if(y(r))return l.push()}},action:null,push:function(){return o(e({},l,{action:"push"}),!0)},replace:function(){return o(e({},l,{action:"replace"}),!0)}};return l}function b(r,n,l){var f,c,s,p,m=(f=o("path",n["~internal"].params),c=n["~internal"].path,s=Object.keys(f).map((function(r){return e({paramName:r},f[r])})),p={},s.forEach((function(r){var e=r.paramName;p[e]=i(e)})),t(c(p)).map((function(r){if(1===r.length)return[];for(var e,n=r.split("/").slice(1),t={},o=[],u=a(n);!(e=u()).done;){for(var l,f=e.value,c=null,p=a(s);!(l=p()).done;){var m=l.value;f.indexOf(i(m.paramName))>=0&&(c=m,t[m.paramName]=!0)}if(c){var v=f.split(i(c.paramName));o.push({leading:v[0],trailing:v[1],namedParamDef:c})}else o.push({leading:f,trailing:"",namedParamDef:null})}return s.map((function(r){return r.paramName})).filter((function(r){return!t[r]})),o}))),v=function(a){void 0===a&&(a={});var t=l(),i=t.arraySeparator,o=t.queryStringSerializer,f=t.baseUrl,c=e({},a);Object.keys(n["~internal"].params).forEach((function(r){var e=n["~internal"].params[r];void 0===c[r]&&void 0!==e["~internal"].default&&(c[r]=e["~internal"].default)}));var s=function(r){var n=r.paramCollection,a=r.paramDefCollection,t=r.arraySeparator,i=r.queryStringSerializer,o=r.pathDefs,l=r.baseUrl,f={path:{},query:{},state:{}},c=function(r){var e,i=n[r];if(void 0===i)return"continue";var o=a[r],l=null!=(e=o["~internal"].valueSerializer.urlEncode)?e:"state"!==o["~internal"].kind&&!o["~internal"].trailing,c=function(r){return o["~internal"].array?0===r.length?null:r.map((function(r){return u(o,r,l)})).join(t):u(o,r,l)},s=c(i);if("query"===o["~internal"].kind&&void 0!==o["~internal"].default&&c(o["~internal"].default)===s)return"continue";f[o["~internal"].kind][r]={valueSerializerId:o["~internal"].valueSerializer.id,array:o["~internal"].array,value:s}};for(var s in a)c(s);var p="/"+o[0].filter((function(r){var e=r.namedParamDef;return!(null!=e&&e["~internal"].optional&&void 0===f.path[e.paramName])})).map((function(r){var e=r.namedParamDef;return r.leading+(e?f.path[e.paramName].value:"")+r.trailing})).join("/");return{fullPath:("/"===l?"":l)+p,path:p,query:Object.keys(f.query).length>0?i.stringify(f.query):void 0,state:0===Object.keys(f.state).length?void 0:Object.keys(f.state).reduce((function(r,n){var a;return e({},r,((a={})[n]=f.state[n].value,a))}),{})}}({paramCollection:a,paramDefCollection:n["~internal"].params,arraySeparator:i,queryStringSerializer:o,pathDefs:m,baseUrl:f});return g({routeName:r,params:c,location:s,routerContext:t})};return Object.defineProperty(v,"name",{value:r}),v["~internal"]={type:"RouteBuilder",match:d({pathDefs:m,params:n["~internal"].params}),pathDefs:m,Route:null},v}function S(r){var e,n;void 0===r&&(r={});var t=null!=(e=r.queryStringArrayFormat)?e:"singleKeyWithBracket",i=null!=(n=r.arraySeparator)?n:",",o="multiKey"===t||"multiKeyWithBracket"===t,u="multiKey"===t||"singleKey"===t?"":"[]";return{parse:function(r){for(var e,n={},t=a(r.split("&"));!(e=t()).done;){var l=e.value.split("="),f=l[0],s=l[1],p=l.slice(2);if(!(void 0===f||p.length>0)){var m=decodeURIComponent(c(f,u)?f.slice(0,f.length-u.length):f);void 0===s?n[m]=null:n[m]&&o?n[m]+=""+i+s:n[m]=s}}return n},stringify:function(r){return Object.keys(r).map((function(e){var n=encodeURIComponent(e),a=r[e].array?""+n+u:n,t=r[e].value;return null===t?a:r[e].array&&o?t.split(i).map((function(r){return a+"="+r})).join("&"):a+"="+t})).join("&")}}}function P(r,n){var a=n.queryStringSerializer,t=n.arraySeparator,i=(0,n.getRoutes)(),o=!1;for(var u in i){var l=i[u]["~internal"].match({routerLocation:r,queryStringSerializer:a,arraySeparator:t});if(!1!==l){if(0===l.numExtraneousParams)return{route:i[u](l.params),primaryPath:l.primaryPath};(!1===o||l.numExtraneousParams<o.numExtraneousParams)&&(o=e({},l,{routeName:u}))}}return o?{route:i[o.routeName](o.params),primaryPath:o.primaryPath}:{route:g({routeName:!1,params:{},location:r,routerContext:n}),primaryPath:!0}}var D=f;function j(r,e){return{fullPath:r.pathname,path:D(r.pathname,e)?"/"!==e?r.pathname.replace(e,""):r.pathname:void 0,query:r.search?D(r.search,"?")?r.search.slice(1):r.search:void 0,state:"object"==typeof r.state&&null!==r.state?r.state.state:void 0}}var k=s;function w(r,e,n){var a=k(r,"?");return P(j({pathname:a[0],search:a[1],state:e},n.baseUrl),n)}function x(r){var e=r.startListening,n=r.stopListening,a=[],t=0;return{add:function(r){var i=t++;return a.push({id:i,handler:r}),1===a.length&&e(),function(){var r=a.map((function(r){return r.id})).indexOf(i);r>=0&&(a.splice(r,1),0===a.length&&n())}},getHandlers:function(){return a.map((function(r){return r.handler}))}}}function O(r){if("push"===r.action&&"object"==typeof window&&null!==window&&"function"==typeof window.scroll&&"object"==typeof navigator&&null!==navigator&&"string"==typeof navigator.userAgent&&!(navigator.userAgent.indexOf("Node.js")>0||navigator.userAgent.indexOf("jsdom")>0))try{window.scroll(0,0)}catch(r){}}function E(r,e){var n={};if(r.name)for(var t,i=a(Object.keys(r.params).sort());!(t=i()).done;){var o=t.value,u=e[r.name]["~internal"].params[o]["~internal"];"state"===u.kind&&(n[o]=u.valueSerializer.stringify(r.params[o]))}return n}var q=s;function z(){for(var n,t,i,o,u,l=arguments.length,f=new Array(l),c=0;c<l;c++)f[c]=arguments[c];var s,p,m=N(f),v=m.routeDefs,d=m.opts,y=x({startListening:function(){p=s.listen((function(r){if(D)D=!1;else{var n=j(r.location,h),a=r.action.toLowerCase(),t=P(n,J()),i=t.primaryPath;_(e({},t.route,{action:a}),i)}}))},stopListening:function(){return null==p?void 0:p()}}),h=null!=(n=d.baseUrl)?n:"/",g=null!=(t=null==(i=d.arrayFormat)?void 0:i.separator)?t:",",b=null!=(o=d.queryStringSerializer)?o:S({queryStringArrayFormat:null==(u=d.arrayFormat)?void 0:u.queryString,arraySeparator:g}),D=!1,k=!1,z=null,C=null,A=[];M(d.session);var I,U=R(J),L={push:function(r,n){var a=w(r,n,J()),t=a.primaryPath;return B(e({},a.route,{action:"push"}),t)},replace:function(r,n){var a=w(r,n,J()),t=a.primaryPath;return B(e({},a.route,{action:"replace"}),t)},back:function(r){void 0===r&&(r=1),s.go(-r)},forward:function(r){void 0===r&&(r=1),s.go(r)},getInitialRoute:function(){if(!z){var r=P(j(s.location,h),J());r.primaryPath||(k=!0,r.route.replace(),r=P(j(s.location,h),J())),z=r.route}return z},reset:function(r){return M(r)},block:function(r){A.push(r);var n=s.block((function(n){var a=P(j(n.location,h),J()).route,t=n.action.toLowerCase();r({route:e({},a,{action:t}),retry:n.retry})}));return function(){A.splice(A.findIndex((function(e){return e===r})),1),n()}},listen:function(r){return y.add(r)}},K=(I=L.getInitialRoute(),L.listen((function(r){return I=r})),{getRoute:function(){return I}}),H=K.getRoute,F={routes:U,session:L,stopListening:function(){return null==p?void 0:p()},getRoute:H};return F;function M(e){void 0===e&&(e={type:"undefined"!=typeof window&&void 0!==window.document?"browser":"memory"}),z=null,s="memory"===e.type?r.createMemoryHistory({initialEntries:e.initialEntries,initialIndex:e.initialIndex}):"hash"===e.type?r.createHashHistory({window:e.window}):r.createBrowserHistory({window:e.window})}function B(r,e){var n;if(A.length>0)A.forEach((function(e){e({route:r,retry:function(){r["push"===r.action?"push":"replace"]()}})}));else{var a=E(r,v);if((null==(n=C)?void 0:n.href)!==r.href||JSON.stringify(E(C,v))!==JSON.stringify(a)){k?k=!1:_(r,e),D=!0;var t=q(r.href,"?"),i=t[1];s["replace"===r.action?"replace":"push"]({pathname:t[0],search:i?"?"+i:"",hash:""},a?{state:a}:void 0)}}}function _(r,e){if(e){for(var n,t=a(y.getHandlers());!(n=t()).done;)(0,n.value)(r);!0===d.scrollToTop&&O(r),C=r}else r.replace()}function J(){return{queryStringSerializer:b,arraySeparator:g,navigate:B,history:s,routeDefs:v,getRoutes:function(){return U},baseUrl:h}}}function N(r){return{routeDefs:1===r.length?r[0]:r[1],opts:1===r.length?{}:r[0]}}function R(r){var e={},n=r().routeDefs;for(var a in n)e[a]=b(a,n[a],r);return e}function C(r){return 1===r.length?{params:{},path:function(){return r[0]}}:{params:r[0],path:r[1]}}var A={id:"boolean",parse:function(r){return"true"===r||"false"!==r&&l},stringify:function(r){return r?"true":"false"}},I={id:"number",parse:function(r){return e=r,isNaN(parseFloat(e))||!/^-?\d*\.?\d*$/.test(e)?l:parseFloat(r);var e},stringify:function(r){return r.toString()}},U={id:"string",parse:function(r){return r},stringify:function(r){return r}},L={path:e({},K("path",!1),{trailing:K("path",!0)}),query:K("query",!1),state:K("state",!1)};function K(r,n){return e({},a(!1,!1),{array:a(!1,!0),optional:e({},a(!0,!1),{array:a(!0,!0)})});function a(e,a){return{string:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:e,valueSerializer:U,trailing:n,default:void 0}}),number:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:e,valueSerializer:I,trailing:n,default:void 0}}),boolean:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:e,valueSerializer:A,trailing:n,default:void 0}}),ofType:function(i){return void 0===i&&(i={id:"json",parse:function(r){var e;try{e=JSON.parse(r)}catch(r){return l}return e},stringify:function(r){return JSON.stringify(r)}}),t({"~internal":{type:"ParamDef",array:a,kind:r,optional:e,valueSerializer:i,trailing:n,default:void 0}})}}}function t(r){var n=r["~internal"];return n.optional?{"~internal":n,default:function(r){return{"~internal":e({},n,{default:r})}}}:{"~internal":n}}}function H(r){var e={};return r.forEach((function(r){r.routeNames?r.routeNames.forEach((function(r){e[r]=!0})):e[r.name]=!0})),{"~internal":{type:"RouteGroup",Route:null},routeNames:Object.keys(e),has:function(r){return!1!==r.name&&!!e[r.name]}}}exports.createGroup=function(r){return r instanceof Array?H(r):(e=z(r),n=H(Object.values(e.routes)),e.stopListening(),n);var e,n},exports.createRouter=z,exports.defineRoute=function r(){for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];var o=C(a),u={"~internal":{type:"RouteDef",params:o.params,path:o.path},extend:function(){for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];var u=C(a),l=u.params,f=u.path,c=Object.keys(o.params),s=Object.keys(l);return c.filter((function(r){return s.indexOf(r)>=0})),r(e({},l,o.params),(function(r){var e,n=t(o.path(i(c))),a=t(f(i(s)));return(e=[]).concat.apply(e,n.map((function(r){return a.map((function(e){return"/"===r?e:r+("/"===e?"":e)}))})));function i(e){var n={};return e.forEach((function(e){n[e]=r[e]})),n}}))}};return u},exports.noMatch=l,exports.param=L,exports.preventDefaultLinkClickBehavior=y;
 //# sourceMappingURL=type-route.cjs.production.min.js.map
diff --git a/node_modules/type-route/core/type-route.cjs.production.min.js.map b/node_modules/type-route/core/type-route.cjs.production.min.js.map
index d4cc01d..94ae71c 100644
--- a/node_modules/type-route/core/type-route.cjs.production.min.js.map
+++ b/node_modules/type-route/core/type-route.cjs.production.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"type-route.cjs.production.min.js","sources":["../src/asArray.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/createMatcher.ts","../src/getQueryMatch.ts","../src/getStateMatch.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts"],"sourcesContent":["export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session: {\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n    },\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n"],"names":["asArray","value","Array","isArray","getParamId","parameterName","getParamDefsOfType","type","paramDefCollection","filteredParamDefCollection","Object","keys","forEach","name","paramDef","kind","stringify","urlEncode","result","valueSerializer","encodeURIComponent","noMatch","__noMatch","stringUtils","start","i","length","end","split","_value$split","slice","join","endsWith","startsWith","getObjectMatch","_ref","_step","object","paramDefs","urlEncodeDefault","arraySeparator","params","namedParamDefs","map","_extends","extraneousParams","_loop","raw","undefined","optional","v","array","part","parse","_paramDef$Internal$v","decodeURIComponent","some","_paramDef$Internal$v2","_iterator","_createForOfIteratorHelperLoose","done","_ret","numExtraneousParams","createMatcher","pathDefs","queryParamDefCollection","stateParamDefCollection","defaultParams","paramName","param","_ref2","routerLocation","queryStringSerializer","path","pathMatch","index","match","primaryPath","pathDef","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","_pathSegmentDef$named","pathSegmentDef","pathSegment","namedParamDef","trailing","leading","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","Math","max","getPathMatch","queryMatch","query","getQueryMatch","stateMatch","state","getStateMatch","preventDefaultLinkClickBehavior","event","target","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","preventDefault","buildRoute","routeName","location","routerContext","navigate","href","history","createHref","pathname","fullPath","search","baseUrl","route","link","onClick","push","action","replace","createRouteBuilder","routeDef","getRouterContext","pathParamDefCollection","getRawPath","namedPathParamDefs","paramIdCollection","rawPath","rawPathSegments","usedPathParams","_step2","rawSegment","includedParamDef","_iterator2","indexOf","_rawSegment$split","filter","build","paramsWithDefault","paramCollection","paramValue","getValue","valueSerializerId","id","_ref3","reduce","key","_extends2","createLocation","defineProperty","Route","createQueryStringSerializer","args","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","rest","encodedName","getMatchingRoute","routes","getRoutes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","splitFirst","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","handler","splice","getHandlers","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sort","parseArgs","opts","createRouteBuilderCollection","boolean","number","isNaN","parseFloat","test","toString","string","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","~internal","default","ofType","JSON","internal","groupItems","routeNames","item","has","_len","_key","arguments","unlisten","_parseArgs","navigationHandlerManager","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","router","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","retry","findIndex","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","defineRoute","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","x","parentPathArray","childPathArray","concat","apply","parentPath","childPath","allowedKeys","filteredX"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"type-route.cjs.production.min.js","sources":["../src/asArray.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/createMatcher.ts","../src/getQueryMatch.ts","../src/getStateMatch.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts"],"sourcesContent":["export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const session: UmbrellaCoreRouter[\"session\"] = {\n\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n\n  };\n\n  const { getRoute } = (() => {\n    let route_current = session.getInitialRoute();\n\n    session.listen(route => (route_current = route));\n\n    function getRoute() {\n        return route_current;\n    }\n\n    return { getRoute };\n  })();\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session,\n    stopListening: ()=> unlisten?.(),\n    getRoute\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    if( opts.scrollToTop === true){\n      attemptScrollToTop(route);\n    }\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder, CoreRouter } from \"./types\";\nimport { assert } from \"./assert\";\nimport { createRouter as coreCreateRouter } from \"./createRouter\";\n\nfunction createGroup_fromItems<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n\nexport function createGroup_fromRouteDefs<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n> {\n  const core = coreCreateRouter(routeDefs);\n\n  const group= createGroup_fromItems(\n    Object.values(core.routes)\n  );\n\n  core.stopListening();\n\n  return group;\n}\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;\nexport function createGroup<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n>;\nexport function createGroup(\n  arg: any[] | Record<string, unknown>\n): RouteGroup<any> {\n  return arg instanceof Array\n    ? createGroup_fromItems(arg)\n    : createGroup_fromRouteDefs(arg);\n}\n\n\n"],"names":["asArray","value","Array","isArray","getParamId","parameterName","getParamDefsOfType","type","paramDefCollection","filteredParamDefCollection","Object","keys","forEach","name","paramDef","kind","stringify","urlEncode","result","valueSerializer","encodeURIComponent","noMatch","__noMatch","stringUtils","start","i","length","end","split","_value$split","slice","join","endsWith","startsWith","getObjectMatch","_ref","_step","object","paramDefs","urlEncodeDefault","arraySeparator","params","namedParamDefs","map","_extends","extraneousParams","_loop","raw","undefined","optional","v","array","part","parse","_paramDef$Internal$v","decodeURIComponent","some","_paramDef$Internal$v2","_iterator","_createForOfIteratorHelperLoose","done","_ret","numExtraneousParams","createMatcher","pathDefs","queryParamDefCollection","stateParamDefCollection","defaultParams","paramName","param","_ref2","routerLocation","queryStringSerializer","path","pathMatch","index","match","primaryPath","pathDef","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","_pathSegmentDef$named","pathSegmentDef","pathSegment","namedParamDef","trailing","leading","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","Math","max","getPathMatch","queryMatch","query","getQueryMatch","stateMatch","state","getStateMatch","preventDefaultLinkClickBehavior","event","target","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","preventDefault","buildRoute","routeName","location","routerContext","navigate","href","history","createHref","pathname","fullPath","search","baseUrl","route","link","onClick","push","action","replace","createRouteBuilder","routeDef","getRouterContext","pathParamDefCollection","getRawPath","namedPathParamDefs","paramIdCollection","rawPath","rawPathSegments","usedPathParams","_step2","rawSegment","includedParamDef","_iterator2","indexOf","_rawSegment$split","filter","build","paramsWithDefault","paramCollection","paramValue","getValue","valueSerializerId","id","_ref3","reduce","key","_extends2","createLocation","defineProperty","Route","createQueryStringSerializer","args","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","rest","encodedName","getMatchingRoute","routes","getRoutes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","splitFirst","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","handler","splice","getHandlers","attemptScrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sort","createRouter","_len","_key","arguments","unlisten","_parseArgs","parseArgs","opts","navigationHandlerManager","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","route_current","createRouteBuilderCollection","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","retry","findIndex","item","getRoute","router","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","JSON","hash","scrollToTop","boolean","number","isNaN","parseFloat","test","toString","string","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","~internal","default","ofType","internal","createGroup_fromItems","groupItems","routeNames","has","arg","core","coreCreateRouter","group","values","defineRoute","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","x","parentPathArray","childPathArray","concat","apply","parentPath","childPath","allowedKeys","filteredX"],"mappings":"qnCAAgBA,EAAWC,GACzB,OAAOC,MAAMC,QAAQF,GAASA,EAAQ,CAACA,GC4OzC,SAASG,EAAWC,GAClB,MAAO,OAASA,EAAgB,aC5OlBC,EACdC,EACAC,GAEA,IAAMC,EAA6D,GAUnE,OARAC,OAAOC,KAAKH,GAAoBI,SAAQ,SAACC,GACvC,IAAMC,EAAWN,EAAmBK,GAChCC,EAAS,aAAaC,OAASR,IACjCE,EAA2BI,GACzBC,MAICL,ECkIT,SAASO,EACPF,EACAb,EACAgB,GAEA,IAAMC,EAASJ,EAAS,aAAaK,gBAAgBH,UAAUf,GAQ/D,OAAOgB,EAAYG,mBAAmBF,GAAUA,MC/JrCG,EAAU,CAAEC,WAAW,GCAvBC,EAEb,SAAoBtB,EAAeuB,GACjC,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAChC,GAAID,EAAMC,KAAOxB,EAAMwB,GACrB,OAAO,EAGX,OAAO,GARIF,EAWb,SAAkBtB,EAAe0B,GAC/B,IAAK,IAAIF,EAAI,EAAGA,GAAKE,EAAID,OAAQD,IAC/B,GAAIE,EAAIA,EAAID,OAASD,KAAOxB,EAAMA,EAAMyB,OAASD,GAC/C,OAAO,EAGX,OAAO,GAjBIF,EAoBb,SAAoBtB,EAAe2B,GACjC,IAAAC,EAAyB5B,EAAM2B,MAAMA,GACrC,MAAO,CADKC,KAASA,EAAAC,SACDC,KAAKH,KClBnBI,EAAyBT,EAAfU,EAAeV,WCDjBW,EAAcC,GAmB5B,QAAqCC,EAlBrCC,EAAMF,EAANE,OACAC,EAASH,EAATG,UACAC,EAAgBJ,EAAhBI,iBACAC,EAAcL,EAAdK,eAOMC,EAAkC,GAElCC,EAAiBhC,OAAOC,KAAK2B,GAAWK,KAAI,SAAC9B,GACjD,OAAA+B,GAAS/B,KAAAA,GAASyB,EAAUzB,OAGxBgC,EAAgBD,KAAQP,GAASS,aAAA,IAE5BhC,EAAQsB,EAAAnC,MACb8C,EAAMV,EAAOvB,EAASD,MAG1B,UAFOgC,EAAiB/B,EAASD,WAErBmC,IAARD,EACF,OAAIjC,EAAS,aAAamC,qBAI1BC,GAAO,GAGT,IAAIjD,SAEJ,GAAY,OAAR8C,EAAc,CAChB,IAAIjC,EAAS,aAAaqC,MAEnB,OAAIrC,EAAS,aAAamC,qBAG/BC,GAAO,GAJPjD,EAAQ,QAML,GAAIa,EAAS,aAAaqC,OAS/B,IARAlD,EAAQ8C,EAAInB,MAAMY,GAAgBG,KAAI,SAACS,SACrC,OAAOtC,EAAS,aAAaK,gBAAgBkC,cAC3CC,EAAAxC,EAAS,aAAaK,gBAAgBF,WAASqC,EAAIf,GAC/CgB,mBAAmBH,GACnBA,OAIEI,MAAK,SAACJ,GAAI,OAAKA,IAAS/B,KAChC,OAAIP,EAAS,aAAamC,qBAI1BC,GAAO,OAEJ,CAAA,IAAAO,EAOL,IANAxD,EAAQa,EAAS,aAAaK,gBAAgBkC,cAC5CI,EAAA3C,EAAS,aAAaK,gBAAgBF,WAASwC,EAAIlB,GAC/CgB,mBAAmBR,GACnBA,MAGQ1B,EACZ,OAAIP,EAAS,aAAamC,qBAI1BC,GAAO,GAIXT,EAAO3B,EAASD,MAAQZ,GAtD1ByD,EAAAC,EAAuBjB,KAAcN,EAAAsB,KAAAE,MAAE,CAAA,IAAAC,EAAAf,IAAA,gBAAAe,oBA+CtBA,SAAAA,EAAAX,EAUjB,MAAO,CAAET,OAAAA,EAAQqB,oBAAqBpD,OAAOC,KAAKkC,GAAkBnB,iBCpEtDqC,EAAa5B,OAC3B6B,EAAQ7B,EAAR6B,SACAvB,EAAMN,EAANM,OAKMwB,EAA0B3D,EAAmB,QAASmC,GACtDyB,EAA0B5D,EAAmB,QAASmC,GAEtD0B,EAAyC,GAU/C,OARAzD,OAAOC,KAAK8B,GAAQ7B,SAAQ,SAACwD,GAC3B,IAAMC,EAAQ5B,EAAO2B,QACcpB,IAA/BqB,EAAM,uBAGVF,EAAcC,GAAaC,EAAM,yBAG5B,SAAAC,OACLC,EAAcD,EAAdC,eACA/B,EAAc8B,EAAd9B,eACAgC,EAAqBF,EAArBE,sBAMA,QAA4BxB,IAAxBuB,EAAeE,KACjB,OAAO,EAGT,IAAMC,WFtCkBvC,GAS1B,QARAsC,EAAItC,EAAJsC,KACAT,EAAQ7B,EAAR6B,SACAxB,EAAcL,EAAdK,eAMSmC,EAAQ,EAAGA,EAAQX,EAAStC,OAAQiD,IAAS,CACpD,IAAMzD,EAAS0D,EAAMZ,EAASW,IAC9B,IAAe,IAAXzD,EACF,OAAA0B,KAAY1B,GAAQ2D,YAAuB,IAAVF,IAIrC,OAAO,EAEP,SAASC,EAAME,GACb,IAAMrC,EAAkC,GAExC,GAAa,MAATgC,GAAmC,IAAnBK,EAAQpD,OAC1B,MAAO,CAAEe,OAAAA,EAAQqB,oBAAqB,GAGxC,IAAMiB,EAAuBN,EAAK/C,OAAS,GAAKM,EAASyC,EAAM,KAE3DM,IACFN,EAAOA,EAAK3C,MAAM,EAAG2C,EAAK/C,OAAS,IAKrC,IAFA,IAAMsD,EAAkBP,EAAK7C,MAAM,KAAKE,MAAM,GAAGgB,WAG3CmC,GAAY,IAAAC,EAAAC,EAiBUC,EAbpBC,EACJJ,GAAgBH,EAAQpD,OAAS,KAAOoD,EAAQG,GAC9CK,EACFL,GAAgBD,EAAgBtD,OAC5B,KACAsD,EAAgBC,GAEtB,GAAuB,OAAnBI,EACF,OAAAnC,GAAO,GAKT,GAAoB,OAAhBoC,EACF,OACkC,GAJAR,EAAQpD,OAAS,EAAIuD,UAKrDG,EAACC,EAAeE,gBAAfH,EAA+B,aAAanC,kBAE7CC,GAAO,GAUX,UAJAgC,EAAIG,EAAeE,gBAAfL,EAA+B,aAAaM,WAC9CF,EAAcN,EAAgBlD,MAAMmD,GAAclD,KAAK,OAGpDE,EAAWqD,EAAaD,EAAeI,SAC1C,OAAAvC,GAAO,GAGT,IAAMwC,EAA0BJ,EAAYxD,MAC1CuD,EAAeI,QAAQ/D,QAGzB,IAAKM,EAAS0D,EAAyBL,EAAeG,UACpD,OAAAtC,GAAO,GAGT,IAAMyC,EAAqCD,EAAwB5D,MACjE,EACA4D,EAAwBhE,OAAS2D,EAAeG,SAAS9D,QAG3D,IAAK2D,EAAeE,cAClB,MAA2C,KAAvCI,cAIJzC,GAAO,GAGT,GAA2C,KAAvCyC,EACF,OAAIN,EAAeE,cAAc,aAAatC,qBAI9CC,GAAO,GAGT,IAAMjC,SAASkE,EACbE,EAAeE,cAAc,aAAapE,gBAAgBF,WAASkE,GAClEE,EAAeE,cAAc,aAAaC,SAEzCvF,SAEJ,GAAIoF,EAAeE,cAAc,aAAapC,OAW5C,IAVAlD,EAAQ0F,EACL/D,MAAMY,GACNG,KAAI,SAACS,SACJ,cAAAwC,EAAOP,EAAeE,sBAAfK,EACL,aACAzE,gBAAgBkC,MAChBpC,EAAYsC,mBAAmBH,GAAQA,OAInCI,MAAK,SAACJ,GAAI,OAAKA,IAAS/B,KAChC,OAAA6B,GAAO,QAST,IANAjD,EAAQoF,EAAeE,cAAc,aAAapE,gBAAgBkC,MAChEpC,EACIsC,mBAAmBoC,GACnBA,MAGQtE,EACZ,OAAA6B,GAAO,GAcX,OATEmC,EAAeE,cAAc,aAAaC,UAC1CT,GAC4B,KAA5BM,EAAeG,WAEfvF,QAGFwC,EAAO4C,EAAeE,cAAcnB,WAAanE,EAE7CoF,EAAeE,cAAc,aAAaC,sBAA9C,GA3GIP,EAAe,EACnBA,EAAeY,KAAKC,IAAIhB,EAAQpD,OAAQsD,EAAgBtD,QACxDuD,IACA,CAAA,IAAApB,EAAAf,EAHImC,GAAY,aAAApB,EA4Gd,MAAM,gBAAAA,oBAjDKA,SAAAA,EAAAX,EAqDf,MAAO,CAAET,OAAAA,EAAQqB,oBAAqB,IE5GpBiC,CAAa,CAC7BtB,KAAMF,EAAeE,KACrBT,SAAAA,EACAxB,eAAAA,IAGF,IAAkB,IAAdkC,EACF,OAAO,EAGT,IAAMsB,WCjDRC,EACA3D,EACAkC,EACAhC,GAEA,IAAIH,EAAwC,GAgB5C,OAdI4D,IACF5D,EAASmC,EAAsBnB,MAAM4C,IAahC/D,EAAe,CACpBG,OAAAA,EACAC,UAAAA,EACAC,kBAAkB,EAClBC,eAAAA,IDwBmB0D,CACjB3B,EAAe0B,MACfhC,EACAO,EACAhC,GAEF,IAAmB,IAAfwD,EACF,OAAO,EAGT,IAAMG,WE5DRC,EACA9D,EACAE,GAEA,OAAON,EAAe,CACpBG,aAAQ+D,EAAAA,EAAS,GACjB9D,UAAAA,EACAC,kBAAkB,EAClBC,eAAAA,IFoDmB6D,CACjB9B,EAAe6B,MACflC,EACA1B,GAEF,OAAmB,IAAf2D,GAIG,CACLtB,YAAaH,EAAUG,YACvBpC,OAAMG,KACDuB,EACAO,EAAUjC,OACVuD,EAAWvD,OACX0D,EAAW1D,QAEhBqB,oBACEY,EAAUZ,oBACVkC,EAAWlC,oBACXqC,EAAWrC,+BGlFHwC,EAAgCC,GAO9C,gBAP8CA,IAAAA,EAAa,MACjDA,EAILC,QAJKD,EAIQC,OAAOA,QAA8B,UAJ7CD,EAI2BC,OAAOA,QAJlCD,EAQLE,kBACU,IATLF,EASNG,QATMH,EACmBI,SADnBJ,EACgCK,QADhCL,EAC4CM,SAD5CN,EACyDO,WADzDP,GAAAA,EAYGQ,gBAZHR,EAaJQ,iBAGG,ICfX,IAAQ9E,EAAeV,WAEPyF,EAAU7E,OACxB8E,EAAS9E,EAAT8E,UACAxE,EAAMN,EAANM,OACAyE,EAAQ/E,EAAR+E,SACAC,EAAahF,EAAbgF,cAOQC,EAAsBD,EAAtBC,SAEJC,EAF0BF,EAAZG,QAECC,WAAW,CAC5BC,UAAwB,IAAdP,EAAsBC,EAASO,SAAWP,EAASzC,KAC7DiD,OAAQR,EAASjB,MAAQ,IAAMiB,EAASjB,MAAQ,KAG9ChE,EAAWoF,EAAM,OACnBA,EAAO,IAAMA,IAGG,IAAdJ,GAAiD,MAA1BE,EAAcQ,UACvCN,EAAOF,EAAcQ,QAAUN,GAGjC,IAAMO,EAAuB,CAC3B/G,KAAMoG,EACNxE,OAAAA,EACA4E,KAAAA,EACAQ,KAAM,CACJR,KAAAA,EACAS,QAAS,SAACvB,GACR,GAAID,EAAgCC,GAClC,OAAOqB,EAAMG,SAInBC,OAAQ,KACRD,KAAM,WAAA,OAAMX,EAAQxE,KAAMgF,GAAOI,OAAQ,UAAU,IACnDC,QAAS,WAAA,OAAMb,EAAQxE,KAAMgF,GAAOI,OAAQ,aAAa,KAG3D,OAAOJ,WCxCOM,EACdjB,EACAkB,EACAC,GAEA,IZAAC,EACAC,EAEMC,EAWAC,EYdAxE,GZANqE,EYEE/H,EAAmB,OAAQ6H,EAAS,aAAa1F,QZDnD6F,EYEEH,EAAS,aAAa1D,KZAlB8D,EAAqB7H,OAAOC,KAAK0H,GAAwB1F,KAC7D,SAACyB,GAMC,OALkCxB,GAChCwB,UAAAA,GACGiE,EAAuBjE,OAO1BoE,EAAuC,GAE7CD,EAAmB3H,SAAQ,SAAAuB,OAAGiC,EAASjC,EAATiC,UAe5BoE,EAAkBpE,GAAahE,EAAWgE,MAkBrCpE,EAfSsI,EAAWE,IAeH7F,KAAI,SAAC8F,GAoB3B,GAAuB,IAAnBA,EAAQ/G,OACV,MAAO,GAgBT,IALA,IAKwCU,EALlCsG,EAAkBD,EAAQ7G,MAAM,KAAKE,MAAM,GAE3C6G,EAAuC,GACvC7D,EAAmB,GAEzBpB,EAAAC,EAAyB+E,KAAetG,EAAAsB,KAAAE,MAAE,CAWxC,IAXwC,IAWCgF,EAXhCC,EAAUzG,EAAAnC,MASf6I,EAAsD,KAE1DC,EAAApF,EAAuB4E,KAAkBK,EAAAG,KAAAnF,MAAE,CAAA,IAAhC9C,EAAQ8H,EAAA3I,MACb4I,EAAWG,QAAQ5I,EAAWU,EAASsD,aAAe,IAiBxD0E,EAAmBhI,EACnB6H,EAAe7H,EAASsD,YAAa,GAIzC,GAAI0E,EAAkB,CACpB,IAAAG,EAA4BJ,EAAWjH,MACrCxB,EAAW0I,EAAiB1E,YA+B9BU,EAAQiD,KAAK,CACXtC,QAjCYwD,KAkCZzD,SAlCsByD,KAmCtB1D,cAAeuD,SAYjBhE,EAAQiD,KAAK,CACXtC,QAASoD,EACTrD,SAAU,GACVD,cAAe,OAgDrB,OAbuCgD,EACpC5F,KAAI,SAAA2B,GAAY,OAAMA,EAAfF,aACP8E,QAAO,SAACrI,GAAI,OAAM8H,EAAe9H,MAW7BiE,MYrNHqE,EAA8B,SAClC1G,YAAAA,IAAAA,EAAkC,IAuClC,IAAM0E,EAAgBiB,IAEd5F,EAAmD2E,EAAnD3E,eAAgBgC,EAAmC2C,EAAnC3C,sBAAuBmD,EAAYR,EAAZQ,QAEzCyB,EAAiBxG,KAAQH,GAE/B/B,OAAOC,KAAKwH,EAAS,aAAa1F,QAAQ7B,SAAQ,SAACwD,GACjD,IAAMtD,EAAWqH,EAAS,aAAa1F,OAAO2B,QAGXpB,IAAjCoG,EAAkBhF,SACgBpB,IAAlClC,EAAS,uBAETsI,EAAkBhF,GAAatD,EAAS,yBAI5C,IAAMoG,WV7DoB/E,OAC5BkH,EAAelH,EAAfkH,gBACA7I,EAAkB2B,EAAlB3B,mBACAgC,EAAcL,EAAdK,eACAgC,EAAqBrC,EAArBqC,sBACAR,EAAQ7B,EAAR6B,SACA2D,EAAOxF,EAAPwF,QASMlF,EAAS,CACbgC,KAAM,GACNwB,MAAO,GACPG,MAAO,IACPtD,WAESsB,GAAS,IAAAd,EACZgG,EAAaD,EAAgBjF,GAEnC,QAAmBpB,IAAfsG,EACF,iBAGF,IAAMxI,EAAWN,EAAmB4D,GAG9BnD,SAASqC,EACbxC,EAAS,aAAaK,gBAAgBF,WAASqC,EAFhB,UAA/BxC,EAAS,aAAaC,OAAqBD,EAAS,aAAa0E,SAI7D+D,EAAW,SAACD,GA4BhB,OAzBIxI,EAAS,aAAaqC,MAgBe,IAApCmG,EAAyB5H,OACtB,KACC4H,EACE3G,KAAI,SAACS,GAAI,OAAKpC,EAAUF,EAAUsC,EAAMnC,MACxCc,KAAKS,GAENxB,EAAUF,EAAUwI,EAAYrI,IAMtChB,EAAQsJ,EAASD,GAEvB,GACiC,UAA/BxI,EAAS,aAAaC,WACYiC,IAAlClC,EAAS,sBACTyI,EAASzI,EAAS,wBAA0Bb,EAE5C,iBAGFwC,EAAO3B,EAAS,aAAaC,MAAMqD,GAAa,CAC9CoF,kBAAmB1I,EAAS,aAAaK,gBAAgBsI,GACzDtG,MAAOrC,EAAS,aAAaqC,MAC7BlD,MAAAA,IAzDJ,IAAK,IAAMmE,KAAa5D,EAAoBsC,EAAjCsB,GA6DX,IAAMK,EACJ,IACAT,EAAS,GACNkF,QAAO,SAAA5E,OAAGiB,EAAajB,EAAbiB,cACT,cACEA,GAAAA,EAAgB,aAAatC,eACYD,IAAzCP,EAAOgC,KAAKc,EAAcnB,eAG7BzB,KAAI,SAAA+G,OAAGnE,EAAamE,EAAbnE,cAIN,OAJ4BmE,EAAPjE,SACJF,EACb9C,EAAOgC,KAAKc,EAAcnB,WAAWnE,MACrC,IAHkCyJ,EAARlE,YAM/BzD,KAAK,KAyBV,MAAO,CACL0F,UAAuB,MAAZE,EAAkB,GAAKA,GAAWlD,EAC7CA,KAAAA,EACAwB,MA1BqBvF,OAAOC,KAAK8B,EAAOwD,OAAOvE,OAAS,EAGtD8C,EAAsBxD,UAAUyB,EAAOwD,YACvCjD,EAuBFoD,MAdqC,IAArC1F,OAAOC,KAAK8B,EAAO2D,OAAO1E,YACtBsB,EACAtC,OAAOC,KAAK8B,EAAO2D,OAAOuD,QACxB,SAACvD,EAAOwD,GAAG,IAAAC,EAAA,OAAAjH,KACNwD,IAAKyD,MACPD,GAAMnH,EAAO2D,MAAMwD,GAAK3J,MAAK4J,MAEhC,KU1DWC,CAAe,CAC9BT,gBAAiB5G,EACjBjC,mBAAoB2H,EAAS,aAAa1F,OAC1CD,eAAAA,EACAgC,sBAAAA,EACAR,SAAAA,EACA2D,QAAAA,IAGF,OAAOX,EAAW,CAChBC,UAAAA,EACAxE,OAAQ2G,EACRlC,SAAAA,EACAC,cAAAA,KAgBJ,OAZAzG,OAAOqJ,eAAeZ,EAAO,OAAQ,CAAElJ,MAAOgH,IAE9CkC,EAAM,aAAe,CACnB5I,KAAM,eACNqE,MAAOb,EAAc,CACnBC,SAAAA,EACAvB,OAAQ0F,EAAS,aAAa1F,SAEhCuB,SAAAA,EACAgG,MAAO,MAGFb,WCvGOc,EACdC,oBAAAA,IAAAA,EAGI,IAEJ,IAAMC,SAAsBC,EAC1BF,EAAKC,wBAAsBC,EAAI,uBAC3B5H,SAAc6H,EAAGH,EAAK1H,gBAAc6H,EAAI,IAExCC,EACuB,aAA3BH,GAC2B,wBAA3BA,EAEII,EACuB,aAA3BJ,GAC2B,cAA3BA,EACI,GACA,KAEN,MAAO,CACL9G,MAAO,SAACN,GAGN,IAFA,IAEiCX,EAF3BoI,EAA6C,GAEnD9G,EAAAC,EAAmBZ,EAAInB,MAAM,QAAIQ,EAAAsB,KAAAE,MAAE,CAAA,IACjC6G,EADarI,EAAAnC,MACuC2B,MAAM,KAAnD8I,EAAYD,KAAEE,EAAaF,KAAKG,EAAIH,EAAA3I,SAE3C,UAAqBkB,IAAjB0H,GAA8BE,EAAKlJ,OAAS,GAAhD,CAIA,IAAMkI,EAAMrG,mBACVhC,EAAqBmJ,EAAcH,GAC/BG,EAAa5I,MAAM,EAAG4I,EAAahJ,OAAS6I,EAAe7I,QAC3DgJ,QAGgB1H,IAAlB2H,EACFH,EAAYZ,GAAO,KACVY,EAAYZ,IAAQU,EAC7BE,EAAYZ,OAAWpH,EAAiBmI,EAExCH,EAAYZ,GAAOe,GAIvB,OAAOH,GAGTxJ,UAAW,SAACwJ,GACV,OAAO9J,OAAOC,KAAK6J,GAChB7H,KAAI,SAAC9B,GACJ,IAAMgK,EAAczJ,mBAAmBP,GACjC+I,EAAMY,EAAY3J,GAAMsC,SACvB0H,EAAcN,EACjBM,EACE5K,EAAQuK,EAAY3J,GAAMZ,MAEhC,OAAc,OAAVA,EACK2J,EAGLY,EAAY3J,GAAMsC,OAASmH,EACVrK,EAAM2B,MAAMY,GACbG,KAAI,SAACS,GAAI,OAAQwG,MAAOxG,KAAQrB,KAAK,KAG/C6H,MAAO3J,KAElB8B,KAAK,gBCrEE+I,EACd5D,EACAC,GAEA,IAAmB3C,EAA0C2C,EAA1C3C,sBAAuBhC,EAAmB2E,EAAnB3E,eAEpCuI,GAASC,EAF8C7D,EAArD6D,aAIJC,GAAyD,EAE7D,IAAK,IAAMhE,KAAa8D,EAAQ,CAC9B,IAAMnG,EAAQmG,EAAO9D,GAAW,aAAarC,MAAM,CACjDL,eAAgB2C,EAChB1C,sBAAAA,EACAhC,eAAAA,IAGF,IAAc,IAAVoC,EAAJ,CAIA,GAAkC,IAA9BA,EAAMd,oBACR,MAAO,CACL8D,MAAOmD,EAAO9D,GAAWrC,EAAMnC,QAC/BoC,YAAaD,EAAMC,eAKH,IAAlBoG,GACArG,EAAMd,oBAAsBmH,EAAcnH,uBAE1CmH,EAAarI,KAAQgC,GAAOqC,UAAAA,MAIhC,OAAIgE,EACK,CACLrD,MAAOmD,EAAOE,EAAchE,WAAWgE,EAAcxI,QACrDoC,YAAaoG,EAAcpG,aAIxB,CACL+C,MAAOZ,EAAW,CAChBC,WAAW,EACXxE,OAAQ,GACRyE,SAAAA,EACAC,cAAAA,IAEFtC,aAAa,GCjDjB,IAAQ5C,EAAeV,WAEP2J,EACdC,EACAxD,GAEA,MAAO,CACLF,SAAU0D,EAAY3D,SACtB/C,KAAMxC,EAAWkJ,EAAY3D,SAAUG,GACvB,MAAZA,EACEwD,EAAY3D,SAASS,QAAQN,EAAS,IACtCwD,EAAY3D,cACdxE,EACJiD,MAAOkF,EAAYzD,OACfzF,EAAWkJ,EAAYzD,OAAQ,KAC7ByD,EAAYzD,OAAO5F,MAAM,GACzBqJ,EAAYzD,YACd1E,EACJoD,MAC+B,iBAAtB+E,EAAY/E,OAA4C,OAAtB+E,EAAY/E,MAChD+E,EAAY/E,MAA6CA,WAC1DpD,GCpBV,IAAQoI,EAAe7J,EAEvB,SAAgB8J,EACdhE,EACAjB,EACAe,GAEA,IAAAmE,EAA2BF,EAAW/D,EAAM,KAW5C,OAAOyD,EATUI,EACf,CACE1D,SAJW8D,KAKX5D,OALmB4D,KAMnBlF,MAAAA,GAEFe,EAAcQ,SAGkBR,YCrBpBoE,EAA8BpJ,OAC5CqJ,EAAcrJ,EAAdqJ,eACAC,EAAatJ,EAAbsJ,cAKMC,EAGA,GACFC,EAAY,EAEhB,MAAO,CAAEC,IAMT,SAAaC,GACX,IAAMpC,EAAKkC,IAOX,OANAD,EAAc3D,KAAK,CAAE0B,GAAAA,EAAIoC,QAAAA,IAEI,IAAzBH,EAAchK,QAChB8J,IAKF,WACE,IAAM7G,EAAQ+G,EAAc/I,KAAI,SAAA+G,GAAK,OAAAA,EAAFD,MAAaT,QAAQS,GACpD9E,GAAS,IACX+G,EAAcI,OAAOnH,EAAO,GACC,IAAzB+G,EAAchK,QAChB+J,OArBMM,YAEd,WACE,OAAOL,EAAc/I,KAAI,SAAA2B,GAAU,OAAAA,EAAPuH,sBChBhBG,EACdpE,GAEA,GACmB,SAAjBA,EAAMI,QACY,iBAAXiE,QACI,OAAXA,QACyB,mBAAlBA,OAAOC,QACO,iBAAdC,WACO,OAAdA,WAC+B,iBAAxBA,UAAUC,aAEfD,UAAUC,UAAUpD,QAAQ,WAAa,GACzCmD,UAAUC,UAAUpD,QAAQ,SAAW,GAGzC,IACEiD,OAAOC,OAAO,EAAG,GACjB,MAAAG,cClBUC,EACd1E,EACA2E,GAEA,IAAMnG,EAAgC,GAEtC,GAAIwB,EAAM/G,KAER,IADA,IACoCuB,EAApCsB,EAAAC,EADqBjD,OAAOC,KAAKiH,EAAMnF,QAAQ+J,UACXpK,EAAAsB,KAAAE,MAAE,CAAA,IAA3BQ,EAAShC,EAAAnC,MACZa,EACJyL,EAAU3E,EAAM/G,MAAM,aAAa4B,OAAO2B,GAAW,aAEjC,UAAlBtD,EAASC,OAEXqF,EAAMhC,GAAatD,EAASK,gBAAgBH,UAD9B4G,EAAMnF,OAAO2B,KAMjC,OAAOgC,MCSWgF,EAAe7J,EAWnC,SAAgBkL,yCAAgBvC,MAAWhK,MAAAwM,GAAAC,IAAAA,EAAAD,EAAAC,IAAXzC,EAAWyC,GAAAC,UAAAD,GACzC,IAmCIrF,EACAuF,EApCJC,EAA4BC,EAAU7C,GAA9BqC,EAASO,EAATP,UAAWS,EAAIF,EAAJE,KAEbC,EAA2B1B,EAA+B,CAC9DC,eAAgB,WACdqB,EAAWvF,EAAQ4F,QAAO,SAACC,GACzB,GAAIC,EACFA,GAAyC,MAD3C,CAKA,IAAMlG,EAAWgE,EACfiC,EAAOjG,SACPS,GAEIK,EAASmF,EAAOnF,OAAOqF,cAC7BC,EAA+BxC,EAC7B5D,EACAkB,KAFavD,EAAWyI,EAAXzI,YAKf0I,EAAgB3K,KALH0K,EAAL1F,OAKqBI,OAAAA,IAAUnD,QAG3C4G,cAAe,WAAA,aAAMoB,SAAAA,OAGjBlF,SAAO6F,EAAGR,EAAKrF,SAAO6F,EAAI,IAC1BhL,SAAciL,SAAAC,EAAGV,EAAKW,oBAALD,EAAkBE,WAASH,EAAI,IAChDjJ,SAAqBqJ,EACzBb,EAAKxI,uBAAqBqJ,EAC1B5D,EAA4B,CAC1BE,8BAAsB2D,EAAEd,EAAKW,oBAALG,EAAkBC,YAC1CvL,eAAAA,IAKA4K,GAAyC,EACzCY,GAAiD,EACjDC,EAAqC,KACrCC,EAAsC,KACtCC,EAAuC,GAE3CC,EAAiBpB,EAAKqB,SAEtB,IAmIMC,EAnIAvD,EAASwD,EAA6BnG,GAEtCiG,EAAyC,CAE3CtG,cAAKV,EAAMjB,GAST,IAAAoI,EAA+BnD,EAC7BhE,EACAjB,EACAgC,KAHavD,EAAW2J,EAAX3J,YAMf,OAAOuC,EAAQxE,KANF4L,EAAL5G,OAMoBI,OAAQ,SAAUnD,IAEhDoD,iBAAQZ,EAAMjB,GASZ,IAAAqI,EAA+BpD,EAC7BhE,EACAjB,EACAgC,KAHavD,EAAW4J,EAAX5J,YAMf,OAAOuC,EAAQxE,KANF6L,EAAL7G,OAMoBI,OAAQ,YAAanD,IAEnD6J,cAAKC,YAAAA,IAAAA,EAAS,GAQZrH,EAAQsH,IAAID,IAEdE,iBAAQF,YAAAA,IAAAA,EAAS,GAQfrH,EAAQsH,GAAGD,IAEbG,2BAOE,IAAKb,EAAc,CACjB,IAAI/M,EAAS4J,EACXI,EACE5D,EAAQJ,SACRS,GAEFS,KAGGlH,EAAO2D,cACVmJ,GAAiD,EACjD9M,EAAO0G,MAAMK,UACb/G,EAAS4J,EACPI,EACE5D,EAAQJ,SACRS,GAEFS,MAGJ6F,EAAe/M,EAAO0G,MAGxB,OAAOqG,GAETc,eAAMV,GAQJ,OAAOD,EAAiBC,IAE1BW,eAAMC,GACJd,EAAkBpG,KAAKkH,GAEvB,IAAMC,EAAU5H,EAAQ0H,OAAM,SAAC7B,GAC7B,IAAQvF,EAAUkD,EAChBI,EACEiC,EAAOjG,SACPS,GAEFS,KALMR,MAQFI,EAASmF,EAAOnF,OAAOqF,cAE7B4B,EAAQ,CAAErH,MAAKhF,KAAOgF,GAAOI,OAAAA,IAAUmH,MAAOhC,EAAOgC,WAGvD,OAAO,WACLhB,EAAkBrC,OAChBqC,EAAkBiB,WAAU,SAACC,GAAI,OAAKA,IAASJ,KAC/C,GAGFC,MAGJhC,OAAQ,SAACrB,GAAO,OAAKoB,EAAyBrB,IAAIC,KAItD1J,GACMmM,EAAgBD,EAAQS,kBAE5BT,EAAQnB,QAAO,SAAAtF,GAAK,OAAK0G,EAAgB1G,KAMlC,CAAE0H,SAJT,WACI,OAAOhB,KANLgB,EAAQnN,EAARmN,SAYFC,EAA6B,CACjCxE,OAAAA,EACAsD,QAAAA,EACA5C,cAAe,WAAA,aAAKoB,SAAAA,KACpByC,SAAAA,GAGF,OAAOC,EAEP,SAASnB,EACPoB,YAAAA,IAAAA,EAA2B,CACzBjP,KACoB,oBAAX0L,aAAqD,IAApBA,OAAOwD,SAC3C,UACA,WAGRxB,EAAe,KAEb3G,EADuB,WAArBkI,EAAYjP,KACJmP,sBAAoB,CAC5BC,eAAgBH,EAAYG,eAC5BC,aAAcJ,EAAYI,eAEE,SAArBJ,EAAYjP,KACXsP,oBAAkB,CAC1B5D,OAAQuD,EAAYvD,SAGZ6D,uBAAqB,CAC7B7D,OAAQuD,EAAYvD,SAK1B,SAAS7E,EAASQ,EAAsB/C,SACtC,GAAIsJ,EAAkBzM,OAAS,EAC7ByM,EAAkBvN,SAAQ,SAACqO,GACzBA,EAAQ,CACNrH,MAAAA,EACAuH,MAAO,WACLvH,EAAuB,SAAjBA,EAAMI,OAAoB,OAAS,uBALjD,CAaA,IAAM5B,EAAQkG,EAAqB1E,EAAO2E,GAE1C,WACEwD,EAAA7B,UAAA6B,EAAe1I,QAASO,EAAMP,MAC9B2I,KAAKhP,UAAUsL,EAAqB4B,EAAe3B,MACjDyD,KAAKhP,UAAUoF,GAHnB,CAQI4H,EACFA,GAAiD,EAEjDT,EAAiB3F,EAAO/C,GAG1BuI,GAAyC,EAEzC,IAAA9B,EAA2BF,EAAWxD,EAAMP,KAAM,KAAjCK,EAAM4D,KAEvBhE,EAAyB,YAAjBM,EAAMI,OAAuB,UAAY,QAC/C,CACER,SAJW8D,KAKX5D,OAAQA,MAAaA,EAAW,GAChCuI,KAAM,IAER7J,EAAQ,CAAEA,MAAAA,QAAUpD,KAIxB,SAASuK,EAAiB3F,EAAsB/C,GAC9C,GAAKA,EAAL,CAKA,QAA4DzC,EAA5DsB,EAAAC,EAAsBsJ,EAAyBlB,iBAAa3J,EAAAsB,KAAAE,OAC1DiI,EADgBzJ,EAAAnC,OACR2H,IAGe,IAArBoF,EAAKkD,aACPlE,EAAmBpE,GAGrBsG,EAAgBtG,OAZdA,EAAMK,UAeV,SAASG,IACP,MAAO,CACL5D,sBAAAA,EACAhC,eAAAA,EACA4E,SAAAA,EACAE,QAAAA,EACAiF,UAAAA,EACAvB,UAAW,WAAA,OAAMD,GACjBpD,QAAAA,aAKUoF,EAAU7C,GAmCxB,MAAO,CAAEqC,UAjCS,IAAhBrC,EAAKxI,OAAewI,EAAK,GAAKA,EAAK,GAiCjB8C,KAhCqB,IAAhB9C,EAAKxI,OAAe,GAAKwI,EAAK,IAmCzD,SAASqE,EAA6BnG,GACpC,IAAM2C,EAA+C,GAC7CwB,EAAcnE,IAAdmE,UAER,IAAK,IAAMtF,KAAasF,EAEtBxB,EAAO9D,GAAaiB,EAClBjB,EAFesF,EAAUtF,GAIzBmB,GAIJ,OAAO2C,EC5RT,SAASgC,EAAU7C,GAIjB,OAAuB,IAAhBA,EAAKxI,OACR,CACEe,OAAQ,GACRgC,KAAM,WAAA,OAAMyF,EAAK,KAEnB,CACEzH,OAAQyH,EAAK,GACbzF,KAAMyF,EAAK,QC/GbiG,EAAoC,CACxC1G,GAAI,UACJpG,MAAO,SAACN,GAAG,MAAc,SAARA,GAAgC,UAARA,GAA0B1B,GACnEL,UAAW,SAACf,GAAK,OAAMA,EAAQ,OAAS,UAGpCmQ,EAAkC,CACtC3G,GAAI,SACJpG,MAAO,SAACN,GACN,OASe9C,EATA8C,EAUTsN,MAAMC,WAAWrQ,MAAW,gBAAgBsQ,KAAKtQ,GAT9CoB,EAGFiP,WAAWvN,GAKtB,IAAmB9C,GAHjBe,UAAW,SAACf,GAAK,OAAKA,EAAMuQ,aAOxBC,EAAkC,CACtChH,GAAI,SACJpG,MAAO,SAACN,GAAG,OAAKA,GAChB/B,UAAW,SAACf,GAAK,OAAKA,IAuBXoE,EAAQ,CACnBI,KAAI7B,KACC8N,EAAuB,QAAQ,IAClClL,SAAUkL,EAAuB,QAAQ,KAE3CzK,MAAOyK,EAAuB,SAAS,GACvCtK,MAAOsK,EAAuB,SAAS,IAGzC,SAASA,EAGP3P,EAAayE,GACb,OAAA5C,KACK+N,GAA8B,GAAO,IACxCxN,MAAOwN,GAA8B,GAAO,GAC5C1N,SAAQL,KACH+N,GAA8B,GAAM,IACvCxN,MAAOwN,GAA8B,GAAM,OAI/C,SAASA,EAGP1N,EAAqBE,GACrB,MAAO,CACLsN,OAAQG,EAAY,CAClBC,YAAa,CACXtQ,KAAM,WACN4C,MAAAA,EACApC,KAAAA,EACAkC,SAAAA,EACA9B,gBAAiBsP,EACjBjL,SAAAA,EACAsL,aAAS9N,KAIboN,OAAQQ,EAAY,CAClBC,YAAa,CACXtQ,KAAM,WACN4C,MAAAA,EACApC,KAAAA,EACAkC,SAAAA,EACA9B,gBAAiBiP,EACjB5K,SAAAA,EACAsL,aAAS9N,KAIbmN,QAASS,EAAY,CACnBC,YAAa,CACXtQ,KAAM,WACN4C,MAAAA,EACApC,KAAAA,EACAkC,SAAAA,EACA9B,gBAAiBgP,EACjB3K,SAAAA,EACAsL,aAAS9N,KAIb+N,gBACE5P,GASA,gBATAA,IAAAA,EAnF2C,CAC/CsI,GAAI,OACJpG,MAAO,SAACN,GACN,IAAI9C,EAEJ,IACEA,EAAQ+P,KAAK3M,MAAMN,GACnB,MAAAsJ,GACA,OAAOhL,EAGT,OAAOpB,GAETe,UAAW,SAACf,GAAK,OAAK+P,KAAKhP,UAAUf,MA+E1B2Q,EAAY,CACjBC,YAAa,CACXtQ,KAAM,WACN4C,MAAAA,EACApC,KAAAA,EACAkC,SAAAA,EACA9B,gBAAAA,EACAqE,SAAAA,EACAsL,aAAS9N,OAyBnB,SAAS4N,EAAWzO,OACL6O,EAAQ7O,EAArB,aAEA,OAAK6O,EAAS/N,SAIP,CACL4N,YAAaG,EAAQF,iBACb7Q,GAON,MAAO,CACL4Q,YAAWjO,KAAOoO,GAAUF,QAAS7Q,OAblC,CAAE4Q,YAAaG,IC9J5B,SAASC,EAAuCC,GAY9C,IAAMC,EAAmC,GAYzC,OAVAD,EAAWtQ,SAAQ,SAACyO,GACDA,EAmCY8B,WAlC3B9B,EAAK8B,WAAWvQ,SAAQ,SAACC,GACvBsQ,EAAWtQ,IAAQ,KAGrBsQ,EAAW9B,EAAKxO,OAAQ,KAIrB,CACLgQ,YAAa,CACXtQ,KAAM,aACNyJ,MAAO,MAETmH,WAAYzQ,OAAOC,KAAKwQ,GACxBC,aAAIxJ,GAQF,OAAmB,IAAfA,EAAM/G,QAIDsQ,EAAWvJ,EAAM/G,qCAsC9BwQ,GAEA,OAAOA,aAAenR,MAClB+Q,EAAsBI,IAvBpBC,EAAOC,EAwBiBF,GAtBxBG,EAAOP,EACXvQ,OAAO+Q,OAAOH,EAAKvG,SAGrBuG,EAAK7F,gBAEE+F,OARDF,EAEAE,uDFnDQE,+BAAexH,MAAWhK,MAAAwM,GAAAC,IAAAA,EAAAD,EAAAC,IAAXzC,EAAWyC,GAAAC,UAAAD,GAGxC,IAAMgF,EAAS5E,EAAU7C,GAEnB/B,EAA6B,CACjC0I,YAAa,CACXtQ,KAAM,WACNkC,OAAQkP,EAAOlP,OACfgC,KAAMkN,EAAOlN,MAEfmN,6CAAU1H,MAAWhK,MAAA2R,GAAAC,IAAAA,EAAAD,EAAAC,IAAX5H,EAAW4H,GAAAlF,UAAAkF,GAGnB,IAAAhF,EAAyBC,EAAU7C,GAA3BzH,EAAMqK,EAANrK,OAAQgC,EAAIqI,EAAJrI,KAEVsN,EAAmBrR,OAAOC,KAAKgR,EAAOlP,QACtCuP,EAAsBtR,OAAOC,KAAK8B,GAcxC,OAZ4BsP,EAAiB7I,QAC3C,SAACrI,GAAI,OAAKmR,EAAoBhJ,QAAQnI,IAAS,KAW1C6Q,EAAW9O,KAEXH,EACAkP,EAAOlP,SAEZ,SAACwP,SACOC,EAAkBlS,EACtB2R,EAAOlN,KAAKyE,EAAO6I,KAEfI,EAAiBnS,EAAQyE,EAAKyE,EAAO8I,KAE3C,OAAQ7P,MAAgBiQ,OAAMC,MAAAlQ,EACzB+P,EAAgBvP,KAAI,SAAC2P,GAAU,OAChCH,EAAexP,KAAI,SAAC4P,GAClB,MAAmB,MAAfD,EACKC,EAGFD,GAA4B,MAAdC,EAAoB,GAAKA,UAKpD,SAASrJ,EAAOsJ,GACd,IAAMC,EAAoC,GAM1C,OAJAD,EAAY5R,SAAQ,SAACgJ,GACnB6I,EAAU7I,GAAQqI,EAA6BrI,MAG1C6I,QAOjB,OAAOtK"}
\ No newline at end of file
diff --git a/node_modules/type-route/core/type-route.esm.js b/node_modules/type-route/core/type-route.esm.js
index 2f56c86..e0a3ffe 100644
--- a/node_modules/type-route/core/type-route.esm.js
+++ b/node_modules/type-route/core/type-route.esm.js
@@ -220,12 +220,6 @@ var TypeRouteError = /*#__PURE__*/buildErrorCollection({
       return ["The following characters are invalid: " + invalidCharacters.join(", ") + "."];
     }
   },
-  App_should_be_wrapped_in_a_RouteProvider_component: {
-    errorCode: 1020,
-    getDetails: function getDetails() {
-      return ["Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook."];
-    }
-  },
   Invalid_React_version: {
     errorCode: 1021,
     getDetails: function getDetails(version) {
@@ -1197,8 +1191,8 @@ function createNavigationHandlerManager(_ref) {
   }
 }
 
-function attemptScrollToTop(route, scrollToTop) {
-  if (route.action === "push" && typeof window === "object" && window !== null && typeof window.scroll === "function" && scrollToTop !== false && typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string" && !(navigator.userAgent.indexOf("Node.js") > 0 || navigator.userAgent.indexOf("jsdom") > 0)) {
+function attemptScrollToTop(route) {
+  if (route.action === "push" && typeof window === "object" && window !== null && typeof window.scroll === "function" && typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string" && !(navigator.userAgent.indexOf("Node.js") > 0 || navigator.userAgent.indexOf("jsdom") > 0)) {
     try {
       window.scroll(0, 0);
     } catch (_unused) {}
@@ -1267,95 +1261,113 @@ function createRouter() {
   var blockerCollection = [];
   applySessionOpts(opts.session);
   var routes = createRouteBuilderCollection(getRouterContext);
-  var router = {
-    routes: routes,
-    session: {
-      push: function push(href, state) {
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].push", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
-        }
-        var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),
-          route = _getRouteByHref.route,
-          primaryPath = _getRouteByHref.primaryPath;
-        return navigate(_extends({}, route, {
-          action: "push"
-        }), primaryPath);
-      },
-      replace: function replace(href, state) {
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].replace", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
-        }
-        var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),
-          route = _getRouteByHref2.route,
-          primaryPath = _getRouteByHref2.primaryPath;
-        return navigate(_extends({}, route, {
-          action: "replace"
-        }), primaryPath);
-      },
-      back: function back(amount) {
-        if (amount === void 0) {
-          amount = 1;
-        }
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].back", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
-        }
-        history.go(-amount);
-      },
-      forward: function forward(amount) {
-        if (amount === void 0) {
-          amount = 1;
-        }
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].forward", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
-        }
-        history.go(amount);
-      },
-      getInitialRoute: function getInitialRoute() {
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].getInitialRoute", [assert.numArgs([].slice.call(arguments), 0)]);
-        }
-        if (!initialRoute) {
-          var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());
-          if (!result.primaryPath) {
-            skipHandlingNextApplicationTriggeredNavigation = true;
-            result.route.replace();
-            result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());
-          }
-          initialRoute = result.route;
-        }
-        return initialRoute;
-      },
-      reset: function reset(session) {
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].reset", [assert.numArgs([].slice.call(arguments), 1), assert.type("object", "session", session)]);
+  var session = {
+    push: function push(href, state) {
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].push", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
+      }
+      var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),
+        route = _getRouteByHref.route,
+        primaryPath = _getRouteByHref.primaryPath;
+      return navigate(_extends({}, route, {
+        action: "push"
+      }), primaryPath);
+    },
+    replace: function replace(href, state) {
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].replace", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
+      }
+      var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),
+        route = _getRouteByHref2.route,
+        primaryPath = _getRouteByHref2.primaryPath;
+      return navigate(_extends({}, route, {
+        action: "replace"
+      }), primaryPath);
+    },
+    back: function back(amount) {
+      if (amount === void 0) {
+        amount = 1;
+      }
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].back", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
+      }
+      history.go(-amount);
+    },
+    forward: function forward(amount) {
+      if (amount === void 0) {
+        amount = 1;
+      }
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].forward", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
+      }
+      history.go(amount);
+    },
+    getInitialRoute: function getInitialRoute() {
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].getInitialRoute", [assert.numArgs([].slice.call(arguments), 0)]);
+      }
+      if (!initialRoute) {
+        var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());
+        if (!result.primaryPath) {
+          skipHandlingNextApplicationTriggeredNavigation = true;
+          result.route.replace();
+          result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());
         }
-        return applySessionOpts(session);
-      },
-      block: function block(blocker) {
-        blockerCollection.push(blocker);
-        var unblock = history.block(function (update) {
-          var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),
-            route = _getMatchingRoute2.route;
-          var action = update.action.toLowerCase();
-          blocker({
-            route: _extends({}, route, {
-              action: action
-            }),
-            retry: update.retry
-          });
-        });
-        return function () {
-          blockerCollection.splice(blockerCollection.findIndex(function (item) {
-            return item === blocker;
-          }), 1);
-          unblock();
-        };
-      },
-      listen: function listen(handler) {
-        return navigationHandlerManager.add(handler);
+        initialRoute = result.route;
       }
+      return initialRoute;
+    },
+    reset: function reset(session) {
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].reset", [assert.numArgs([].slice.call(arguments), 1), assert.type("object", "session", session)]);
+      }
+      return applySessionOpts(session);
+    },
+    block: function block(blocker) {
+      blockerCollection.push(blocker);
+      var unblock = history.block(function (update) {
+        var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),
+          route = _getMatchingRoute2.route;
+        var action = update.action.toLowerCase();
+        blocker({
+          route: _extends({}, route, {
+            action: action
+          }),
+          retry: update.retry
+        });
+      });
+      return function () {
+        blockerCollection.splice(blockerCollection.findIndex(function (item) {
+          return item === blocker;
+        }), 1);
+        unblock();
+      };
+    },
+    listen: function listen(handler) {
+      return navigationHandlerManager.add(handler);
     }
   };
+  var _ref = function () {
+      var route_current = session.getInitialRoute();
+      session.listen(function (route) {
+        return route_current = route;
+      });
+      function getRoute() {
+        return route_current;
+      }
+      return {
+        getRoute: getRoute
+      };
+    }(),
+    getRoute = _ref.getRoute;
+  var router = {
+    routes: routes,
+    session: session,
+    stopListening: function stopListening() {
+      return unlisten == null ? void 0 : unlisten();
+    },
+    getRoute: getRoute
+  };
   return router;
   function applySessionOpts(sessionOpts) {
     if (sessionOpts === void 0) {
@@ -1422,7 +1434,9 @@ function createRouter() {
       var handler = _step.value;
       handler(route);
     }
-    attemptScrollToTop(route, opts.scrollToTop);
+    if (opts.scrollToTop === true) {
+      attemptScrollToTop(route);
+    }
     previousRoute = route;
   }
   function getRouterContext() {
@@ -1698,7 +1712,7 @@ function getParamDefKindSection(kind, trailing) {
   }
 }
 
-function createGroup(groupItems) {
+function createGroup_fromItems(groupItems) {
   if (process.env.NODE_ENV !== "production") {
     assert("createGroup", [assert.numArgs([].slice.call(arguments), 1), assert.arrayOfType(["RouteGroup", "RouteBuilder"], "groupItems", groupItems)]);
   }
@@ -1732,6 +1746,15 @@ function createGroup(groupItems) {
 function isRouteGroup(value) {
   return !!value.routeNames;
 }
+function createGroup_fromRouteDefs(routeDefs) {
+  var core = createRouter(routeDefs);
+  var group = createGroup_fromItems(Object.values(core.routes));
+  core.stopListening();
+  return group;
+}
+function createGroup(arg) {
+  return arg instanceof Array ? createGroup_fromItems(arg) : createGroup_fromRouteDefs(arg);
+}
 
 export { createGroup, createRouter, defineRoute, noMatch, param, preventDefaultLinkClickBehavior };
 //# sourceMappingURL=type-route.esm.js.map
diff --git a/node_modules/type-route/core/type-route.esm.js.map b/node_modules/type-route/core/type-route.esm.js.map
index ce6bd29..bc13e92 100644
--- a/node_modules/type-route/core/type-route.esm.js.map
+++ b/node_modules/type-route/core/type-route.esm.js.map
@@ -1 +1 @@
-{"version":3,"file":"type-route.esm.js","sources":["../src/typeOf.ts","../src/TypeRouteError.ts","../src/asArray.ts","../src/assert.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/getStateMatch.ts","../src/getQueryMatch.ts","../src/createMatcher.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  App_should_be_wrapped_in_a_RouteProvider_component: {\n    errorCode: 1020,\n    getDetails() {\n      return [\n        \"Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook.\",\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session: {\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n    },\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n"],"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","App_should_be_wrapped_in_a_RouteProvider_component","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","process","env","NODE_ENV","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","_loop","_paramDef$Internal$v","paramValue","undefined","urlEncodeDefault","urlEncode","valueSerializer","getValue","valueSerializerId","id","_ret","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","router","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","_opts$arrayFormat3","_getRouterContext","defineRoute","assertDefineRouteOrExtendArgs","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup","groupItems","routeNames","isRouteGroup","has"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"type-route.esm.js","sources":["../src/typeOf.ts","../src/TypeRouteError.ts","../src/asArray.ts","../src/assert.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/getStateMatch.ts","../src/getQueryMatch.ts","../src/createMatcher.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const session: UmbrellaCoreRouter[\"session\"] = {\n\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n\n  };\n\n  const { getRoute } = (() => {\n    let route_current = session.getInitialRoute();\n\n    session.listen(route => (route_current = route));\n\n    function getRoute() {\n        return route_current;\n    }\n\n    return { getRoute };\n  })();\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session,\n    stopListening: ()=> unlisten?.(),\n    getRoute\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    if( opts.scrollToTop === true){\n      attemptScrollToTop(route);\n    }\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder, CoreRouter } from \"./types\";\nimport { assert } from \"./assert\";\nimport { createRouter as coreCreateRouter } from \"./createRouter\";\n\nfunction createGroup_fromItems<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n\nexport function createGroup_fromRouteDefs<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n> {\n  const core = coreCreateRouter(routeDefs);\n\n  const group= createGroup_fromItems(\n    Object.values(core.routes)\n  );\n\n  core.stopListening();\n\n  return group;\n}\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;\nexport function createGroup<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n>;\nexport function createGroup(\n  arg: any[] | Record<string, unknown>\n): RouteGroup<any> {\n  return arg instanceof Array\n    ? createGroup_fromItems(arg)\n    : createGroup_fromRouteDefs(arg);\n}\n\n\n"],"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","process","env","NODE_ENV","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","_loop","_paramDef$Internal$v","paramValue","undefined","urlEncodeDefault","urlEncode","valueSerializer","getValue","valueSerializerId","id","_ret","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","route_current","getRoute","router","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","scrollToTop","_opts$arrayFormat3","_getRouterContext","defineRoute","assertDefineRouteOrExtendArgs","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup_fromItems","groupItems","routeNames","isRouteGroup","has","createGroup_fromRouteDefs","core","coreCreateRouter","group","values","createGroup","arg"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/type-route/dist/index.d.ts b/node_modules/type-route/dist/index.d.ts
index 75b6f96..6731455 100644
--- a/node_modules/type-route/dist/index.d.ts
+++ b/node_modules/type-route/dist/index.d.ts
@@ -1,3 +1,5 @@
+import { History } from 'history';
+
 declare const noMatch: {
     readonly __noMatch: true;
 };
@@ -11,6 +13,14 @@ declare type KeysMatching<TObject, TCondition> = {
 declare type KeysDiffering<TObject, TCondition> = {
     [TKey in keyof TObject]: TObject[TKey] extends TCondition ? never : TKey;
 }[keyof TObject];
+declare type ErrorDef = {
+    errorCode: number;
+    getDetails: (...args: any[]) => string[];
+};
+declare type BuildPathDefErrorContext = {
+    routeName: string;
+    rawPath: string;
+};
 /**
  * Object for configuring a custom query string serializer. You likely
  * do not need this level of customization for your application.
@@ -40,6 +50,7 @@ declare type QueryStringSerializer = {
         value: string | null;
     }>) => string;
 };
+declare type ParamDefKind = "path" | "query" | "state";
 /**
  * Object for configuring a custom parameter value serializer.
  *
@@ -62,6 +73,20 @@ declare type ParamDef<TParamDefKind, TValue = unknown> = {
         trailing?: boolean;
     };
 };
+declare type UmbrellaParamDef = ParamDef<ParamDefKind>;
+declare type RouterContext = {
+    queryStringSerializer: QueryStringSerializer;
+    navigate: NavigateFunction;
+    arraySeparator: string;
+    history: History;
+    routeDefs: UmbrellaRouteDefCollection;
+    getRoutes: () => Record<string, UmbrellaRouteBuilder>;
+    baseUrl: string;
+};
+declare type ParamDefCollection<TParamDefKind> = {
+    [parameterName: string]: ParamDef<TParamDefKind>;
+};
+declare type UmbrellaParamDefCollection = ParamDefCollection<ParamDefKind>;
 declare type PathParamDef<TValue = unknown> = ParamDef<"path", TValue>;
 declare type NamedPathParamDef<TValue = unknown> = PathParamDef<TValue> & {
     paramName: string;
@@ -78,6 +103,10 @@ declare type PathSegmentDef = {
     namedParamDef: NamedPathParamDef | null;
 };
 declare type PathDef = PathSegmentDef[];
+declare type ParamIdCollection = {
+    [paramName: string]: string;
+};
+declare type GetRawPath = (paramIdCollection: ParamIdCollection) => string | string[];
 declare type PathParamNames<TParamDefCollection> = KeysMatching<TParamDefCollection, {
     ["~internal"]: {
         kind: "path";
@@ -139,6 +168,8 @@ declare type RouteDef<TParamDefCollection> = {
      */
     extend(path: string | string[]): RouteDef<TParamDefCollection>;
 };
+declare type UmbrellaRouteDef = RouteDef<UmbrellaParamDefCollection>;
+declare type NavigateFunction = (route: UmbrellaRoute, primaryPath: boolean) => void;
 declare type OnClickHandler = (event?: any) => void;
 declare type Link = {
     href: string;
@@ -166,6 +197,19 @@ declare type RouteBuilder<TRouteName, TParamDefCollection> = RouteParamsFunction
         Route: Route<TRouteName, TParamDefCollection>;
     };
 };
+declare type UmbrellaRouteBuilder = RouteBuilder<string, UmbrellaParamDefCollection>;
+declare type ClickEvent = {
+    preventDefault?: () => void;
+    button?: number | null;
+    defaultPrevented?: boolean | null;
+    metaKey?: boolean | null;
+    altKey?: boolean | null;
+    ctrlKey?: boolean | null;
+    shiftKey?: boolean | null;
+    target?: {
+        target?: string | null;
+    } | null;
+};
 declare type Action = "push" | "replace" | "pop";
 declare type RouteDefCollectionRoute<TRouteDefCollection> = TRouteDefCollection extends Record<string, RouteDef<any>> ? {
     [TRouteName in keyof TRouteDefCollection]: Route<TRouteName, TRouteDefCollection[TRouteName]["~internal"]["params"]>;
@@ -227,7 +271,9 @@ declare type GetRoute<T> = T extends {
         Route: any;
     };
 }> ? T[keyof T]["~internal"]["Route"] | NotFoundRoute : never;
+declare type UmbrellaRoute = Route<string | false, Record<string, any>>;
 declare type NavigationHandler<TRouteDefCollection> = (route: RouteDefCollectionRoute<TRouteDefCollection>) => void;
+declare type UmbrellaNavigationHandler = NavigationHandler<UmbrellaRouteDefCollection>;
 declare type Unblock = () => void;
 declare type Blocker<TRouteDefCollection> = (update: {
     /**
@@ -241,6 +287,7 @@ declare type Blocker<TRouteDefCollection> = (update: {
      */
     retry: () => void;
 }) => void;
+declare type UmbrellaBlocker = Blocker<UmbrellaRouteDefCollection>;
 /**
  * Functions for interacting with the current history session.
  */
@@ -285,6 +332,7 @@ declare type RouterSession<TRouteDefCollection> = {
      */
     listen(handler: NavigationHandler<TRouteDefCollection>): Unlisten;
 };
+declare type UmbrellaRouterSession = RouterSession<UmbrellaRouteDefCollection>;
 declare type MemoryHistorySessionOpts = {
     type: "memory";
     /**
@@ -362,6 +410,7 @@ declare type RouterOpts = {
 declare type Unlisten = {
     (): void;
 };
+declare type UmbrellaRouteDefCollection = Record<string, UmbrellaRouteDef>;
 declare type CoreRouter<TRouteDefCollection extends {
     [routeName: string]: any;
 }> = {
@@ -372,7 +421,10 @@ declare type CoreRouter<TRouteDefCollection extends {
         [TRouteName in keyof TRouteDefCollection]: RouteBuilder<TRouteName, TRouteDefCollection[TRouteName]["~internal"]["params"]>;
     };
     session: RouterSession<TRouteDefCollection>;
+    stopListening: () => void;
+    getRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;
 };
+declare type UmbrellaCoreRouter = CoreRouter<UmbrellaRouteDefCollection>;
 declare type RouteGroup<T extends any[] = any[]> = {
     ["~internal"]: {
         type: "RouteGroup";
@@ -388,6 +440,137 @@ declare type RouteGroup<T extends any[] = any[]> = {
     has(route: Route<any, any>): route is T[number]["~internal"]["Route"];
 };
 
+type types_d_Compute<A extends any> = Compute<A>;
+type types_d_KeysMatching<TObject, TCondition> = KeysMatching<TObject, TCondition>;
+type types_d_KeysDiffering<TObject, TCondition> = KeysDiffering<TObject, TCondition>;
+type types_d_ErrorDef = ErrorDef;
+type types_d_BuildPathDefErrorContext = BuildPathDefErrorContext;
+type types_d_QueryStringSerializer = QueryStringSerializer;
+type types_d_ParamDefKind = ParamDefKind;
+type types_d_ValueSerializer<TValue = unknown> = ValueSerializer<TValue>;
+type types_d_ParamDef<TParamDefKind, TValue = unknown> = ParamDef<TParamDefKind, TValue>;
+type types_d_UmbrellaParamDef = UmbrellaParamDef;
+type types_d_RouterContext = RouterContext;
+type types_d_ParamDefCollection<TParamDefKind> = ParamDefCollection<TParamDefKind>;
+type types_d_UmbrellaParamDefCollection = UmbrellaParamDefCollection;
+type types_d_PathParamDef<TValue = unknown> = PathParamDef<TValue>;
+type types_d_NamedPathParamDef<TValue = unknown> = NamedPathParamDef<TValue>;
+type types_d_RouterLocation = RouterLocation;
+type types_d_PathSegmentDef = PathSegmentDef;
+type types_d_PathDef = PathDef;
+type types_d_ParamIdCollection = ParamIdCollection;
+type types_d_GetRawPath = GetRawPath;
+type types_d_PathParamNames<TParamDefCollection> = PathParamNames<TParamDefCollection>;
+type types_d_ParamValue<TParamDef> = ParamValue<TParamDef>;
+type types_d_PathParams<TParamDefCollection> = PathParams<TParamDefCollection>;
+type types_d_PathFn<TParamDefCollection> = PathFn<TParamDefCollection>;
+type types_d_RouteDef<TParamDefCollection> = RouteDef<TParamDefCollection>;
+type types_d_UmbrellaRouteDef = UmbrellaRouteDef;
+type types_d_NavigateFunction = NavigateFunction;
+type types_d_OnClickHandler = OnClickHandler;
+type types_d_Link = Link;
+type types_d_Match = Match;
+type types_d_RouteBuilder<TRouteName, TParamDefCollection> = RouteBuilder<TRouteName, TParamDefCollection>;
+type types_d_UmbrellaRouteBuilder = UmbrellaRouteBuilder;
+type types_d_ClickEvent = ClickEvent;
+type types_d_Action = Action;
+type types_d_RouteDefCollectionRoute<TRouteDefCollection> = RouteDefCollectionRoute<TRouteDefCollection>;
+type types_d_NotFoundRoute = NotFoundRoute;
+type types_d_Route<TName, TParamDefCollection> = Route<TName, TParamDefCollection>;
+type types_d_GetRoute<T> = GetRoute<T>;
+type types_d_UmbrellaRoute = UmbrellaRoute;
+type types_d_NavigationHandler<TRouteDefCollection> = NavigationHandler<TRouteDefCollection>;
+type types_d_UmbrellaNavigationHandler = UmbrellaNavigationHandler;
+type types_d_Blocker<TRouteDefCollection> = Blocker<TRouteDefCollection>;
+type types_d_UmbrellaBlocker = UmbrellaBlocker;
+type types_d_RouterSession<TRouteDefCollection> = RouterSession<TRouteDefCollection>;
+type types_d_UmbrellaRouterSession = UmbrellaRouterSession;
+type types_d_MemoryHistorySessionOpts = MemoryHistorySessionOpts;
+type types_d_HashHistorySessionOpts = HashHistorySessionOpts;
+type types_d_BrowserHistorySessionOpts = BrowserHistorySessionOpts;
+type types_d_SessionOpts = SessionOpts;
+type types_d_QueryStringArrayFormat = QueryStringArrayFormat;
+type types_d_ArrayFormat = ArrayFormat;
+type types_d_RouterOpts = RouterOpts;
+type types_d_Unlisten = Unlisten;
+type types_d_UmbrellaRouteDefCollection = UmbrellaRouteDefCollection;
+type types_d_CoreRouter<TRouteDefCollection extends {
+    [routeName: string]: any;
+}> = CoreRouter<TRouteDefCollection>;
+type types_d_UmbrellaCoreRouter = UmbrellaCoreRouter;
+type types_d_RouteGroup<T extends any[] = any[]> = RouteGroup<T>;
+declare namespace types_d {
+  export {
+    types_d_Compute as Compute,
+    types_d_KeysMatching as KeysMatching,
+    types_d_KeysDiffering as KeysDiffering,
+    types_d_ErrorDef as ErrorDef,
+    types_d_BuildPathDefErrorContext as BuildPathDefErrorContext,
+    types_d_QueryStringSerializer as QueryStringSerializer,
+    types_d_ParamDefKind as ParamDefKind,
+    types_d_ValueSerializer as ValueSerializer,
+    types_d_ParamDef as ParamDef,
+    types_d_UmbrellaParamDef as UmbrellaParamDef,
+    types_d_RouterContext as RouterContext,
+    types_d_ParamDefCollection as ParamDefCollection,
+    types_d_UmbrellaParamDefCollection as UmbrellaParamDefCollection,
+    types_d_PathParamDef as PathParamDef,
+    types_d_NamedPathParamDef as NamedPathParamDef,
+    types_d_RouterLocation as RouterLocation,
+    types_d_PathSegmentDef as PathSegmentDef,
+    types_d_PathDef as PathDef,
+    types_d_ParamIdCollection as ParamIdCollection,
+    types_d_GetRawPath as GetRawPath,
+    types_d_PathParamNames as PathParamNames,
+    types_d_ParamValue as ParamValue,
+    types_d_PathParams as PathParams,
+    types_d_PathFn as PathFn,
+    types_d_RouteDef as RouteDef,
+    types_d_UmbrellaRouteDef as UmbrellaRouteDef,
+    types_d_NavigateFunction as NavigateFunction,
+    types_d_OnClickHandler as OnClickHandler,
+    types_d_Link as Link,
+    types_d_Match as Match,
+    types_d_RouteBuilder as RouteBuilder,
+    types_d_UmbrellaRouteBuilder as UmbrellaRouteBuilder,
+    types_d_ClickEvent as ClickEvent,
+    types_d_Action as Action,
+    types_d_RouteDefCollectionRoute as RouteDefCollectionRoute,
+    types_d_NotFoundRoute as NotFoundRoute,
+    types_d_Route as Route,
+    types_d_GetRoute as GetRoute,
+    types_d_UmbrellaRoute as UmbrellaRoute,
+    types_d_NavigationHandler as NavigationHandler,
+    types_d_UmbrellaNavigationHandler as UmbrellaNavigationHandler,
+    types_d_Blocker as Blocker,
+    types_d_UmbrellaBlocker as UmbrellaBlocker,
+    types_d_RouterSession as RouterSession,
+    types_d_UmbrellaRouterSession as UmbrellaRouterSession,
+    types_d_MemoryHistorySessionOpts as MemoryHistorySessionOpts,
+    types_d_HashHistorySessionOpts as HashHistorySessionOpts,
+    types_d_BrowserHistorySessionOpts as BrowserHistorySessionOpts,
+    types_d_SessionOpts as SessionOpts,
+    types_d_QueryStringArrayFormat as QueryStringArrayFormat,
+    types_d_ArrayFormat as ArrayFormat,
+    types_d_RouterOpts as RouterOpts,
+    types_d_Unlisten as Unlisten,
+    types_d_UmbrellaRouteDefCollection as UmbrellaRouteDefCollection,
+    types_d_CoreRouter as CoreRouter,
+    types_d_UmbrellaCoreRouter as UmbrellaCoreRouter,
+    types_d_RouteGroup as RouteGroup,
+  };
+}
+
+declare function createRouter$1<TRouteDefCollection extends {
+    [routeName: string]: any;
+}>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;
+declare function createRouter$1<TRouteDefCollection extends {
+    [routeName: string]: any;
+}>(opts: RouterOpts, routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;
+
+/** @see <https://docs.tsafe.dev/uniontointersection> **/
+declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
+
 declare function defineRoute<TParamDefCollection>(params: TParamDefCollection, path: PathFn<TParamDefCollection>): RouteDef<TParamDefCollection>;
 declare function defineRoute(path: string | string[]): RouteDef<{}>;
 
@@ -1483,26 +1666,32 @@ declare const param: {
 };
 
 declare function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;
+declare function createGroup<TRouteDefCollection extends {
+    [routeName: string]: any;
+}>(routeDefs: TRouteDefCollection): RouteGroup<CoreRouter<TRouteDefCollection>["routes"][keyof TRouteDefCollection][]>;
 
 declare function preventDefaultLinkClickBehavior(event?: any): boolean;
 
 declare type Router<TRouteDefCollection extends {
     [routeName: string]: any;
-}> = CoreRouter<TRouteDefCollection> & {
+}> = Omit<CoreRouter<TRouteDefCollection>, "stopListening"> & {
     /**
      * React hook for retrieving the current route.
      *
      * @see https://type-route.zilch.dev/api-reference/router/use-route
      */
     useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;
-    /**
-     * React component which connects React to Type Route and provides the current route to the rest of the application.
-     *
-     * @see https://type-route.zilch.dev/api-reference/router/route-provider
-     */
-    RouteProvider: (props: {
-        children?: any;
-    }) => any;
+};
+declare function mergeRouteDefs<TPageCollection extends {
+    [pageName: string]: {
+        routeDefs: {
+            [routeName: string]: any;
+        };
+    };
+}>(params: {
+    pages: TPageCollection;
+}): {
+    routeDefs: UnionToIntersection<TPageCollection[keyof TPageCollection]["routeDefs"]>;
 };
 declare function createRouter<TRouteDefCollection extends {
     [routeName: string]: any;
@@ -1511,4 +1700,4 @@ declare function createRouter<TRouteDefCollection extends {
     [routeName: string]: any;
 }>(opts: RouterOpts, routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;
 
-export { Link, QueryStringSerializer, GetRoute as Route, RouterOpts, SessionOpts, ValueSerializer, createGroup, createRouter, defineRoute, noMatch, param, preventDefaultLinkClickBehavior };
+export { Link, QueryStringSerializer, GetRoute as Route, RouterOpts, SessionOpts, ValueSerializer, createRouter$1 as coreCreateRouter, createGroup, createRouter, defineRoute, mergeRouteDefs, noMatch, param, preventDefaultLinkClickBehavior, types_d as types };
diff --git a/node_modules/type-route/dist/tools/UnionToIntersection.d.ts b/node_modules/type-route/dist/tools/UnionToIntersection.d.ts
new file mode 100644
index 0000000..4dd6bdc
--- /dev/null
+++ b/node_modules/type-route/dist/tools/UnionToIntersection.d.ts
@@ -0,0 +1,2 @@
+/** @see <https://docs.tsafe.dev/uniontointersection> **/
+export declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
diff --git a/node_modules/type-route/dist/type-route.cjs.development.js b/node_modules/type-route/dist/type-route.cjs.development.js
index c3294b6..2e883ed 100644
--- a/node_modules/type-route/dist/type-route.cjs.development.js
+++ b/node_modules/type-route/dist/type-route.cjs.development.js
@@ -225,12 +225,6 @@ var TypeRouteError = /*#__PURE__*/buildErrorCollection({
       return ["The following characters are invalid: " + invalidCharacters.join(", ") + "."];
     }
   },
-  App_should_be_wrapped_in_a_RouteProvider_component: {
-    errorCode: 1020,
-    getDetails: function getDetails() {
-      return ["Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook."];
-    }
-  },
   Invalid_React_version: {
     errorCode: 1021,
     getDetails: function getDetails(version) {
@@ -1202,8 +1196,8 @@ function createNavigationHandlerManager(_ref) {
   }
 }
 
-function attemptScrollToTop(route, scrollToTop) {
-  if (route.action === "push" && typeof window === "object" && window !== null && typeof window.scroll === "function" && scrollToTop !== false && typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string" && !(navigator.userAgent.indexOf("Node.js") > 0 || navigator.userAgent.indexOf("jsdom") > 0)) {
+function attemptScrollToTop(route) {
+  if (route.action === "push" && typeof window === "object" && window !== null && typeof window.scroll === "function" && typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string" && !(navigator.userAgent.indexOf("Node.js") > 0 || navigator.userAgent.indexOf("jsdom") > 0)) {
     try {
       window.scroll(0, 0);
     } catch (_unused) {}
@@ -1272,95 +1266,113 @@ function createRouter() {
   var blockerCollection = [];
   applySessionOpts(opts.session);
   var routes = createRouteBuilderCollection(getRouterContext);
-  var router = {
-    routes: routes,
-    session: {
-      push: function push(href, state) {
-        {
-          assert("[RouterSessionHistory].push", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
-        }
-        var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),
-          route = _getRouteByHref.route,
-          primaryPath = _getRouteByHref.primaryPath;
-        return navigate(_extends({}, route, {
-          action: "push"
-        }), primaryPath);
-      },
-      replace: function replace(href, state) {
-        {
-          assert("[RouterSessionHistory].replace", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
-        }
-        var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),
-          route = _getRouteByHref2.route,
-          primaryPath = _getRouteByHref2.primaryPath;
-        return navigate(_extends({}, route, {
-          action: "replace"
-        }), primaryPath);
-      },
-      back: function back(amount) {
-        if (amount === void 0) {
-          amount = 1;
-        }
-        {
-          assert("[RouterSessionHistory].back", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
-        }
-        history$1.go(-amount);
-      },
-      forward: function forward(amount) {
-        if (amount === void 0) {
-          amount = 1;
-        }
-        {
-          assert("[RouterSessionHistory].forward", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
-        }
-        history$1.go(amount);
-      },
-      getInitialRoute: function getInitialRoute() {
-        {
-          assert("[RouterSessionHistory].getInitialRoute", [assert.numArgs([].slice.call(arguments), 0)]);
-        }
-        if (!initialRoute) {
-          var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history$1.location, baseUrl), getRouterContext());
-          if (!result.primaryPath) {
-            skipHandlingNextApplicationTriggeredNavigation = true;
-            result.route.replace();
-            result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history$1.location, baseUrl), getRouterContext());
-          }
-          initialRoute = result.route;
-        }
-        return initialRoute;
-      },
-      reset: function reset(session) {
-        {
-          assert("[RouterSessionHistory].reset", [assert.numArgs([].slice.call(arguments), 1), assert.type("object", "session", session)]);
+  var session = {
+    push: function push(href, state) {
+      {
+        assert("[RouterSessionHistory].push", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
+      }
+      var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),
+        route = _getRouteByHref.route,
+        primaryPath = _getRouteByHref.primaryPath;
+      return navigate(_extends({}, route, {
+        action: "push"
+      }), primaryPath);
+    },
+    replace: function replace(href, state) {
+      {
+        assert("[RouterSessionHistory].replace", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
+      }
+      var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),
+        route = _getRouteByHref2.route,
+        primaryPath = _getRouteByHref2.primaryPath;
+      return navigate(_extends({}, route, {
+        action: "replace"
+      }), primaryPath);
+    },
+    back: function back(amount) {
+      if (amount === void 0) {
+        amount = 1;
+      }
+      {
+        assert("[RouterSessionHistory].back", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
+      }
+      history$1.go(-amount);
+    },
+    forward: function forward(amount) {
+      if (amount === void 0) {
+        amount = 1;
+      }
+      {
+        assert("[RouterSessionHistory].forward", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
+      }
+      history$1.go(amount);
+    },
+    getInitialRoute: function getInitialRoute() {
+      {
+        assert("[RouterSessionHistory].getInitialRoute", [assert.numArgs([].slice.call(arguments), 0)]);
+      }
+      if (!initialRoute) {
+        var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history$1.location, baseUrl), getRouterContext());
+        if (!result.primaryPath) {
+          skipHandlingNextApplicationTriggeredNavigation = true;
+          result.route.replace();
+          result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history$1.location, baseUrl), getRouterContext());
         }
-        return applySessionOpts(session);
-      },
-      block: function block(blocker) {
-        blockerCollection.push(blocker);
-        var unblock = history$1.block(function (update) {
-          var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),
-            route = _getMatchingRoute2.route;
-          var action = update.action.toLowerCase();
-          blocker({
-            route: _extends({}, route, {
-              action: action
-            }),
-            retry: update.retry
-          });
-        });
-        return function () {
-          blockerCollection.splice(blockerCollection.findIndex(function (item) {
-            return item === blocker;
-          }), 1);
-          unblock();
-        };
-      },
-      listen: function listen(handler) {
-        return navigationHandlerManager.add(handler);
+        initialRoute = result.route;
+      }
+      return initialRoute;
+    },
+    reset: function reset(session) {
+      {
+        assert("[RouterSessionHistory].reset", [assert.numArgs([].slice.call(arguments), 1), assert.type("object", "session", session)]);
       }
+      return applySessionOpts(session);
+    },
+    block: function block(blocker) {
+      blockerCollection.push(blocker);
+      var unblock = history$1.block(function (update) {
+        var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),
+          route = _getMatchingRoute2.route;
+        var action = update.action.toLowerCase();
+        blocker({
+          route: _extends({}, route, {
+            action: action
+          }),
+          retry: update.retry
+        });
+      });
+      return function () {
+        blockerCollection.splice(blockerCollection.findIndex(function (item) {
+          return item === blocker;
+        }), 1);
+        unblock();
+      };
+    },
+    listen: function listen(handler) {
+      return navigationHandlerManager.add(handler);
     }
   };
+  var _ref = function () {
+      var route_current = session.getInitialRoute();
+      session.listen(function (route) {
+        return route_current = route;
+      });
+      function getRoute() {
+        return route_current;
+      }
+      return {
+        getRoute: getRoute
+      };
+    }(),
+    getRoute = _ref.getRoute;
+  var router = {
+    routes: routes,
+    session: session,
+    stopListening: function stopListening() {
+      return unlisten == null ? void 0 : unlisten();
+    },
+    getRoute: getRoute
+  };
   return router;
   function applySessionOpts(sessionOpts) {
     if (sessionOpts === void 0) {
@@ -1427,7 +1439,9 @@ function createRouter() {
       var handler = _step.value;
       handler(route);
     }
-    attemptScrollToTop(route, opts.scrollToTop);
+    if (opts.scrollToTop === true) {
+      attemptScrollToTop(route);
+    }
     previousRoute = route;
   }
   function getRouterContext() {
@@ -1703,7 +1717,7 @@ function getParamDefKindSection(kind, trailing) {
   }
 }
 
-function createGroup(groupItems) {
+function createGroup_fromItems(groupItems) {
   {
     assert("createGroup", [assert.numArgs([].slice.call(arguments), 1), assert.arrayOfType(["RouteGroup", "RouteBuilder"], "groupItems", groupItems)]);
   }
@@ -1737,6 +1751,15 @@ function createGroup(groupItems) {
 function isRouteGroup(value) {
   return !!value.routeNames;
 }
+function createGroup_fromRouteDefs(routeDefs) {
+  var core = createRouter(routeDefs);
+  var group = createGroup_fromItems(Object.values(core.routes));
+  core.stopListening();
+  return group;
+}
+function createGroup(arg) {
+  return arg instanceof Array ? createGroup_fromItems(arg) : createGroup_fromRouteDefs(arg);
+}
 
 {
   var _React$version$split$ = /*#__PURE__*/React.version.split(".").map(function (value) {
@@ -1748,49 +1771,74 @@ function isRouteGroup(value) {
     throw TypeRouteError.Invalid_React_version.create(React.version);
   }
 }
+function mergeRouteDefs(params) {
+  var pages = params.pages;
+  var routeDefs = {};
+  Object.keys(pages).forEach(function (pageName) {
+    return Object.assign(routeDefs, pages[pageName].routeDefs);
+  });
+  // @ts-expect-error
+  return {
+    routeDefs: routeDefs
+  };
+}
+// NOTE: For HMR, we want stable reference.  
+var router = undefined;
 function createRouter$1() {
+  if (router !== undefined) {
+    return router;
+  }
   for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
     args[_key] = arguments[_key];
   }
   var _parseArgs = parseArgs(args),
     opts = _parseArgs.opts,
     routeDefs = _parseArgs.routeDefs;
-  var router = createRouter(_extends({}, opts, {
-    scrollToTop: false
-  }), routeDefs);
-  var routeContext = React.createContext(null);
-  return _extends({}, router, {
-    RouteProvider: RouteProvider,
-    useRoute: useRoute
-  });
-  function RouteProvider(props) {
-    var _React$useState = React.useState(router.session.getInitialRoute()),
-      route = _React$useState[0],
-      setRoute = _React$useState[1];
+  var _coreCreateRouter = createRouter(_extends({}, opts, {
+      scrollToTop: false
+    }), routeDefs),
+    routes = _coreCreateRouter.routes,
+    session = _coreCreateRouter.session,
+    getRoute = _coreCreateRouter.getRoute;
+  var _effect = undefined;
+  if (opts.scrollToTop === true) {
+    session.listen(function (route) {
+      _effect = function effect() {
+        _effect = undefined;
+        attemptScrollToTop(route);
+      };
+    });
+  }
+  function useRoute() {
+    var route = getRoute();
+    var _React$useReducer = React.useReducer(function (count) {
+        return count + 1;
+      }, 0),
+      reRender = _React$useReducer[1];
     React.useLayoutEffect(function () {
-      return router.session.listen(setRoute);
+      return session.listen(function () {
+        return reRender();
+      });
     }, []);
     React.useEffect(function () {
-      attemptScrollToTop(route, opts.scrollToTop);
+      _effect == null ? void 0 : _effect();
     }, [route]);
-    return React.createElement(routeContext.Provider, {
-      value: route
-    }, props.children);
-  }
-  function useRoute() {
-    var route = React.useContext(routeContext);
-    {
-      if (route === null) {
-        throw TypeRouteError.App_should_be_wrapped_in_a_RouteProvider_component.create();
-      }
-    }
     return route;
   }
+  router = {
+    routes: routes,
+    session: session,
+    getRoute: getRoute,
+    useRoute: useRoute
+  };
+  return router;
 }
 
+exports.coreCreateRouter = createRouter;
 exports.createGroup = createGroup;
 exports.createRouter = createRouter$1;
 exports.defineRoute = defineRoute;
+exports.mergeRouteDefs = mergeRouteDefs;
 exports.noMatch = noMatch;
 exports.param = param;
 exports.preventDefaultLinkClickBehavior = preventDefaultLinkClickBehavior;
diff --git a/node_modules/type-route/dist/type-route.cjs.development.js.map b/node_modules/type-route/dist/type-route.cjs.development.js.map
index bbb1b1c..5d62700 100644
--- a/node_modules/type-route/dist/type-route.cjs.development.js.map
+++ b/node_modules/type-route/dist/type-route.cjs.development.js.map
@@ -1 +1 @@
-{"version":3,"file":"type-route.cjs.development.js","sources":["../src/typeOf.ts","../src/TypeRouteError.ts","../src/asArray.ts","../src/assert.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/getStateMatch.ts","../src/getQueryMatch.ts","../src/createMatcher.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts","../src/react.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  App_should_be_wrapped_in_a_RouteProvider_component: {\n    errorCode: 1020,\n    getDetails() {\n      return [\n        \"Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook.\",\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session: {\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n    },\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n","import {\n  CoreRouter,\n  UmbrellaRouteDefCollection,\n  UmbrellaRoute,\n  RouteDefCollectionRoute,\n  RouterOpts,\n} from \"./types\";\nimport { createRouter as coreCreateRouter, parseArgs } from \"./createRouter\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport * as React from \"react\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\n\nif (typeof __DEV__ === \"boolean\" && __DEV__) {\n  const [major, minor] = React.version\n    .split(\".\")\n    .map((value: string) => parseInt(value, 10));\n\n  if (major < 16 || (major === 16 && minor < 8)) {\n    throw TypeRouteError.Invalid_React_version.create(React.version);\n  }\n}\n\nexport { defineRoute } from \"./defineRoute\";\nexport { param } from \"./param\";\nexport { createGroup } from \"./createGroup\";\nexport { noMatch } from \"./noMatch\";\nexport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nexport {\n  GetRoute as Route,\n  Link,\n  ValueSerializer,\n  QueryStringSerializer,\n  SessionOpts,\n  RouterOpts,\n} from \"./types\";\n\ntype Router<TRouteDefCollection extends { [routeName: string]: any }> =\n  CoreRouter<TRouteDefCollection> & {\n    /**\n     * React hook for retrieving the current route.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/use-route\n     */\n    useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;\n\n    /**\n     * React component which connects React to Type Route and provides the current route to the rest of the application.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/route-provider\n     */\n    RouteProvider: (props: { children?: any }) => any;\n  };\ntype UmbrellaRouter = Router<UmbrellaRouteDefCollection>;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): Router<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaRouter {\n  const { opts, routeDefs } = parseArgs(args);\n  const router = coreCreateRouter({ ...opts, scrollToTop: false }, routeDefs);\n  const routeContext = React.createContext<UmbrellaRoute | null>(null);\n\n  return {\n    ...router,\n    RouteProvider,\n    useRoute,\n  };\n\n  function RouteProvider(props: { children?: any }) {\n    const [route, setRoute] = React.useState(router.session.getInitialRoute());\n\n    React.useLayoutEffect(() => router.session.listen(setRoute), []);\n\n    React.useEffect(() => {\n      attemptScrollToTop(route, opts.scrollToTop);\n    }, [route]);\n\n    return React.createElement(\n      routeContext.Provider,\n      { value: route },\n      props.children\n    );\n  }\n\n  function useRoute() {\n    const route = React.useContext(routeContext);\n\n    if (__DEV__) {\n      if (route === null) {\n        throw TypeRouteError.App_should_be_wrapped_in_a_RouteProvider_component.create();\n      }\n    }\n\n    return route!;\n  }\n}\n"],"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","App_should_be_wrapped_in_a_RouteProvider_component","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","_loop","_paramDef$Internal$v","paramValue","undefined","urlEncodeDefault","urlEncode","valueSerializer","getValue","valueSerializerId","id","_ret","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","router","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","_opts$arrayFormat3","_getRouterContext","defineRoute","assertDefineRouteOrExtendArgs","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup","groupItems","routeNames","isRouteGroup","has","_React$version$split$","React","parseInt","major","minor","coreCreateRouter","routeContext","RouteProvider","useRoute","props","_React$useState","setRoute","Provider","children"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"type-route.cjs.development.js","sources":["../src/typeOf.ts","../src/TypeRouteError.ts","../src/asArray.ts","../src/assert.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/getStateMatch.ts","../src/getQueryMatch.ts","../src/createMatcher.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts","../src/react.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const session: UmbrellaCoreRouter[\"session\"] = {\n\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n\n  };\n\n  const { getRoute } = (() => {\n    let route_current = session.getInitialRoute();\n\n    session.listen(route => (route_current = route));\n\n    function getRoute() {\n        return route_current;\n    }\n\n    return { getRoute };\n  })();\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session,\n    stopListening: ()=> unlisten?.(),\n    getRoute\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    if( opts.scrollToTop === true){\n      attemptScrollToTop(route);\n    }\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder, CoreRouter } from \"./types\";\nimport { assert } from \"./assert\";\nimport { createRouter as coreCreateRouter } from \"./createRouter\";\n\nfunction createGroup_fromItems<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n\nexport function createGroup_fromRouteDefs<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n> {\n  const core = coreCreateRouter(routeDefs);\n\n  const group= createGroup_fromItems(\n    Object.values(core.routes)\n  );\n\n  core.stopListening();\n\n  return group;\n}\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;\nexport function createGroup<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n>;\nexport function createGroup(\n  arg: any[] | Record<string, unknown>\n): RouteGroup<any> {\n  return arg instanceof Array\n    ? createGroup_fromItems(arg)\n    : createGroup_fromRouteDefs(arg);\n}\n\n\n","import {\n  CoreRouter,\n  UmbrellaRouteDefCollection,\n  RouteDefCollectionRoute,\n  RouterOpts,\n} from \"./types\";\nimport { createRouter as coreCreateRouter, parseArgs } from \"./createRouter\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport * as React from \"react\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport type { UnionToIntersection } from \"./tools/UnionToIntersection\";\n\nimport * as types from \"./types\";\n\nexport type { types };\nexport { coreCreateRouter };\n\nif (typeof __DEV__ === \"boolean\" && __DEV__) {\n  const [major, minor] = React.version\n    .split(\".\")\n    .map((value: string) => parseInt(value, 10));\n\n  if (major < 16 || (major === 16 && minor < 8)) {\n    throw TypeRouteError.Invalid_React_version.create(React.version);\n  }\n}\n\nexport { defineRoute } from \"./defineRoute\";\nexport { param } from \"./param\";\nexport { createGroup } from \"./createGroup\";\nexport { noMatch } from \"./noMatch\";\nexport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nexport {\n  GetRoute as Route,\n  Link,\n  ValueSerializer,\n  QueryStringSerializer,\n  SessionOpts,\n  RouterOpts,\n} from \"./types\";\n\ntype Router<TRouteDefCollection extends { [routeName: string]: any }> =\n  Omit<CoreRouter<TRouteDefCollection>, \"stopListening\"> & {\n    /**\n     * React hook for retrieving the current route.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/use-route\n     */\n    useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;\n  };\ntype UmbrellaRouter = Router<UmbrellaRouteDefCollection>;\n\nexport function mergeRouteDefs<\n  TPageCollection extends { [pageName: string]: { routeDefs: { [routeName: string]: any } } }\n>(\n  params: { pages: TPageCollection; }\n): { routeDefs: UnionToIntersection<TPageCollection[keyof TPageCollection][\"routeDefs\"]> }{\n\n  const { pages } = params;\n\n  const routeDefs = {};\n\n  Object.keys(pages).forEach((pageName) =>\n    Object.assign(routeDefs, pages[pageName].routeDefs)\n  );\n\n  // @ts-expect-error\n  return { routeDefs };\n}\n\n// NOTE: For HMR, we want stable reference.  \nlet router: UmbrellaRouter | undefined = undefined;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): Router<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaRouter {\n  if (router !== undefined) {\n    return router;\n  }\n\n  const { opts, routeDefs } = parseArgs(args);\n  const { routes, session, getRoute } = coreCreateRouter(\n    { ...opts, scrollToTop: false },\n    routeDefs\n  );\n\n  let effect: (() => void) | undefined = undefined;\n\n  if (opts.scrollToTop === true) {\n    session.listen((route) => {\n      effect = () => {\n        effect = undefined;\n        attemptScrollToTop(route);\n      };\n    });\n  }\n\n  function useRoute() {\n    const route = getRoute();\n\n    const [, reRender] = React.useReducer((count) => count + 1, 0);\n\n    React.useLayoutEffect(() => session.listen(() => reRender()), []);\n\n    React.useEffect(() => {\n      effect?.();\n    }, [route]);\n\n    return route;\n  }\n\n  router = {\n    routes,\n    session,\n    getRoute,\n    useRoute,\n  };\n\n  return router;\n}\n\n"],"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","_loop","_paramDef$Internal$v","paramValue","undefined","urlEncodeDefault","urlEncode","valueSerializer","getValue","valueSerializerId","id","_ret","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","route_current","getRoute","router","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","scrollToTop","_opts$arrayFormat3","_getRouterContext","defineRoute","assertDefineRouteOrExtendArgs","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup_fromItems","groupItems","routeNames","isRouteGroup","has","createGroup_fromRouteDefs","core","coreCreateRouter","group","values","createGroup","arg","_React$version$split$","React","parseInt","major","minor","mergeRouteDefs","pages","pageName","assign","_coreCreateRouter","effect","useRoute","_React$useReducer","count","reRender"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/type-route/dist/type-route.cjs.production.min.js b/node_modules/type-route/dist/type-route.cjs.production.min.js
index 1679dad..dd00228 100644
--- a/node_modules/type-route/dist/type-route.cjs.production.min.js
+++ b/node_modules/type-route/dist/type-route.cjs.production.min.js
@@ -1,2 +1,2 @@
-"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var r=require("history"),e=require("react");function n(){return(n=Object.assign||function(r){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(r[a]=n[a])}return r}).apply(this,arguments)}function a(r,e){(null==e||e>r.length)&&(e=r.length);for(var n=0,a=new Array(e);n<e;n++)a[n]=r[n];return a}function t(r,e){var n="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(n)return(n=n.call(r)).next.bind(n);if(Array.isArray(r)||(n=function(r,e){if(r){if("string"==typeof r)return a(r,void 0);var n=Object.prototype.toString.call(r).slice(8,-1);return"Object"===n&&r.constructor&&(n=r.constructor.name),"Map"===n||"Set"===n?Array.from(r):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?a(r,void 0):void 0}}(r))||e&&r&&"number"==typeof r.length){n&&(r=n);var t=0;return function(){return t>=r.length?{done:!0}:{done:!1,value:r[t++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function i(r){return Array.isArray(r)?r:[r]}function o(r){return"${p."+r+"}"}function u(r,e){var n={};return Object.keys(e).forEach((function(a){var t=e[a];t["~internal"].kind===r&&(n[a]=t)})),n}function l(r,e,n){var a=r["~internal"].valueSerializer.stringify(e);return n?encodeURIComponent(a):a}var f={__noMatch:!0},c=function(r,e){for(var n=0;n<e.length;n++)if(e[n]!==r[n])return!1;return!0},s=function(r,e){for(var n=1;n<=e.length;n++)if(e[e.length-n]!==r[r.length-n])return!1;return!0},p=function(r,e){var n=r.split(e);return[n[0],n.slice(1).join(e)]},v=s,m=c;function d(r){for(var e,a=r.object,i=r.paramDefs,o=r.urlEncodeDefault,u=r.arraySeparator,l={},c=Object.keys(i).map((function(r){return n({name:r},i[r])})),s=n({},a),p=function(){var r=e.value,n=a[r.name];if(delete s[r.name],void 0===n)return r["~internal"].optional?"continue":{v:!1};var t=void 0;if(null===n){if(!r["~internal"].array)return r["~internal"].optional?"continue":{v:!1};t=[]}else if(r["~internal"].array){if((t=n.split(u).map((function(e){var n;return r["~internal"].valueSerializer.parse((null!=(n=r["~internal"].valueSerializer.urlEncode)?n:o)?decodeURIComponent(e):e)}))).some((function(r){return r===f})))return r["~internal"].optional?"continue":{v:!1}}else{var i;if((t=r["~internal"].valueSerializer.parse((null!=(i=r["~internal"].valueSerializer.urlEncode)?i:o)?decodeURIComponent(n):n))===f)return r["~internal"].optional?"continue":{v:!1}}l[r.name]=t},v=t(c);!(e=v()).done;){var m=p();if("continue"!==m&&"object"==typeof m)return m.v}return{params:l,numExtraneousParams:Object.keys(s).length}}function y(r){var e=r.pathDefs,a=r.params,t=u("query",a),i=u("state",a),o={};return Object.keys(a).forEach((function(r){var e=a[r];void 0!==e["~internal"].default&&(o[r]=e["~internal"].default)})),function(r){var a=r.routerLocation,u=r.arraySeparator,l=r.queryStringSerializer;if(void 0===a.path)return!1;var c=function(r){for(var e=r.path,a=r.pathDefs,t=r.arraySeparator,i=0;i<a.length;i++){var o=u(a[i]);if(!1!==o)return n({},o,{primaryPath:0===i})}return!1;function u(r){var n={};if("/"===e&&0===r.length)return{params:n,numExtraneousParams:0};var a=e.length>1&&v(e,"/");a&&(e=e.slice(0,e.length-1));for(var i=e.split("/").slice(1),o=function(e){var o,u,l,c=e>=r.length?null:r[e],s=e>=i.length?null:i[e];if(null===c)return{v:!1};if(null===s)return 0==r.length-1-e&&null!=(l=c.namedParamDef)&&l["~internal"].optional?"break":{v:!1};if(null!=(o=c.namedParamDef)&&o["~internal"].trailing&&(s=i.slice(e).join("/")),!m(s,c.leading))return{v:!1};var p=s.slice(c.leading.length);if(!v(p,c.trailing))return{v:!1};var d=p.slice(0,p.length-c.trailing.length);if(!c.namedParamDef)return""===d?"continue":{v:!1};if(""===d)return c.namedParamDef["~internal"].optional?"continue":{v:!1};var y=null!=(u=c.namedParamDef["~internal"].valueSerializer.urlEncode)?u:!c.namedParamDef["~internal"].trailing,h=void 0;if(c.namedParamDef["~internal"].array){if((h=d.split(t).map((function(r){var e;return null==(e=c.namedParamDef)?void 0:e["~internal"].valueSerializer.parse(y?decodeURIComponent(r):r)}))).some((function(r){return r===f})))return{v:!1}}else if((h=c.namedParamDef["~internal"].valueSerializer.parse(y?decodeURIComponent(d):d))===f)return{v:!1};return c.namedParamDef["~internal"].trailing&&a&&""===c.trailing&&(h+="/"),n[c.namedParamDef.paramName]=h,c.namedParamDef["~internal"].trailing?"break":void 0},u=0;u<Math.max(r.length,i.length);u++){var l=o(u);if("break"===l)break;if("continue"!==l&&"object"==typeof l)return l.v}return{params:n,numExtraneousParams:0}}}({path:a.path,pathDefs:e,arraySeparator:u});if(!1===c)return!1;var s=function(r,e,n,a){var t={};return r&&(t=n.parse(r)),d({object:t,paramDefs:e,urlEncodeDefault:!0,arraySeparator:a})}(a.query,t,l,u);if(!1===s)return!1;var p=function(r,e,n){return d({object:null!=r?r:{},paramDefs:e,urlEncodeDefault:!1,arraySeparator:n})}(a.state,i,u);return!1!==p&&{primaryPath:c.primaryPath,params:n({},o,c.params,s.params,p.params),numExtraneousParams:c.numExtraneousParams+s.numExtraneousParams+p.numExtraneousParams}}}function h(r){return void 0===r&&(r={}),!(r.target&&r.target.target&&"_self"!==r.target.target||r.defaultPrevented||0!==r.button||r.metaKey||r.altKey||r.ctrlKey||r.shiftKey||(r&&r.preventDefault&&r.preventDefault(),0))}var g=c;function S(r){var e=r.routeName,a=r.params,t=r.location,i=r.routerContext,o=i.navigate,u=i.history.createHref({pathname:!1===e?t.fullPath:t.path,search:t.query?"?"+t.query:""});g(u,"#")&&(u="/"+u),!1!==e&&"/"!==i.baseUrl&&(u=i.baseUrl+u);var l={name:e,params:a,href:u,link:{href:u,onClick:function(r){if(h(r))return l.push()}},action:null,push:function(){return o(n({},l,{action:"push"}),!0)},replace:function(){return o(n({},l,{action:"replace"}),!0)}};return l}function b(r,e,a){var f,c,s,p,v=(f=u("path",e["~internal"].params),c=e["~internal"].path,s=Object.keys(f).map((function(r){return n({paramName:r},f[r])})),p={},s.forEach((function(r){var e=r.paramName;p[e]=o(e)})),i(c(p)).map((function(r){if(1===r.length)return[];for(var e,n=r.split("/").slice(1),a={},i=[],u=t(n);!(e=u()).done;){for(var l,f=e.value,c=null,p=t(s);!(l=p()).done;){var v=l.value;f.indexOf(o(v.paramName))>=0&&(c=v,a[v.paramName]=!0)}if(c){var m=f.split(o(c.paramName));i.push({leading:m[0],trailing:m[1],namedParamDef:c})}else i.push({leading:f,trailing:"",namedParamDef:null})}return s.map((function(r){return r.paramName})).filter((function(r){return!a[r]})),i}))),m=function(t){void 0===t&&(t={});var i=a(),o=i.arraySeparator,u=i.queryStringSerializer,f=i.baseUrl,c=n({},t);Object.keys(e["~internal"].params).forEach((function(r){var n=e["~internal"].params[r];void 0===c[r]&&void 0!==n["~internal"].default&&(c[r]=n["~internal"].default)}));var s=function(r){var e=r.paramCollection,a=r.paramDefCollection,t=r.arraySeparator,i=r.queryStringSerializer,o=r.pathDefs,u=r.baseUrl,f={path:{},query:{},state:{}},c=function(r){var n,i=e[r];if(void 0===i)return"continue";var o=a[r],u=null!=(n=o["~internal"].valueSerializer.urlEncode)?n:"state"!==o["~internal"].kind&&!o["~internal"].trailing,c=function(r){return o["~internal"].array?0===r.length?null:r.map((function(r){return l(o,r,u)})).join(t):l(o,r,u)},s=c(i);if("query"===o["~internal"].kind&&void 0!==o["~internal"].default&&c(o["~internal"].default)===s)return"continue";f[o["~internal"].kind][r]={valueSerializerId:o["~internal"].valueSerializer.id,array:o["~internal"].array,value:s}};for(var s in a)c(s);var p="/"+o[0].filter((function(r){var e=r.namedParamDef;return!(null!=e&&e["~internal"].optional&&void 0===f.path[e.paramName])})).map((function(r){var e=r.namedParamDef;return r.leading+(e?f.path[e.paramName].value:"")+r.trailing})).join("/");return{fullPath:("/"===u?"":u)+p,path:p,query:Object.keys(f.query).length>0?i.stringify(f.query):void 0,state:0===Object.keys(f.state).length?void 0:Object.keys(f.state).reduce((function(r,e){var a;return n({},r,((a={})[e]=f.state[e].value,a))}),{})}}({paramCollection:t,paramDefCollection:e["~internal"].params,arraySeparator:o,queryStringSerializer:u,pathDefs:v,baseUrl:f});return S({routeName:r,params:c,location:s,routerContext:i})};return Object.defineProperty(m,"name",{value:r}),m["~internal"]={type:"RouteBuilder",match:y({pathDefs:v,params:e["~internal"].params}),pathDefs:v,Route:null},m}function P(r){var e,n;void 0===r&&(r={});var a=null!=(e=r.queryStringArrayFormat)?e:"singleKeyWithBracket",i=null!=(n=r.arraySeparator)?n:",",o="multiKey"===a||"multiKeyWithBracket"===a,u="multiKey"===a||"singleKey"===a?"":"[]";return{parse:function(r){for(var e,n={},a=t(r.split("&"));!(e=a()).done;){var l=e.value.split("="),f=l[0],c=l[1],p=l.slice(2);if(!(void 0===f||p.length>0)){var v=decodeURIComponent(s(f,u)?f.slice(0,f.length-u.length):f);void 0===c?n[v]=null:n[v]&&o?n[v]+=""+i+c:n[v]=c}}return n},stringify:function(r){return Object.keys(r).map((function(e){var n=encodeURIComponent(e),a=r[e].array?""+n+u:n,t=r[e].value;return null===t?a:r[e].array&&o?t.split(i).map((function(r){return a+"="+r})).join("&"):a+"="+t})).join("&")}}}function D(r,e){var a=e.queryStringSerializer,t=e.arraySeparator,i=(0,e.getRoutes)(),o=!1;for(var u in i){var l=i[u]["~internal"].match({routerLocation:r,queryStringSerializer:a,arraySeparator:t});if(!1!==l){if(0===l.numExtraneousParams)return{route:i[u](l.params),primaryPath:l.primaryPath};(!1===o||l.numExtraneousParams<o.numExtraneousParams)&&(o=n({},l,{routeName:u}))}}return o?{route:i[o.routeName](o.params),primaryPath:o.primaryPath}:{route:S({routeName:!1,params:{},location:r,routerContext:e}),primaryPath:!0}}var j=c;function k(r,e){return{fullPath:r.pathname,path:j(r.pathname,e)?"/"!==e?r.pathname.replace(e,""):r.pathname:void 0,query:r.search?j(r.search,"?")?r.search.slice(1):r.search:void 0,state:"object"==typeof r.state&&null!==r.state?r.state.state:void 0}}var w=p;function x(r,e,n){var a=w(r,"?");return D(k({pathname:a[0],search:a[1],state:e},n.baseUrl),n)}function E(r){var e=r.startListening,n=r.stopListening,a=[],t=0;return{add:function(r){var i=t++;return a.push({id:i,handler:r}),1===a.length&&e(),function(){var r=a.map((function(r){return r.id})).indexOf(i);r>=0&&(a.splice(r,1),0===a.length&&n())}},getHandlers:function(){return a.map((function(r){return r.handler}))}}}function O(r,e){if("push"===r.action&&"object"==typeof window&&null!==window&&"function"==typeof window.scroll&&!1!==e&&"object"==typeof navigator&&null!==navigator&&"string"==typeof navigator.userAgent&&!(navigator.userAgent.indexOf("Node.js")>0||navigator.userAgent.indexOf("jsdom")>0))try{window.scroll(0,0)}catch(r){}}function q(r,e){var n={};if(r.name)for(var a,i=t(Object.keys(r.params).sort());!(a=i()).done;){var o=a.value,u=e[r.name]["~internal"].params[o]["~internal"];"state"===u.kind&&(n[o]=u.valueSerializer.stringify(r.params[o]))}return n}var z=p;function N(){for(var e,a,i,o,u,l=arguments.length,f=new Array(l),c=0;c<l;c++)f[c]=arguments[c];var s,p,v=C(f),m=v.routeDefs,d=v.opts,y=E({startListening:function(){p=s.listen((function(r){if(b)b=!1;else{var e=k(r.location,h),a=r.action.toLowerCase(),t=D(e,H()),i=t.primaryPath;T(n({},t.route,{action:a}),i)}}))},stopListening:function(){return null==p?void 0:p()}}),h=null!=(e=d.baseUrl)?e:"/",g=null!=(a=null==(i=d.arrayFormat)?void 0:i.separator)?a:",",S=null!=(o=d.queryStringSerializer)?o:P({queryStringArrayFormat:null==(u=d.arrayFormat)?void 0:u.queryString,arraySeparator:g}),b=!1,j=!1,w=null,N=null,A=[];L(d.session);var I=R(H),U={routes:I,session:{push:function(r,e){var a=x(r,e,H()),t=a.primaryPath;return K(n({},a.route,{action:"push"}),t)},replace:function(r,e){var a=x(r,e,H()),t=a.primaryPath;return K(n({},a.route,{action:"replace"}),t)},back:function(r){void 0===r&&(r=1),s.go(-r)},forward:function(r){void 0===r&&(r=1),s.go(r)},getInitialRoute:function(){if(!w){var r=D(k(s.location,h),H());r.primaryPath||(j=!0,r.route.replace(),r=D(k(s.location,h),H())),w=r.route}return w},reset:function(r){return L(r)},block:function(r){A.push(r);var e=s.block((function(e){var a=D(k(e.location,h),H()).route,t=e.action.toLowerCase();r({route:n({},a,{action:t}),retry:e.retry})}));return function(){A.splice(A.findIndex((function(e){return e===r})),1),e()}},listen:function(r){return y.add(r)}}};return U;function L(e){void 0===e&&(e={type:"undefined"!=typeof window&&void 0!==window.document?"browser":"memory"}),w=null,s="memory"===e.type?r.createMemoryHistory({initialEntries:e.initialEntries,initialIndex:e.initialIndex}):"hash"===e.type?r.createHashHistory({window:e.window}):r.createBrowserHistory({window:e.window})}function K(r,e){var n;if(A.length>0)A.forEach((function(e){e({route:r,retry:function(){r["push"===r.action?"push":"replace"]()}})}));else{var a=q(r,m);if((null==(n=N)?void 0:n.href)!==r.href||JSON.stringify(q(N,m))!==JSON.stringify(a)){j?j=!1:T(r,e),b=!0;var t=z(r.href,"?"),i=t[1];s["replace"===r.action?"replace":"push"]({pathname:t[0],search:i?"?"+i:"",hash:""},a?{state:a}:void 0)}}}function T(r,e){if(e){for(var n,a=t(y.getHandlers());!(n=a()).done;)(0,n.value)(r);O(r,d.scrollToTop),N=r}else r.replace()}function H(){return{queryStringSerializer:S,arraySeparator:g,navigate:K,history:s,routeDefs:m,getRoutes:function(){return I},baseUrl:h}}}function C(r){return{routeDefs:1===r.length?r[0]:r[1],opts:1===r.length?{}:r[0]}}function R(r){var e={},n=r().routeDefs;for(var a in n)e[a]=b(a,n[a],r);return e}function A(r){return 1===r.length?{params:{},path:function(){return r[0]}}:{params:r[0],path:r[1]}}var I={id:"boolean",parse:function(r){return"true"===r||"false"!==r&&f},stringify:function(r){return r?"true":"false"}},U={id:"number",parse:function(r){return e=r,isNaN(parseFloat(e))||!/^-?\d*\.?\d*$/.test(e)?f:parseFloat(r);var e},stringify:function(r){return r.toString()}},L={id:"string",parse:function(r){return r},stringify:function(r){return r}},K={path:n({},T("path",!1),{trailing:T("path",!0)}),query:T("query",!1),state:T("state",!1)};function T(r,e){return n({},a(!1,!1),{array:a(!1,!0),optional:n({},a(!0,!1),{array:a(!0,!0)})});function a(n,a){return{string:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:n,valueSerializer:L,trailing:e,default:void 0}}),number:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:n,valueSerializer:U,trailing:e,default:void 0}}),boolean:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:n,valueSerializer:I,trailing:e,default:void 0}}),ofType:function(i){return void 0===i&&(i={id:"json",parse:function(r){var e;try{e=JSON.parse(r)}catch(r){return f}return e},stringify:function(r){return JSON.stringify(r)}}),t({"~internal":{type:"ParamDef",array:a,kind:r,optional:n,valueSerializer:i,trailing:e,default:void 0}})}}}function t(r){var e=r["~internal"];return e.optional?{"~internal":e,default:function(r){return{"~internal":n({},e,{default:r})}}}:{"~internal":e}}}exports.createGroup=function(r){var e={};return r.forEach((function(r){r.routeNames?r.routeNames.forEach((function(r){e[r]=!0})):e[r.name]=!0})),{"~internal":{type:"RouteGroup",Route:null},routeNames:Object.keys(e),has:function(r){return!1!==r.name&&!!e[r.name]}}},exports.createRouter=function(){for(var r=arguments.length,a=new Array(r),t=0;t<r;t++)a[t]=arguments[t];var i=C(a),o=i.opts,u=i.routeDefs,l=N(n({},o,{scrollToTop:!1}),u),f=e.createContext(null);return n({},l,{RouteProvider:c,useRoute:s});function c(r){var n=e.useState(l.session.getInitialRoute()),a=n[0],t=n[1];return e.useLayoutEffect((function(){return l.session.listen(t)}),[]),e.useEffect((function(){O(a,o.scrollToTop)}),[a]),e.createElement(f.Provider,{value:a},r.children)}function s(){return e.useContext(f)}},exports.defineRoute=function r(){for(var e=arguments.length,a=new Array(e),t=0;t<e;t++)a[t]=arguments[t];var o=A(a),u={"~internal":{type:"RouteDef",params:o.params,path:o.path},extend:function(){for(var e=arguments.length,a=new Array(e),t=0;t<e;t++)a[t]=arguments[t];var u=A(a),l=u.params,f=u.path,c=Object.keys(o.params),s=Object.keys(l);return c.filter((function(r){return s.indexOf(r)>=0})),r(n({},l,o.params),(function(r){var e,n=i(o.path(t(c))),a=i(f(t(s)));return(e=[]).concat.apply(e,n.map((function(r){return a.map((function(e){return"/"===r?e:r+("/"===e?"":e)}))})));function t(e){var n={};return e.forEach((function(e){n[e]=r[e]})),n}}))}};return u},exports.noMatch=f,exports.param=K,exports.preventDefaultLinkClickBehavior=h;
+"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var r=require("history"),e=require("react");function n(){return(n=Object.assign||function(r){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(r[t]=n[t])}return r}).apply(this,arguments)}function t(r,e){(null==e||e>r.length)&&(e=r.length);for(var n=0,t=new Array(e);n<e;n++)t[n]=r[n];return t}function a(r,e){var n="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(n)return(n=n.call(r)).next.bind(n);if(Array.isArray(r)||(n=function(r,e){if(r){if("string"==typeof r)return t(r,void 0);var n=Object.prototype.toString.call(r).slice(8,-1);return"Object"===n&&r.constructor&&(n=r.constructor.name),"Map"===n||"Set"===n?Array.from(r):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?t(r,void 0):void 0}}(r))||e&&r&&"number"==typeof r.length){n&&(r=n);var a=0;return function(){return a>=r.length?{done:!0}:{done:!1,value:r[a++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function i(r){return Array.isArray(r)?r:[r]}function o(r){return"${p."+r+"}"}function u(r,e){var n={};return Object.keys(e).forEach((function(t){var a=e[t];a["~internal"].kind===r&&(n[t]=a)})),n}function l(r,e,n){var t=r["~internal"].valueSerializer.stringify(e);return n?encodeURIComponent(t):t}var f={__noMatch:!0},s=function(r,e){for(var n=0;n<e.length;n++)if(e[n]!==r[n])return!1;return!0},c=function(r,e){for(var n=1;n<=e.length;n++)if(e[e.length-n]!==r[r.length-n])return!1;return!0},p=function(r,e){var n=r.split(e);return[n[0],n.slice(1).join(e)]},v=c,m=s;function d(r){for(var e,t=r.object,i=r.paramDefs,o=r.urlEncodeDefault,u=r.arraySeparator,l={},s=Object.keys(i).map((function(r){return n({name:r},i[r])})),c=n({},t),p=function(){var r=e.value,n=t[r.name];if(delete c[r.name],void 0===n)return r["~internal"].optional?"continue":{v:!1};var a=void 0;if(null===n){if(!r["~internal"].array)return r["~internal"].optional?"continue":{v:!1};a=[]}else if(r["~internal"].array){if((a=n.split(u).map((function(e){var n;return r["~internal"].valueSerializer.parse((null!=(n=r["~internal"].valueSerializer.urlEncode)?n:o)?decodeURIComponent(e):e)}))).some((function(r){return r===f})))return r["~internal"].optional?"continue":{v:!1}}else{var i;if((a=r["~internal"].valueSerializer.parse((null!=(i=r["~internal"].valueSerializer.urlEncode)?i:o)?decodeURIComponent(n):n))===f)return r["~internal"].optional?"continue":{v:!1}}l[r.name]=a},v=a(s);!(e=v()).done;){var m=p();if("continue"!==m&&"object"==typeof m)return m.v}return{params:l,numExtraneousParams:Object.keys(c).length}}function y(r){var e=r.pathDefs,t=r.params,a=u("query",t),i=u("state",t),o={};return Object.keys(t).forEach((function(r){var e=t[r];void 0!==e["~internal"].default&&(o[r]=e["~internal"].default)})),function(r){var t=r.routerLocation,u=r.arraySeparator,l=r.queryStringSerializer;if(void 0===t.path)return!1;var s=function(r){for(var e=r.path,t=r.pathDefs,a=r.arraySeparator,i=0;i<t.length;i++){var o=u(t[i]);if(!1!==o)return n({},o,{primaryPath:0===i})}return!1;function u(r){var n={};if("/"===e&&0===r.length)return{params:n,numExtraneousParams:0};var t=e.length>1&&v(e,"/");t&&(e=e.slice(0,e.length-1));for(var i=e.split("/").slice(1),o=function(e){var o,u,l,s=e>=r.length?null:r[e],c=e>=i.length?null:i[e];if(null===s)return{v:!1};if(null===c)return 0==r.length-1-e&&null!=(l=s.namedParamDef)&&l["~internal"].optional?"break":{v:!1};if(null!=(o=s.namedParamDef)&&o["~internal"].trailing&&(c=i.slice(e).join("/")),!m(c,s.leading))return{v:!1};var p=c.slice(s.leading.length);if(!v(p,s.trailing))return{v:!1};var d=p.slice(0,p.length-s.trailing.length);if(!s.namedParamDef)return""===d?"continue":{v:!1};if(""===d)return s.namedParamDef["~internal"].optional?"continue":{v:!1};var y=null!=(u=s.namedParamDef["~internal"].valueSerializer.urlEncode)?u:!s.namedParamDef["~internal"].trailing,h=void 0;if(s.namedParamDef["~internal"].array){if((h=d.split(a).map((function(r){var e;return null==(e=s.namedParamDef)?void 0:e["~internal"].valueSerializer.parse(y?decodeURIComponent(r):r)}))).some((function(r){return r===f})))return{v:!1}}else if((h=s.namedParamDef["~internal"].valueSerializer.parse(y?decodeURIComponent(d):d))===f)return{v:!1};return s.namedParamDef["~internal"].trailing&&t&&""===s.trailing&&(h+="/"),n[s.namedParamDef.paramName]=h,s.namedParamDef["~internal"].trailing?"break":void 0},u=0;u<Math.max(r.length,i.length);u++){var l=o(u);if("break"===l)break;if("continue"!==l&&"object"==typeof l)return l.v}return{params:n,numExtraneousParams:0}}}({path:t.path,pathDefs:e,arraySeparator:u});if(!1===s)return!1;var c=function(r,e,n,t){var a={};return r&&(a=n.parse(r)),d({object:a,paramDefs:e,urlEncodeDefault:!0,arraySeparator:t})}(t.query,a,l,u);if(!1===c)return!1;var p=function(r,e,n){return d({object:null!=r?r:{},paramDefs:e,urlEncodeDefault:!1,arraySeparator:n})}(t.state,i,u);return!1!==p&&{primaryPath:s.primaryPath,params:n({},o,s.params,c.params,p.params),numExtraneousParams:s.numExtraneousParams+c.numExtraneousParams+p.numExtraneousParams}}}function h(r){return void 0===r&&(r={}),!(r.target&&r.target.target&&"_self"!==r.target.target||r.defaultPrevented||0!==r.button||r.metaKey||r.altKey||r.ctrlKey||r.shiftKey||(r&&r.preventDefault&&r.preventDefault(),0))}var g=s;function b(r){var e=r.routeName,t=r.params,a=r.location,i=r.routerContext,o=i.navigate,u=i.history.createHref({pathname:!1===e?a.fullPath:a.path,search:a.query?"?"+a.query:""});g(u,"#")&&(u="/"+u),!1!==e&&"/"!==i.baseUrl&&(u=i.baseUrl+u);var l={name:e,params:t,href:u,link:{href:u,onClick:function(r){if(h(r))return l.push()}},action:null,push:function(){return o(n({},l,{action:"push"}),!0)},replace:function(){return o(n({},l,{action:"replace"}),!0)}};return l}function S(r,e,t){var f,s,c,p,v=(f=u("path",e["~internal"].params),s=e["~internal"].path,c=Object.keys(f).map((function(r){return n({paramName:r},f[r])})),p={},c.forEach((function(r){var e=r.paramName;p[e]=o(e)})),i(s(p)).map((function(r){if(1===r.length)return[];for(var e,n=r.split("/").slice(1),t={},i=[],u=a(n);!(e=u()).done;){for(var l,f=e.value,s=null,p=a(c);!(l=p()).done;){var v=l.value;f.indexOf(o(v.paramName))>=0&&(s=v,t[v.paramName]=!0)}if(s){var m=f.split(o(s.paramName));i.push({leading:m[0],trailing:m[1],namedParamDef:s})}else i.push({leading:f,trailing:"",namedParamDef:null})}return c.map((function(r){return r.paramName})).filter((function(r){return!t[r]})),i}))),m=function(a){void 0===a&&(a={});var i=t(),o=i.arraySeparator,u=i.queryStringSerializer,f=i.baseUrl,s=n({},a);Object.keys(e["~internal"].params).forEach((function(r){var n=e["~internal"].params[r];void 0===s[r]&&void 0!==n["~internal"].default&&(s[r]=n["~internal"].default)}));var c=function(r){var e=r.paramCollection,t=r.paramDefCollection,a=r.arraySeparator,i=r.queryStringSerializer,o=r.pathDefs,u=r.baseUrl,f={path:{},query:{},state:{}},s=function(r){var n,i=e[r];if(void 0===i)return"continue";var o=t[r],u=null!=(n=o["~internal"].valueSerializer.urlEncode)?n:"state"!==o["~internal"].kind&&!o["~internal"].trailing,s=function(r){return o["~internal"].array?0===r.length?null:r.map((function(r){return l(o,r,u)})).join(a):l(o,r,u)},c=s(i);if("query"===o["~internal"].kind&&void 0!==o["~internal"].default&&s(o["~internal"].default)===c)return"continue";f[o["~internal"].kind][r]={valueSerializerId:o["~internal"].valueSerializer.id,array:o["~internal"].array,value:c}};for(var c in t)s(c);var p="/"+o[0].filter((function(r){var e=r.namedParamDef;return!(null!=e&&e["~internal"].optional&&void 0===f.path[e.paramName])})).map((function(r){var e=r.namedParamDef;return r.leading+(e?f.path[e.paramName].value:"")+r.trailing})).join("/");return{fullPath:("/"===u?"":u)+p,path:p,query:Object.keys(f.query).length>0?i.stringify(f.query):void 0,state:0===Object.keys(f.state).length?void 0:Object.keys(f.state).reduce((function(r,e){var t;return n({},r,((t={})[e]=f.state[e].value,t))}),{})}}({paramCollection:a,paramDefCollection:e["~internal"].params,arraySeparator:o,queryStringSerializer:u,pathDefs:v,baseUrl:f});return b({routeName:r,params:s,location:c,routerContext:i})};return Object.defineProperty(m,"name",{value:r}),m["~internal"]={type:"RouteBuilder",match:y({pathDefs:v,params:e["~internal"].params}),pathDefs:v,Route:null},m}function P(r){var e,n;void 0===r&&(r={});var t=null!=(e=r.queryStringArrayFormat)?e:"singleKeyWithBracket",i=null!=(n=r.arraySeparator)?n:",",o="multiKey"===t||"multiKeyWithBracket"===t,u="multiKey"===t||"singleKey"===t?"":"[]";return{parse:function(r){for(var e,n={},t=a(r.split("&"));!(e=t()).done;){var l=e.value.split("="),f=l[0],s=l[1],p=l.slice(2);if(!(void 0===f||p.length>0)){var v=decodeURIComponent(c(f,u)?f.slice(0,f.length-u.length):f);void 0===s?n[v]=null:n[v]&&o?n[v]+=""+i+s:n[v]=s}}return n},stringify:function(r){return Object.keys(r).map((function(e){var n=encodeURIComponent(e),t=r[e].array?""+n+u:n,a=r[e].value;return null===a?t:r[e].array&&o?a.split(i).map((function(r){return t+"="+r})).join("&"):t+"="+a})).join("&")}}}function D(r,e){var t=e.queryStringSerializer,a=e.arraySeparator,i=(0,e.getRoutes)(),o=!1;for(var u in i){var l=i[u]["~internal"].match({routerLocation:r,queryStringSerializer:t,arraySeparator:a});if(!1!==l){if(0===l.numExtraneousParams)return{route:i[u](l.params),primaryPath:l.primaryPath};(!1===o||l.numExtraneousParams<o.numExtraneousParams)&&(o=n({},l,{routeName:u}))}}return o?{route:i[o.routeName](o.params),primaryPath:o.primaryPath}:{route:b({routeName:!1,params:{},location:r,routerContext:e}),primaryPath:!0}}var j=s;function k(r,e){return{fullPath:r.pathname,path:j(r.pathname,e)?"/"!==e?r.pathname.replace(e,""):r.pathname:void 0,query:r.search?j(r.search,"?")?r.search.slice(1):r.search:void 0,state:"object"==typeof r.state&&null!==r.state?r.state.state:void 0}}var w=p;function x(r,e,n){var t=w(r,"?");return D(k({pathname:t[0],search:t[1],state:e},n.baseUrl),n)}function O(r){var e=r.startListening,n=r.stopListening,t=[],a=0;return{add:function(r){var i=a++;return t.push({id:i,handler:r}),1===t.length&&e(),function(){var r=t.map((function(r){return r.id})).indexOf(i);r>=0&&(t.splice(r,1),0===t.length&&n())}},getHandlers:function(){return t.map((function(r){return r.handler}))}}}function E(r){if("push"===r.action&&"object"==typeof window&&null!==window&&"function"==typeof window.scroll&&"object"==typeof navigator&&null!==navigator&&"string"==typeof navigator.userAgent&&!(navigator.userAgent.indexOf("Node.js")>0||navigator.userAgent.indexOf("jsdom")>0))try{window.scroll(0,0)}catch(r){}}function R(r,e){var n={};if(r.name)for(var t,i=a(Object.keys(r.params).sort());!(t=i()).done;){var o=t.value,u=e[r.name]["~internal"].params[o]["~internal"];"state"===u.kind&&(n[o]=u.valueSerializer.stringify(r.params[o]))}return n}var q=p;function z(){for(var e,t,i,o,u,l=arguments.length,f=new Array(l),s=0;s<l;s++)f[s]=arguments[s];var c,p,v=N(f),m=v.routeDefs,d=v.opts,y=O({startListening:function(){p=c.listen((function(r){if(S)S=!1;else{var e=k(r.location,h),t=r.action.toLowerCase(),a=D(e,_()),i=a.primaryPath;B(n({},a.route,{action:t}),i)}}))},stopListening:function(){return null==p?void 0:p()}}),h=null!=(e=d.baseUrl)?e:"/",g=null!=(t=null==(i=d.arrayFormat)?void 0:i.separator)?t:",",b=null!=(o=d.queryStringSerializer)?o:P({queryStringArrayFormat:null==(u=d.arrayFormat)?void 0:u.queryString,arraySeparator:g}),S=!1,j=!1,w=null,z=null,A=[];F(d.session);var I,U=C(_),L={push:function(r,e){var t=x(r,e,_()),a=t.primaryPath;return M(n({},t.route,{action:"push"}),a)},replace:function(r,e){var t=x(r,e,_()),a=t.primaryPath;return M(n({},t.route,{action:"replace"}),a)},back:function(r){void 0===r&&(r=1),c.go(-r)},forward:function(r){void 0===r&&(r=1),c.go(r)},getInitialRoute:function(){if(!w){var r=D(k(c.location,h),_());r.primaryPath||(j=!0,r.route.replace(),r=D(k(c.location,h),_())),w=r.route}return w},reset:function(r){return F(r)},block:function(r){A.push(r);var e=c.block((function(e){var t=D(k(e.location,h),_()).route,a=e.action.toLowerCase();r({route:n({},t,{action:a}),retry:e.retry})}));return function(){A.splice(A.findIndex((function(e){return e===r})),1),e()}},listen:function(r){return y.add(r)}},K=(I=L.getInitialRoute(),L.listen((function(r){return I=r})),{getRoute:function(){return I}}),T=K.getRoute,H={routes:U,session:L,stopListening:function(){return null==p?void 0:p()},getRoute:T};return H;function F(e){void 0===e&&(e={type:"undefined"!=typeof window&&void 0!==window.document?"browser":"memory"}),w=null,c="memory"===e.type?r.createMemoryHistory({initialEntries:e.initialEntries,initialIndex:e.initialIndex}):"hash"===e.type?r.createHashHistory({window:e.window}):r.createBrowserHistory({window:e.window})}function M(r,e){var n;if(A.length>0)A.forEach((function(e){e({route:r,retry:function(){r["push"===r.action?"push":"replace"]()}})}));else{var t=R(r,m);if((null==(n=z)?void 0:n.href)!==r.href||JSON.stringify(R(z,m))!==JSON.stringify(t)){j?j=!1:B(r,e),S=!0;var a=q(r.href,"?"),i=a[1];c["replace"===r.action?"replace":"push"]({pathname:a[0],search:i?"?"+i:"",hash:""},t?{state:t}:void 0)}}}function B(r,e){if(e){for(var n,t=a(y.getHandlers());!(n=t()).done;)(0,n.value)(r);!0===d.scrollToTop&&E(r),z=r}else r.replace()}function _(){return{queryStringSerializer:b,arraySeparator:g,navigate:M,history:c,routeDefs:m,getRoutes:function(){return U},baseUrl:h}}}function N(r){return{routeDefs:1===r.length?r[0]:r[1],opts:1===r.length?{}:r[0]}}function C(r){var e={},n=r().routeDefs;for(var t in n)e[t]=S(t,n[t],r);return e}function A(r){return 1===r.length?{params:{},path:function(){return r[0]}}:{params:r[0],path:r[1]}}var I={id:"boolean",parse:function(r){return"true"===r||"false"!==r&&f},stringify:function(r){return r?"true":"false"}},U={id:"number",parse:function(r){return e=r,isNaN(parseFloat(e))||!/^-?\d*\.?\d*$/.test(e)?f:parseFloat(r);var e},stringify:function(r){return r.toString()}},L={id:"string",parse:function(r){return r},stringify:function(r){return r}},K={path:n({},T("path",!1),{trailing:T("path",!0)}),query:T("query",!1),state:T("state",!1)};function T(r,e){return n({},t(!1,!1),{array:t(!1,!0),optional:n({},t(!0,!1),{array:t(!0,!0)})});function t(n,t){return{string:a({"~internal":{type:"ParamDef",array:t,kind:r,optional:n,valueSerializer:L,trailing:e,default:void 0}}),number:a({"~internal":{type:"ParamDef",array:t,kind:r,optional:n,valueSerializer:U,trailing:e,default:void 0}}),boolean:a({"~internal":{type:"ParamDef",array:t,kind:r,optional:n,valueSerializer:I,trailing:e,default:void 0}}),ofType:function(i){return void 0===i&&(i={id:"json",parse:function(r){var e;try{e=JSON.parse(r)}catch(r){return f}return e},stringify:function(r){return JSON.stringify(r)}}),a({"~internal":{type:"ParamDef",array:t,kind:r,optional:n,valueSerializer:i,trailing:e,default:void 0}})}}}function a(r){var e=r["~internal"];return e.optional?{"~internal":e,default:function(r){return{"~internal":n({},e,{default:r})}}}:{"~internal":e}}}function H(r){var e={};return r.forEach((function(r){r.routeNames?r.routeNames.forEach((function(r){e[r]=!0})):e[r.name]=!0})),{"~internal":{type:"RouteGroup",Route:null},routeNames:Object.keys(e),has:function(r){return!1!==r.name&&!!e[r.name]}}}var F=void 0;exports.coreCreateRouter=z,exports.createGroup=function(r){return r instanceof Array?H(r):(e=z(r),n=H(Object.values(e.routes)),e.stopListening(),n);var e,n},exports.createRouter=function(){if(void 0!==F)return F;for(var r=arguments.length,t=new Array(r),a=0;a<r;a++)t[a]=arguments[a];var i=N(t),o=i.opts,u=i.routeDefs,l=z(n({},o,{scrollToTop:!1}),u),f=l.routes,s=l.session,c=l.getRoute,p=void 0;function v(){var r=c(),n=e.useReducer((function(r){return r+1}),0)[1];return e.useLayoutEffect((function(){return s.listen((function(){return n()}))}),[]),e.useEffect((function(){null==p||p()}),[r]),r}return!0===o.scrollToTop&&s.listen((function(r){p=function(){p=void 0,E(r)}})),F={routes:f,session:s,getRoute:c,useRoute:v}},exports.defineRoute=function r(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];var o=A(t),u={"~internal":{type:"RouteDef",params:o.params,path:o.path},extend:function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];var u=A(t),l=u.params,f=u.path,s=Object.keys(o.params),c=Object.keys(l);return s.filter((function(r){return c.indexOf(r)>=0})),r(n({},l,o.params),(function(r){var e,n=i(o.path(a(s))),t=i(f(a(c)));return(e=[]).concat.apply(e,n.map((function(r){return t.map((function(e){return"/"===r?e:r+("/"===e?"":e)}))})));function a(e){var n={};return e.forEach((function(e){n[e]=r[e]})),n}}))}};return u},exports.mergeRouteDefs=function(r){var e=r.pages,n={};return Object.keys(e).forEach((function(r){return Object.assign(n,e[r].routeDefs)})),{routeDefs:n}},exports.noMatch=f,exports.param=K,exports.preventDefaultLinkClickBehavior=h;
 //# sourceMappingURL=type-route.cjs.production.min.js.map
diff --git a/node_modules/type-route/dist/type-route.cjs.production.min.js.map b/node_modules/type-route/dist/type-route.cjs.production.min.js.map
index c03d48d..6f9e17a 100644
--- a/node_modules/type-route/dist/type-route.cjs.production.min.js.map
+++ b/node_modules/type-route/dist/type-route.cjs.production.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"type-route.cjs.production.min.js","sources":["../src/asArray.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/createMatcher.ts","../src/getQueryMatch.ts","../src/getStateMatch.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts","../src/react.ts"],"sourcesContent":["export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session: {\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n    },\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n","import {\n  CoreRouter,\n  UmbrellaRouteDefCollection,\n  UmbrellaRoute,\n  RouteDefCollectionRoute,\n  RouterOpts,\n} from \"./types\";\nimport { createRouter as coreCreateRouter, parseArgs } from \"./createRouter\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport * as React from \"react\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\n\nif (typeof __DEV__ === \"boolean\" && __DEV__) {\n  const [major, minor] = React.version\n    .split(\".\")\n    .map((value: string) => parseInt(value, 10));\n\n  if (major < 16 || (major === 16 && minor < 8)) {\n    throw TypeRouteError.Invalid_React_version.create(React.version);\n  }\n}\n\nexport { defineRoute } from \"./defineRoute\";\nexport { param } from \"./param\";\nexport { createGroup } from \"./createGroup\";\nexport { noMatch } from \"./noMatch\";\nexport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nexport {\n  GetRoute as Route,\n  Link,\n  ValueSerializer,\n  QueryStringSerializer,\n  SessionOpts,\n  RouterOpts,\n} from \"./types\";\n\ntype Router<TRouteDefCollection extends { [routeName: string]: any }> =\n  CoreRouter<TRouteDefCollection> & {\n    /**\n     * React hook for retrieving the current route.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/use-route\n     */\n    useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;\n\n    /**\n     * React component which connects React to Type Route and provides the current route to the rest of the application.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/route-provider\n     */\n    RouteProvider: (props: { children?: any }) => any;\n  };\ntype UmbrellaRouter = Router<UmbrellaRouteDefCollection>;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): Router<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaRouter {\n  const { opts, routeDefs } = parseArgs(args);\n  const router = coreCreateRouter({ ...opts, scrollToTop: false }, routeDefs);\n  const routeContext = React.createContext<UmbrellaRoute | null>(null);\n\n  return {\n    ...router,\n    RouteProvider,\n    useRoute,\n  };\n\n  function RouteProvider(props: { children?: any }) {\n    const [route, setRoute] = React.useState(router.session.getInitialRoute());\n\n    React.useLayoutEffect(() => router.session.listen(setRoute), []);\n\n    React.useEffect(() => {\n      attemptScrollToTop(route, opts.scrollToTop);\n    }, [route]);\n\n    return React.createElement(\n      routeContext.Provider,\n      { value: route },\n      props.children\n    );\n  }\n\n  function useRoute() {\n    const route = React.useContext(routeContext);\n\n    if (__DEV__) {\n      if (route === null) {\n        throw TypeRouteError.App_should_be_wrapped_in_a_RouteProvider_component.create();\n      }\n    }\n\n    return route!;\n  }\n}\n"],"names":["asArray","value","Array","isArray","getParamId","parameterName","getParamDefsOfType","type","paramDefCollection","filteredParamDefCollection","Object","keys","forEach","name","paramDef","kind","stringify","urlEncode","result","valueSerializer","encodeURIComponent","noMatch","__noMatch","stringUtils","start","i","length","end","split","_value$split","slice","join","endsWith","startsWith","getObjectMatch","_ref","_step","object","paramDefs","urlEncodeDefault","arraySeparator","params","namedParamDefs","map","_extends","extraneousParams","_loop","raw","undefined","optional","v","array","part","parse","_paramDef$Internal$v","decodeURIComponent","some","_paramDef$Internal$v2","_iterator","_createForOfIteratorHelperLoose","done","_ret","numExtraneousParams","createMatcher","pathDefs","queryParamDefCollection","stateParamDefCollection","defaultParams","paramName","param","_ref2","routerLocation","queryStringSerializer","path","pathMatch","index","match","primaryPath","pathDef","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","_pathSegmentDef$named","pathSegmentDef","pathSegment","namedParamDef","trailing","leading","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","Math","max","getPathMatch","queryMatch","query","getQueryMatch","stateMatch","state","getStateMatch","preventDefaultLinkClickBehavior","event","target","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","preventDefault","buildRoute","routeName","location","routerContext","navigate","href","history","createHref","pathname","fullPath","search","baseUrl","route","link","onClick","push","action","replace","createRouteBuilder","routeDef","getRouterContext","pathParamDefCollection","getRawPath","namedPathParamDefs","paramIdCollection","rawPath","rawPathSegments","usedPathParams","_step2","rawSegment","includedParamDef","_iterator2","indexOf","_rawSegment$split","filter","build","paramsWithDefault","paramCollection","paramValue","getValue","valueSerializerId","id","_ref3","reduce","key","_extends2","createLocation","defineProperty","Route","createQueryStringSerializer","args","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","rest","encodedName","getMatchingRoute","routes","getRoutes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","splitFirst","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","handler","splice","getHandlers","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sort","createRouter","_len","_key","arguments","unlisten","_parseArgs","parseArgs","opts","navigationHandlerManager","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","router","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","retry","findIndex","item","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","JSON","hash","boolean","number","isNaN","parseFloat","test","toString","string","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","~internal","default","ofType","internal","groupItems","routeNames","has","coreCreateRouter","routeContext","React","RouteProvider","useRoute","props","_React$useState","setRoute","Provider","children","defineRoute","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","x","parentPathArray","childPathArray","concat","apply","parentPath","childPath","allowedKeys","filteredX"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"type-route.cjs.production.min.js","sources":["../src/asArray.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/createMatcher.ts","../src/getQueryMatch.ts","../src/getStateMatch.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts","../src/react.ts"],"sourcesContent":["export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const session: UmbrellaCoreRouter[\"session\"] = {\n\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n\n  };\n\n  const { getRoute } = (() => {\n    let route_current = session.getInitialRoute();\n\n    session.listen(route => (route_current = route));\n\n    function getRoute() {\n        return route_current;\n    }\n\n    return { getRoute };\n  })();\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session,\n    stopListening: ()=> unlisten?.(),\n    getRoute\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    if( opts.scrollToTop === true){\n      attemptScrollToTop(route);\n    }\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder, CoreRouter } from \"./types\";\nimport { assert } from \"./assert\";\nimport { createRouter as coreCreateRouter } from \"./createRouter\";\n\nfunction createGroup_fromItems<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n\nexport function createGroup_fromRouteDefs<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n> {\n  const core = coreCreateRouter(routeDefs);\n\n  const group= createGroup_fromItems(\n    Object.values(core.routes)\n  );\n\n  core.stopListening();\n\n  return group;\n}\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;\nexport function createGroup<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n>;\nexport function createGroup(\n  arg: any[] | Record<string, unknown>\n): RouteGroup<any> {\n  return arg instanceof Array\n    ? createGroup_fromItems(arg)\n    : createGroup_fromRouteDefs(arg);\n}\n\n\n","import {\n  CoreRouter,\n  UmbrellaRouteDefCollection,\n  RouteDefCollectionRoute,\n  RouterOpts,\n} from \"./types\";\nimport { createRouter as coreCreateRouter, parseArgs } from \"./createRouter\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport * as React from \"react\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport type { UnionToIntersection } from \"./tools/UnionToIntersection\";\n\nimport * as types from \"./types\";\n\nexport type { types };\nexport { coreCreateRouter };\n\nif (typeof __DEV__ === \"boolean\" && __DEV__) {\n  const [major, minor] = React.version\n    .split(\".\")\n    .map((value: string) => parseInt(value, 10));\n\n  if (major < 16 || (major === 16 && minor < 8)) {\n    throw TypeRouteError.Invalid_React_version.create(React.version);\n  }\n}\n\nexport { defineRoute } from \"./defineRoute\";\nexport { param } from \"./param\";\nexport { createGroup } from \"./createGroup\";\nexport { noMatch } from \"./noMatch\";\nexport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nexport {\n  GetRoute as Route,\n  Link,\n  ValueSerializer,\n  QueryStringSerializer,\n  SessionOpts,\n  RouterOpts,\n} from \"./types\";\n\ntype Router<TRouteDefCollection extends { [routeName: string]: any }> =\n  Omit<CoreRouter<TRouteDefCollection>, \"stopListening\"> & {\n    /**\n     * React hook for retrieving the current route.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/use-route\n     */\n    useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;\n  };\ntype UmbrellaRouter = Router<UmbrellaRouteDefCollection>;\n\nexport function mergeRouteDefs<\n  TPageCollection extends { [pageName: string]: { routeDefs: { [routeName: string]: any } } }\n>(\n  params: { pages: TPageCollection; }\n): { routeDefs: UnionToIntersection<TPageCollection[keyof TPageCollection][\"routeDefs\"]> }{\n\n  const { pages } = params;\n\n  const routeDefs = {};\n\n  Object.keys(pages).forEach((pageName) =>\n    Object.assign(routeDefs, pages[pageName].routeDefs)\n  );\n\n  // @ts-expect-error\n  return { routeDefs };\n}\n\n// NOTE: For HMR, we want stable reference.  \nlet router: UmbrellaRouter | undefined = undefined;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): Router<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaRouter {\n  if (router !== undefined) {\n    return router;\n  }\n\n  const { opts, routeDefs } = parseArgs(args);\n  const { routes, session, getRoute } = coreCreateRouter(\n    { ...opts, scrollToTop: false },\n    routeDefs\n  );\n\n  let effect: (() => void) | undefined = undefined;\n\n  if (opts.scrollToTop === true) {\n    session.listen((route) => {\n      effect = () => {\n        effect = undefined;\n        attemptScrollToTop(route);\n      };\n    });\n  }\n\n  function useRoute() {\n    const route = getRoute();\n\n    const [, reRender] = React.useReducer((count) => count + 1, 0);\n\n    React.useLayoutEffect(() => session.listen(() => reRender()), []);\n\n    React.useEffect(() => {\n      effect?.();\n    }, [route]);\n\n    return route;\n  }\n\n  router = {\n    routes,\n    session,\n    getRoute,\n    useRoute,\n  };\n\n  return router;\n}\n\n"],"names":["asArray","value","Array","isArray","getParamId","parameterName","getParamDefsOfType","type","paramDefCollection","filteredParamDefCollection","Object","keys","forEach","name","paramDef","kind","stringify","urlEncode","result","valueSerializer","encodeURIComponent","noMatch","__noMatch","stringUtils","start","i","length","end","split","_value$split","slice","join","endsWith","startsWith","getObjectMatch","_ref","_step","object","paramDefs","urlEncodeDefault","arraySeparator","params","namedParamDefs","map","_extends","extraneousParams","_loop","raw","undefined","optional","v","array","part","parse","_paramDef$Internal$v","decodeURIComponent","some","_paramDef$Internal$v2","_iterator","_createForOfIteratorHelperLoose","done","_ret","numExtraneousParams","createMatcher","pathDefs","queryParamDefCollection","stateParamDefCollection","defaultParams","paramName","param","_ref2","routerLocation","queryStringSerializer","path","pathMatch","index","match","primaryPath","pathDef","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","_pathSegmentDef$named","pathSegmentDef","pathSegment","namedParamDef","trailing","leading","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","Math","max","getPathMatch","queryMatch","query","getQueryMatch","stateMatch","state","getStateMatch","preventDefaultLinkClickBehavior","event","target","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","preventDefault","buildRoute","routeName","location","routerContext","navigate","href","history","createHref","pathname","fullPath","search","baseUrl","route","link","onClick","push","action","replace","createRouteBuilder","routeDef","getRouterContext","pathParamDefCollection","getRawPath","namedPathParamDefs","paramIdCollection","rawPath","rawPathSegments","usedPathParams","_step2","rawSegment","includedParamDef","_iterator2","indexOf","_rawSegment$split","filter","build","paramsWithDefault","paramCollection","paramValue","getValue","valueSerializerId","id","_ref3","reduce","key","_extends2","createLocation","defineProperty","Route","createQueryStringSerializer","args","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","rest","encodedName","getMatchingRoute","routes","getRoutes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","splitFirst","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","handler","splice","getHandlers","attemptScrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sort","createRouter","_len","_key","arguments","unlisten","_parseArgs","parseArgs","opts","navigationHandlerManager","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","route_current","createRouteBuilderCollection","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","retry","findIndex","item","getRoute","router","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","JSON","hash","scrollToTop","boolean","number","isNaN","parseFloat","test","toString","string","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","~internal","default","ofType","internal","createGroup_fromItems","groupItems","routeNames","has","arg","core","coreCreateRouter","group","values","_coreCreateRouter","effect","useRoute","reRender","React","count","defineRoute","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","x","parentPathArray","childPathArray","concat","apply","parentPath","childPath","allowedKeys","filteredX","pages","pageName","assign"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/type-route/dist/type-route.esm.js b/node_modules/type-route/dist/type-route.esm.js
index 3517dec..06dec7c 100644
--- a/node_modules/type-route/dist/type-route.esm.js
+++ b/node_modules/type-route/dist/type-route.esm.js
@@ -1,5 +1,5 @@
 import { createMemoryHistory, createHashHistory, createBrowserHistory } from 'history';
-import { version, createContext, useState, useLayoutEffect, useEffect, createElement, useContext } from 'react';
+import { version, useReducer, useLayoutEffect, useEffect } from 'react';
 
 function _extends() {
   _extends = Object.assign || function (target) {
@@ -221,12 +221,6 @@ var TypeRouteError = /*#__PURE__*/buildErrorCollection({
       return ["The following characters are invalid: " + invalidCharacters.join(", ") + "."];
     }
   },
-  App_should_be_wrapped_in_a_RouteProvider_component: {
-    errorCode: 1020,
-    getDetails: function getDetails() {
-      return ["Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook."];
-    }
-  },
   Invalid_React_version: {
     errorCode: 1021,
     getDetails: function getDetails(version) {
@@ -1198,8 +1192,8 @@ function createNavigationHandlerManager(_ref) {
   }
 }
 
-function attemptScrollToTop(route, scrollToTop) {
-  if (route.action === "push" && typeof window === "object" && window !== null && typeof window.scroll === "function" && scrollToTop !== false && typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string" && !(navigator.userAgent.indexOf("Node.js") > 0 || navigator.userAgent.indexOf("jsdom") > 0)) {
+function attemptScrollToTop(route) {
+  if (route.action === "push" && typeof window === "object" && window !== null && typeof window.scroll === "function" && typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string" && !(navigator.userAgent.indexOf("Node.js") > 0 || navigator.userAgent.indexOf("jsdom") > 0)) {
     try {
       window.scroll(0, 0);
     } catch (_unused) {}
@@ -1268,95 +1262,113 @@ function createRouter() {
   var blockerCollection = [];
   applySessionOpts(opts.session);
   var routes = createRouteBuilderCollection(getRouterContext);
-  var router = {
-    routes: routes,
-    session: {
-      push: function push(href, state) {
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].push", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
-        }
-        var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),
-          route = _getRouteByHref.route,
-          primaryPath = _getRouteByHref.primaryPath;
-        return navigate(_extends({}, route, {
-          action: "push"
-        }), primaryPath);
-      },
-      replace: function replace(href, state) {
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].replace", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
-        }
-        var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),
-          route = _getRouteByHref2.route,
-          primaryPath = _getRouteByHref2.primaryPath;
-        return navigate(_extends({}, route, {
-          action: "replace"
-        }), primaryPath);
-      },
-      back: function back(amount) {
-        if (amount === void 0) {
-          amount = 1;
-        }
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].back", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
-        }
-        history.go(-amount);
-      },
-      forward: function forward(amount) {
-        if (amount === void 0) {
-          amount = 1;
-        }
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].forward", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
-        }
-        history.go(amount);
-      },
-      getInitialRoute: function getInitialRoute() {
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].getInitialRoute", [assert.numArgs([].slice.call(arguments), 0)]);
-        }
-        if (!initialRoute) {
-          var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());
-          if (!result.primaryPath) {
-            skipHandlingNextApplicationTriggeredNavigation = true;
-            result.route.replace();
-            result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());
-          }
-          initialRoute = result.route;
-        }
-        return initialRoute;
-      },
-      reset: function reset(session) {
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].reset", [assert.numArgs([].slice.call(arguments), 1), assert.type("object", "session", session)]);
+  var session = {
+    push: function push(href, state) {
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].push", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
+      }
+      var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),
+        route = _getRouteByHref.route,
+        primaryPath = _getRouteByHref.primaryPath;
+      return navigate(_extends({}, route, {
+        action: "push"
+      }), primaryPath);
+    },
+    replace: function replace(href, state) {
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].replace", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
+      }
+      var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),
+        route = _getRouteByHref2.route,
+        primaryPath = _getRouteByHref2.primaryPath;
+      return navigate(_extends({}, route, {
+        action: "replace"
+      }), primaryPath);
+    },
+    back: function back(amount) {
+      if (amount === void 0) {
+        amount = 1;
+      }
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].back", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
+      }
+      history.go(-amount);
+    },
+    forward: function forward(amount) {
+      if (amount === void 0) {
+        amount = 1;
+      }
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].forward", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
+      }
+      history.go(amount);
+    },
+    getInitialRoute: function getInitialRoute() {
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].getInitialRoute", [assert.numArgs([].slice.call(arguments), 0)]);
+      }
+      if (!initialRoute) {
+        var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());
+        if (!result.primaryPath) {
+          skipHandlingNextApplicationTriggeredNavigation = true;
+          result.route.replace();
+          result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());
         }
-        return applySessionOpts(session);
-      },
-      block: function block(blocker) {
-        blockerCollection.push(blocker);
-        var unblock = history.block(function (update) {
-          var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),
-            route = _getMatchingRoute2.route;
-          var action = update.action.toLowerCase();
-          blocker({
-            route: _extends({}, route, {
-              action: action
-            }),
-            retry: update.retry
-          });
-        });
-        return function () {
-          blockerCollection.splice(blockerCollection.findIndex(function (item) {
-            return item === blocker;
-          }), 1);
-          unblock();
-        };
-      },
-      listen: function listen(handler) {
-        return navigationHandlerManager.add(handler);
+        initialRoute = result.route;
+      }
+      return initialRoute;
+    },
+    reset: function reset(session) {
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].reset", [assert.numArgs([].slice.call(arguments), 1), assert.type("object", "session", session)]);
       }
+      return applySessionOpts(session);
+    },
+    block: function block(blocker) {
+      blockerCollection.push(blocker);
+      var unblock = history.block(function (update) {
+        var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),
+          route = _getMatchingRoute2.route;
+        var action = update.action.toLowerCase();
+        blocker({
+          route: _extends({}, route, {
+            action: action
+          }),
+          retry: update.retry
+        });
+      });
+      return function () {
+        blockerCollection.splice(blockerCollection.findIndex(function (item) {
+          return item === blocker;
+        }), 1);
+        unblock();
+      };
+    },
+    listen: function listen(handler) {
+      return navigationHandlerManager.add(handler);
     }
   };
+  var _ref = function () {
+      var route_current = session.getInitialRoute();
+      session.listen(function (route) {
+        return route_current = route;
+      });
+      function getRoute() {
+        return route_current;
+      }
+      return {
+        getRoute: getRoute
+      };
+    }(),
+    getRoute = _ref.getRoute;
+  var router = {
+    routes: routes,
+    session: session,
+    stopListening: function stopListening() {
+      return unlisten == null ? void 0 : unlisten();
+    },
+    getRoute: getRoute
+  };
   return router;
   function applySessionOpts(sessionOpts) {
     if (sessionOpts === void 0) {
@@ -1423,7 +1435,9 @@ function createRouter() {
       var handler = _step.value;
       handler(route);
     }
-    attemptScrollToTop(route, opts.scrollToTop);
+    if (opts.scrollToTop === true) {
+      attemptScrollToTop(route);
+    }
     previousRoute = route;
   }
   function getRouterContext() {
@@ -1699,7 +1713,7 @@ function getParamDefKindSection(kind, trailing) {
   }
 }
 
-function createGroup(groupItems) {
+function createGroup_fromItems(groupItems) {
   if (process.env.NODE_ENV !== "production") {
     assert("createGroup", [assert.numArgs([].slice.call(arguments), 1), assert.arrayOfType(["RouteGroup", "RouteBuilder"], "groupItems", groupItems)]);
   }
@@ -1733,6 +1747,15 @@ function createGroup(groupItems) {
 function isRouteGroup(value) {
   return !!value.routeNames;
 }
+function createGroup_fromRouteDefs(routeDefs) {
+  var core = createRouter(routeDefs);
+  var group = createGroup_fromItems(Object.values(core.routes));
+  core.stopListening();
+  return group;
+}
+function createGroup(arg) {
+  return arg instanceof Array ? createGroup_fromItems(arg) : createGroup_fromRouteDefs(arg);
+}
 
 if (typeof (process.env.NODE_ENV !== "production") === "boolean" && process.env.NODE_ENV !== "production") {
   var _React$version$split$ = /*#__PURE__*/version.split(".").map(function (value) {
@@ -1744,45 +1767,68 @@ if (typeof (process.env.NODE_ENV !== "production") === "boolean" && process.env.
     throw TypeRouteError.Invalid_React_version.create(version);
   }
 }
+function mergeRouteDefs(params) {
+  var pages = params.pages;
+  var routeDefs = {};
+  Object.keys(pages).forEach(function (pageName) {
+    return Object.assign(routeDefs, pages[pageName].routeDefs);
+  });
+  // @ts-expect-error
+  return {
+    routeDefs: routeDefs
+  };
+}
+// NOTE: For HMR, we want stable reference.  
+var router = undefined;
 function createRouter$1() {
+  if (router !== undefined) {
+    return router;
+  }
   for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
     args[_key] = arguments[_key];
   }
   var _parseArgs = parseArgs(args),
     opts = _parseArgs.opts,
     routeDefs = _parseArgs.routeDefs;
-  var router = createRouter(_extends({}, opts, {
-    scrollToTop: false
-  }), routeDefs);
-  var routeContext = createContext(null);
-  return _extends({}, router, {
-    RouteProvider: RouteProvider,
-    useRoute: useRoute
-  });
-  function RouteProvider(props) {
-    var _React$useState = useState(router.session.getInitialRoute()),
-      route = _React$useState[0],
-      setRoute = _React$useState[1];
+  var _coreCreateRouter = createRouter(_extends({}, opts, {
+      scrollToTop: false
+    }), routeDefs),
+    routes = _coreCreateRouter.routes,
+    session = _coreCreateRouter.session,
+    getRoute = _coreCreateRouter.getRoute;
+  var _effect = undefined;
+  if (opts.scrollToTop === true) {
+    session.listen(function (route) {
+      _effect = function effect() {
+        _effect = undefined;
+        attemptScrollToTop(route);
+      };
+    });
+  }
+  function useRoute() {
+    var route = getRoute();
+    var _React$useReducer = useReducer(function (count) {
+        return count + 1;
+      }, 0),
+      reRender = _React$useReducer[1];
     useLayoutEffect(function () {
-      return router.session.listen(setRoute);
+      return session.listen(function () {
+        return reRender();
+      });
     }, []);
     useEffect(function () {
-      attemptScrollToTop(route, opts.scrollToTop);
+      _effect == null ? void 0 : _effect();
     }, [route]);
-    return createElement(routeContext.Provider, {
-      value: route
-    }, props.children);
-  }
-  function useRoute() {
-    var route = useContext(routeContext);
-    if (process.env.NODE_ENV !== "production") {
-      if (route === null) {
-        throw TypeRouteError.App_should_be_wrapped_in_a_RouteProvider_component.create();
-      }
-    }
     return route;
   }
+  router = {
+    routes: routes,
+    session: session,
+    getRoute: getRoute,
+    useRoute: useRoute
+  };
+  return router;
 }
 
-export { createGroup, createRouter$1 as createRouter, defineRoute, noMatch, param, preventDefaultLinkClickBehavior };
+export { createRouter as coreCreateRouter, createGroup, createRouter$1 as createRouter, defineRoute, mergeRouteDefs, noMatch, param, preventDefaultLinkClickBehavior };
 //# sourceMappingURL=type-route.esm.js.map
diff --git a/node_modules/type-route/dist/type-route.esm.js.map b/node_modules/type-route/dist/type-route.esm.js.map
index 83ac7b9..c8164cc 100644
--- a/node_modules/type-route/dist/type-route.esm.js.map
+++ b/node_modules/type-route/dist/type-route.esm.js.map
@@ -1 +1 @@
-{"version":3,"file":"type-route.esm.js","sources":["../src/typeOf.ts","../src/TypeRouteError.ts","../src/asArray.ts","../src/assert.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/getStateMatch.ts","../src/getQueryMatch.ts","../src/createMatcher.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts","../src/react.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  App_should_be_wrapped_in_a_RouteProvider_component: {\n    errorCode: 1020,\n    getDetails() {\n      return [\n        \"Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook.\",\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session: {\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n    },\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n","import {\n  CoreRouter,\n  UmbrellaRouteDefCollection,\n  UmbrellaRoute,\n  RouteDefCollectionRoute,\n  RouterOpts,\n} from \"./types\";\nimport { createRouter as coreCreateRouter, parseArgs } from \"./createRouter\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport * as React from \"react\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\n\nif (typeof __DEV__ === \"boolean\" && __DEV__) {\n  const [major, minor] = React.version\n    .split(\".\")\n    .map((value: string) => parseInt(value, 10));\n\n  if (major < 16 || (major === 16 && minor < 8)) {\n    throw TypeRouteError.Invalid_React_version.create(React.version);\n  }\n}\n\nexport { defineRoute } from \"./defineRoute\";\nexport { param } from \"./param\";\nexport { createGroup } from \"./createGroup\";\nexport { noMatch } from \"./noMatch\";\nexport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nexport {\n  GetRoute as Route,\n  Link,\n  ValueSerializer,\n  QueryStringSerializer,\n  SessionOpts,\n  RouterOpts,\n} from \"./types\";\n\ntype Router<TRouteDefCollection extends { [routeName: string]: any }> =\n  CoreRouter<TRouteDefCollection> & {\n    /**\n     * React hook for retrieving the current route.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/use-route\n     */\n    useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;\n\n    /**\n     * React component which connects React to Type Route and provides the current route to the rest of the application.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/route-provider\n     */\n    RouteProvider: (props: { children?: any }) => any;\n  };\ntype UmbrellaRouter = Router<UmbrellaRouteDefCollection>;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): Router<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaRouter {\n  const { opts, routeDefs } = parseArgs(args);\n  const router = coreCreateRouter({ ...opts, scrollToTop: false }, routeDefs);\n  const routeContext = React.createContext<UmbrellaRoute | null>(null);\n\n  return {\n    ...router,\n    RouteProvider,\n    useRoute,\n  };\n\n  function RouteProvider(props: { children?: any }) {\n    const [route, setRoute] = React.useState(router.session.getInitialRoute());\n\n    React.useLayoutEffect(() => router.session.listen(setRoute), []);\n\n    React.useEffect(() => {\n      attemptScrollToTop(route, opts.scrollToTop);\n    }, [route]);\n\n    return React.createElement(\n      routeContext.Provider,\n      { value: route },\n      props.children\n    );\n  }\n\n  function useRoute() {\n    const route = React.useContext(routeContext);\n\n    if (__DEV__) {\n      if (route === null) {\n        throw TypeRouteError.App_should_be_wrapped_in_a_RouteProvider_component.create();\n      }\n    }\n\n    return route!;\n  }\n}\n"],"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","App_should_be_wrapped_in_a_RouteProvider_component","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","process","env","NODE_ENV","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","_loop","_paramDef$Internal$v","paramValue","undefined","urlEncodeDefault","urlEncode","valueSerializer","getValue","valueSerializerId","id","_ret","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","router","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","_opts$arrayFormat3","_getRouterContext","defineRoute","assertDefineRouteOrExtendArgs","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup","groupItems","routeNames","isRouteGroup","has","_React$version$split$","React","parseInt","major","minor","coreCreateRouter","routeContext","RouteProvider","useRoute","props","_React$useState","setRoute","Provider","children"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"type-route.esm.js","sources":["../src/typeOf.ts","../src/TypeRouteError.ts","../src/asArray.ts","../src/assert.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/getStateMatch.ts","../src/getQueryMatch.ts","../src/createMatcher.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts","../src/react.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const session: UmbrellaCoreRouter[\"session\"] = {\n\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n\n  };\n\n  const { getRoute } = (() => {\n    let route_current = session.getInitialRoute();\n\n    session.listen(route => (route_current = route));\n\n    function getRoute() {\n        return route_current;\n    }\n\n    return { getRoute };\n  })();\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session,\n    stopListening: ()=> unlisten?.(),\n    getRoute\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    if( opts.scrollToTop === true){\n      attemptScrollToTop(route);\n    }\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder, CoreRouter } from \"./types\";\nimport { assert } from \"./assert\";\nimport { createRouter as coreCreateRouter } from \"./createRouter\";\n\nfunction createGroup_fromItems<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n\nexport function createGroup_fromRouteDefs<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n> {\n  const core = coreCreateRouter(routeDefs);\n\n  const group= createGroup_fromItems(\n    Object.values(core.routes)\n  );\n\n  core.stopListening();\n\n  return group;\n}\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;\nexport function createGroup<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n>;\nexport function createGroup(\n  arg: any[] | Record<string, unknown>\n): RouteGroup<any> {\n  return arg instanceof Array\n    ? createGroup_fromItems(arg)\n    : createGroup_fromRouteDefs(arg);\n}\n\n\n","import {\n  CoreRouter,\n  UmbrellaRouteDefCollection,\n  RouteDefCollectionRoute,\n  RouterOpts,\n} from \"./types\";\nimport { createRouter as coreCreateRouter, parseArgs } from \"./createRouter\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport * as React from \"react\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport type { UnionToIntersection } from \"./tools/UnionToIntersection\";\n\nimport * as types from \"./types\";\n\nexport type { types };\nexport { coreCreateRouter };\n\nif (typeof __DEV__ === \"boolean\" && __DEV__) {\n  const [major, minor] = React.version\n    .split(\".\")\n    .map((value: string) => parseInt(value, 10));\n\n  if (major < 16 || (major === 16 && minor < 8)) {\n    throw TypeRouteError.Invalid_React_version.create(React.version);\n  }\n}\n\nexport { defineRoute } from \"./defineRoute\";\nexport { param } from \"./param\";\nexport { createGroup } from \"./createGroup\";\nexport { noMatch } from \"./noMatch\";\nexport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nexport {\n  GetRoute as Route,\n  Link,\n  ValueSerializer,\n  QueryStringSerializer,\n  SessionOpts,\n  RouterOpts,\n} from \"./types\";\n\ntype Router<TRouteDefCollection extends { [routeName: string]: any }> =\n  Omit<CoreRouter<TRouteDefCollection>, \"stopListening\"> & {\n    /**\n     * React hook for retrieving the current route.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/use-route\n     */\n    useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;\n  };\ntype UmbrellaRouter = Router<UmbrellaRouteDefCollection>;\n\nexport function mergeRouteDefs<\n  TPageCollection extends { [pageName: string]: { routeDefs: { [routeName: string]: any } } }\n>(\n  params: { pages: TPageCollection; }\n): { routeDefs: UnionToIntersection<TPageCollection[keyof TPageCollection][\"routeDefs\"]> }{\n\n  const { pages } = params;\n\n  const routeDefs = {};\n\n  Object.keys(pages).forEach((pageName) =>\n    Object.assign(routeDefs, pages[pageName].routeDefs)\n  );\n\n  // @ts-expect-error\n  return { routeDefs };\n}\n\n// NOTE: For HMR, we want stable reference.  \nlet router: UmbrellaRouter | undefined = undefined;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): Router<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaRouter {\n  if (router !== undefined) {\n    return router;\n  }\n\n  const { opts, routeDefs } = parseArgs(args);\n  const { routes, session, getRoute } = coreCreateRouter(\n    { ...opts, scrollToTop: false },\n    routeDefs\n  );\n\n  let effect: (() => void) | undefined = undefined;\n\n  if (opts.scrollToTop === true) {\n    session.listen((route) => {\n      effect = () => {\n        effect = undefined;\n        attemptScrollToTop(route);\n      };\n    });\n  }\n\n  function useRoute() {\n    const route = getRoute();\n\n    const [, reRender] = React.useReducer((count) => count + 1, 0);\n\n    React.useLayoutEffect(() => session.listen(() => reRender()), []);\n\n    React.useEffect(() => {\n      effect?.();\n    }, [route]);\n\n    return route;\n  }\n\n  router = {\n    routes,\n    session,\n    getRoute,\n    useRoute,\n  };\n\n  return router;\n}\n\n"],"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","process","env","NODE_ENV","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","_loop","_paramDef$Internal$v","paramValue","undefined","urlEncodeDefault","urlEncode","valueSerializer","getValue","valueSerializerId","id","_ret","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","route_current","getRoute","router","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","scrollToTop","_opts$arrayFormat3","_getRouterContext","defineRoute","assertDefineRouteOrExtendArgs","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup_fromItems","groupItems","routeNames","isRouteGroup","has","createGroup_fromRouteDefs","core","coreCreateRouter","group","values","createGroup","arg","_React$version$split$","React","parseInt","major","minor","mergeRouteDefs","pages","pageName","assign","_coreCreateRouter","effect","useRoute","_React$useReducer","count","reRender"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/type-route/src/TypeRouteError.ts b/node_modules/type-route/src/TypeRouteError.ts
index d3066de..1946509 100644
--- a/node_modules/type-route/src/TypeRouteError.ts
+++ b/node_modules/type-route/src/TypeRouteError.ts
@@ -322,15 +322,6 @@ export const TypeRouteError = buildErrorCollection({
     },
   },
 
-  App_should_be_wrapped_in_a_RouteProvider_component: {
-    errorCode: 1020,
-    getDetails() {
-      return [
-        "Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook.",
-      ];
-    },
-  },
-
   Invalid_React_version: {
     errorCode: 1021,
     getDetails(version: string) {
diff --git a/node_modules/type-route/src/attemptScrollToTop.ts b/node_modules/type-route/src/attemptScrollToTop.ts
index 436e4ef..e2ee856 100644
--- a/node_modules/type-route/src/attemptScrollToTop.ts
+++ b/node_modules/type-route/src/attemptScrollToTop.ts
@@ -1,15 +1,13 @@
 import { UmbrellaRoute } from "./types";
 
 export function attemptScrollToTop(
-  route: UmbrellaRoute,
-  scrollToTop: boolean | undefined
+  route: UmbrellaRoute
 ) {
   if (
     route.action === "push" &&
     typeof window === "object" &&
     window !== null &&
     typeof window.scroll === "function" &&
-    scrollToTop !== false &&
     typeof navigator === "object" &&
     navigator !== null &&
     typeof navigator.userAgent === "string" &&
diff --git a/node_modules/type-route/src/createGroup.ts b/node_modules/type-route/src/createGroup.ts
index 3234466..e45ecf2 100644
--- a/node_modules/type-route/src/createGroup.ts
+++ b/node_modules/type-route/src/createGroup.ts
@@ -1,7 +1,8 @@
-import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from "./types";
+import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder, CoreRouter } from "./types";
 import { assert } from "./assert";
+import { createRouter as coreCreateRouter } from "./createRouter";
 
-export function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {
+function createGroup_fromItems<T extends any[]>(groupItems: T): RouteGroup<T> {
   if (__DEV__) {
     assert("createGroup", [
       assert.numArgs([].slice.call(arguments), 1),
@@ -53,3 +54,39 @@ function isRouteGroup(
 ): value is RouteGroup {
   return !!(value as RouteGroup).routeNames;
 }
+
+export function createGroup_fromRouteDefs<
+  TRouteDefCollection extends { [routeName: string]: any }
+>(
+  routeDefs: TRouteDefCollection
+): RouteGroup<
+  CoreRouter<TRouteDefCollection>["routes"][keyof TRouteDefCollection][]
+> {
+  const core = coreCreateRouter(routeDefs);
+
+  const group= createGroup_fromItems(
+    Object.values(core.routes)
+  );
+
+  core.stopListening();
+
+  return group;
+}
+
+export function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;
+export function createGroup<
+  TRouteDefCollection extends { [routeName: string]: any }
+>(
+  routeDefs: TRouteDefCollection
+): RouteGroup<
+  CoreRouter<TRouteDefCollection>["routes"][keyof TRouteDefCollection][]
+>;
+export function createGroup(
+  arg: any[] | Record<string, unknown>
+): RouteGroup<any> {
+  return arg instanceof Array
+    ? createGroup_fromItems(arg)
+    : createGroup_fromRouteDefs(arg);
+}
+
+
diff --git a/node_modules/type-route/src/createRouter.ts b/node_modules/type-route/src/createRouter.ts
index ad0292a..4786626 100644
--- a/node_modules/type-route/src/createRouter.ts
+++ b/node_modules/type-route/src/createRouter.ts
@@ -87,9 +87,8 @@ export function createRouter(...args: any[]): UmbrellaCoreRouter {
 
   const routes = createRouteBuilderCollection(getRouterContext);
 
-  const router: UmbrellaCoreRouter = {
-    routes,
-    session: {
+  const session: UmbrellaCoreRouter["session"] = {
+
       push(href, state) {
         if (__DEV__) {
           assert("[RouterSessionHistory].push", [
@@ -213,7 +212,26 @@ export function createRouter(...args: any[]): UmbrellaCoreRouter {
         };
       },
       listen: (handler) => navigationHandlerManager.add(handler),
-    },
+
+  };
+
+  const { getRoute } = (() => {
+    let route_current = session.getInitialRoute();
+
+    session.listen(route => (route_current = route));
+
+    function getRoute() {
+        return route_current;
+    }
+
+    return { getRoute };
+  })();
+
+  const router: UmbrellaCoreRouter = {
+    routes,
+    session,
+    stopListening: ()=> unlisten?.(),
+    getRoute
   };
 
   return router;
@@ -297,7 +315,9 @@ export function createRouter(...args: any[]): UmbrellaCoreRouter {
       handler(route);
     }
 
-    attemptScrollToTop(route, opts.scrollToTop);
+    if( opts.scrollToTop === true){
+      attemptScrollToTop(route);
+    }
 
     previousRoute = route;
   }
diff --git a/node_modules/type-route/src/react.ts b/node_modules/type-route/src/react.ts
index 2682db5..0f76791 100644
--- a/node_modules/type-route/src/react.ts
+++ b/node_modules/type-route/src/react.ts
@@ -1,7 +1,6 @@
 import {
   CoreRouter,
   UmbrellaRouteDefCollection,
-  UmbrellaRoute,
   RouteDefCollectionRoute,
   RouterOpts,
 } from "./types";
@@ -9,6 +8,12 @@ import { createRouter as coreCreateRouter, parseArgs } from "./createRouter";
 import { TypeRouteError } from "./TypeRouteError";
 import * as React from "react";
 import { attemptScrollToTop } from "./attemptScrollToTop";
+import type { UnionToIntersection } from "./tools/UnionToIntersection";
+
+import * as types from "./types";
+
+export type { types };
+export { coreCreateRouter };
 
 if (typeof __DEV__ === "boolean" && __DEV__) {
   const [major, minor] = React.version
@@ -35,23 +40,37 @@ export {
 } from "./types";
 
 type Router<TRouteDefCollection extends { [routeName: string]: any }> =
-  CoreRouter<TRouteDefCollection> & {
+  Omit<CoreRouter<TRouteDefCollection>, "stopListening"> & {
     /**
      * React hook for retrieving the current route.
      *
      * @see https://type-route.zilch.dev/api-reference/router/use-route
      */
     useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;
-
-    /**
-     * React component which connects React to Type Route and provides the current route to the rest of the application.
-     *
-     * @see https://type-route.zilch.dev/api-reference/router/route-provider
-     */
-    RouteProvider: (props: { children?: any }) => any;
   };
 type UmbrellaRouter = Router<UmbrellaRouteDefCollection>;
 
+export function mergeRouteDefs<
+  TPageCollection extends { [pageName: string]: { routeDefs: { [routeName: string]: any } } }
+>(
+  params: { pages: TPageCollection; }
+): { routeDefs: UnionToIntersection<TPageCollection[keyof TPageCollection]["routeDefs"]> }{
+
+  const { pages } = params;
+
+  const routeDefs = {};
+
+  Object.keys(pages).forEach((pageName) =>
+    Object.assign(routeDefs, pages[pageName].routeDefs)
+  );
+
+  // @ts-expect-error
+  return { routeDefs };
+}
+
+// NOTE: For HMR, we want stable reference.  
+let router: UmbrellaRouter | undefined = undefined;
+
 export function createRouter<
   TRouteDefCollection extends { [routeName: string]: any }
 >(routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;
@@ -62,41 +81,48 @@ export function createRouter<
   routeDefs: TRouteDefCollection
 ): Router<TRouteDefCollection>;
 export function createRouter(...args: any[]): UmbrellaRouter {
+  if (router !== undefined) {
+    return router;
+  }
+
   const { opts, routeDefs } = parseArgs(args);
-  const router = coreCreateRouter({ ...opts, scrollToTop: false }, routeDefs);
-  const routeContext = React.createContext<UmbrellaRoute | null>(null);
+  const { routes, session, getRoute } = coreCreateRouter(
+    { ...opts, scrollToTop: false },
+    routeDefs
+  );
 
-  return {
-    ...router,
-    RouteProvider,
-    useRoute,
-  };
+  let effect: (() => void) | undefined = undefined;
+
+  if (opts.scrollToTop === true) {
+    session.listen((route) => {
+      effect = () => {
+        effect = undefined;
+        attemptScrollToTop(route);
+      };
+    });
+  }
+
+  function useRoute() {
+    const route = getRoute();
 
-  function RouteProvider(props: { children?: any }) {
-    const [route, setRoute] = React.useState(router.session.getInitialRoute());
+    const [, reRender] = React.useReducer((count) => count + 1, 0);
 
-    React.useLayoutEffect(() => router.session.listen(setRoute), []);
+    React.useLayoutEffect(() => session.listen(() => reRender()), []);
 
     React.useEffect(() => {
-      attemptScrollToTop(route, opts.scrollToTop);
+      effect?.();
     }, [route]);
 
-    return React.createElement(
-      routeContext.Provider,
-      { value: route },
-      props.children
-    );
+    return route;
   }
 
-  function useRoute() {
-    const route = React.useContext(routeContext);
-
-    if (__DEV__) {
-      if (route === null) {
-        throw TypeRouteError.App_should_be_wrapped_in_a_RouteProvider_component.create();
-      }
-    }
+  router = {
+    routes,
+    session,
+    getRoute,
+    useRoute,
+  };
 
-    return route!;
-  }
+  return router;
 }
+
diff --git a/node_modules/type-route/src/tools/UnionToIntersection.ts b/node_modules/type-route/src/tools/UnionToIntersection.ts
new file mode 100644
index 0000000..1e83af3
--- /dev/null
+++ b/node_modules/type-route/src/tools/UnionToIntersection.ts
@@ -0,0 +1,3 @@
+
+/** @see <https://docs.tsafe.dev/uniontointersection> **/
+export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ( k: infer I,) => void ? I : never;
\ No newline at end of file
diff --git a/node_modules/type-route/src/types.ts b/node_modules/type-route/src/types.ts
index d0976f1..e1e126d 100644
--- a/node_modules/type-route/src/types.ts
+++ b/node_modules/type-route/src/types.ts
@@ -570,6 +570,10 @@ export type CoreRouter<
   };
 
   session: RouterSession<TRouteDefCollection>;
+
+  stopListening: ()=> void;
+
+  getRoute: ()=> RouteDefCollectionRoute<TRouteDefCollection>
 };
 
 export type UmbrellaCoreRouter = CoreRouter<UmbrellaRouteDefCollection>;
