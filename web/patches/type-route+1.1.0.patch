diff --git a/node_modules/type-route/core/index.d.ts b/node_modules/type-route/core/index.d.ts
index 6fc2dab..2353808 100644
--- a/node_modules/type-route/core/index.d.ts
+++ b/node_modules/type-route/core/index.d.ts
@@ -372,6 +372,8 @@ declare type CoreRouter<TRouteDefCollection extends {
         [TRouteName in keyof TRouteDefCollection]: RouteBuilder<TRouteName, TRouteDefCollection[TRouteName]["~internal"]["params"]>;
     };
     session: RouterSession<TRouteDefCollection>;
+    stopListening: () => void;
+    getRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;
 };
 declare type RouteGroup<T extends any[] = any[]> = {
     ["~internal"]: {
@@ -1490,6 +1492,9 @@ declare const param: {
 };
 
 declare function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;
+declare function createGroup<TRouteDefCollection extends {
+    [routeName: string]: any;
+}>(routeDefs: TRouteDefCollection): RouteGroup<CoreRouter<TRouteDefCollection>["routes"][keyof TRouteDefCollection][]>;
 
 declare function preventDefaultLinkClickBehavior(event?: any): boolean;
 
diff --git a/node_modules/type-route/core/tools/createForwardingProxy.d.ts b/node_modules/type-route/core/tools/createForwardingProxy.d.ts
new file mode 100644
index 0000000..36c6a31
--- /dev/null
+++ b/node_modules/type-route/core/tools/createForwardingProxy.d.ts
@@ -0,0 +1,11 @@
+/**
+ * Creates a proxy that forwards EVERYTHING to the current target.
+ * The proxy has a stable identity, and you can update the target at runtime.
+ */
+export declare function createForwardingProxy<T extends object>(params: {
+    accessBeforeSetErrorMessage?: string;
+    isFunction: boolean;
+}): {
+    proxy: T;
+    updateTarget(newTarget: T): void;
+};
diff --git a/node_modules/type-route/core/type-route.cjs.development.js b/node_modules/type-route/core/type-route.cjs.development.js
index 4770c08..2fa81e2 100644
--- a/node_modules/type-route/core/type-route.cjs.development.js
+++ b/node_modules/type-route/core/type-route.cjs.development.js
@@ -1271,95 +1271,113 @@ function createRouter() {
   var blockerCollection = [];
   applySessionOpts(opts.session);
   var routes = createRouteBuilderCollection(getRouterContext);
-  var router = {
-    routes: routes,
-    session: {
-      push: function push(href, state) {
-        {
-          assert("[RouterSessionHistory].push", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
-        }
-        var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),
-          route = _getRouteByHref.route,
-          primaryPath = _getRouteByHref.primaryPath;
-        return navigate(_extends({}, route, {
-          action: "push"
-        }), primaryPath);
-      },
-      replace: function replace(href, state) {
-        {
-          assert("[RouterSessionHistory].replace", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
-        }
-        var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),
-          route = _getRouteByHref2.route,
-          primaryPath = _getRouteByHref2.primaryPath;
-        return navigate(_extends({}, route, {
-          action: "replace"
-        }), primaryPath);
-      },
-      back: function back(amount) {
-        if (amount === void 0) {
-          amount = 1;
-        }
-        {
-          assert("[RouterSessionHistory].back", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
-        }
-        history$1.go(-amount);
-      },
-      forward: function forward(amount) {
-        if (amount === void 0) {
-          amount = 1;
-        }
-        {
-          assert("[RouterSessionHistory].forward", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
-        }
-        history$1.go(amount);
-      },
-      getInitialRoute: function getInitialRoute() {
-        {
-          assert("[RouterSessionHistory].getInitialRoute", [assert.numArgs([].slice.call(arguments), 0)]);
-        }
-        if (!initialRoute) {
-          var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history$1.location, baseUrl), getRouterContext());
-          if (!result.primaryPath) {
-            skipHandlingNextApplicationTriggeredNavigation = true;
-            result.route.replace();
-            result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history$1.location, baseUrl), getRouterContext());
-          }
-          initialRoute = result.route;
-        }
-        return initialRoute;
-      },
-      reset: function reset(session) {
-        {
-          assert("[RouterSessionHistory].reset", [assert.numArgs([].slice.call(arguments), 1), assert.type("object", "session", session)]);
+  var session = {
+    push: function push(href, state) {
+      {
+        assert("[RouterSessionHistory].push", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
+      }
+      var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),
+        route = _getRouteByHref.route,
+        primaryPath = _getRouteByHref.primaryPath;
+      return navigate(_extends({}, route, {
+        action: "push"
+      }), primaryPath);
+    },
+    replace: function replace(href, state) {
+      {
+        assert("[RouterSessionHistory].replace", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
+      }
+      var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),
+        route = _getRouteByHref2.route,
+        primaryPath = _getRouteByHref2.primaryPath;
+      return navigate(_extends({}, route, {
+        action: "replace"
+      }), primaryPath);
+    },
+    back: function back(amount) {
+      if (amount === void 0) {
+        amount = 1;
+      }
+      {
+        assert("[RouterSessionHistory].back", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
+      }
+      history$1.go(-amount);
+    },
+    forward: function forward(amount) {
+      if (amount === void 0) {
+        amount = 1;
+      }
+      {
+        assert("[RouterSessionHistory].forward", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
+      }
+      history$1.go(amount);
+    },
+    getInitialRoute: function getInitialRoute() {
+      {
+        assert("[RouterSessionHistory].getInitialRoute", [assert.numArgs([].slice.call(arguments), 0)]);
+      }
+      if (!initialRoute) {
+        var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history$1.location, baseUrl), getRouterContext());
+        if (!result.primaryPath) {
+          skipHandlingNextApplicationTriggeredNavigation = true;
+          result.route.replace();
+          result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history$1.location, baseUrl), getRouterContext());
         }
-        return applySessionOpts(session);
-      },
-      block: function block(blocker) {
-        blockerCollection.push(blocker);
-        var unblock = history$1.block(function (update) {
-          var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),
-            route = _getMatchingRoute2.route;
-          var action = update.action.toLowerCase();
-          blocker({
-            route: _extends({}, route, {
-              action: action
-            }),
-            retry: update.retry
-          });
-        });
-        return function () {
-          blockerCollection.splice(blockerCollection.findIndex(function (item) {
-            return item === blocker;
-          }), 1);
-          unblock();
-        };
-      },
-      listen: function listen(handler) {
-        return navigationHandlerManager.add(handler);
+        initialRoute = result.route;
       }
+      return initialRoute;
+    },
+    reset: function reset(session) {
+      {
+        assert("[RouterSessionHistory].reset", [assert.numArgs([].slice.call(arguments), 1), assert.type("object", "session", session)]);
+      }
+      return applySessionOpts(session);
+    },
+    block: function block(blocker) {
+      blockerCollection.push(blocker);
+      var unblock = history$1.block(function (update) {
+        var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),
+          route = _getMatchingRoute2.route;
+        var action = update.action.toLowerCase();
+        blocker({
+          route: _extends({}, route, {
+            action: action
+          }),
+          retry: update.retry
+        });
+      });
+      return function () {
+        blockerCollection.splice(blockerCollection.findIndex(function (item) {
+          return item === blocker;
+        }), 1);
+        unblock();
+      };
+    },
+    listen: function listen(handler) {
+      return navigationHandlerManager.add(handler);
     }
   };
+  var _ref = function () {
+      var route_current = session.getInitialRoute();
+      session.listen(function (route) {
+        return route_current = route;
+      });
+      function getRoute() {
+        return route_current;
+      }
+      return {
+        getRoute: getRoute
+      };
+    }(),
+    getRoute = _ref.getRoute;
+  var router = {
+    routes: routes,
+    session: session,
+    stopListening: function stopListening() {
+      return unlisten == null ? void 0 : unlisten();
+    },
+    getRoute: getRoute
+  };
   return router;
   function applySessionOpts(sessionOpts) {
     if (sessionOpts === void 0) {
@@ -1702,7 +1720,7 @@ function getParamDefKindSection(kind, trailing) {
   }
 }
 
-function createGroup(groupItems) {
+function createGroup_fromItems(groupItems) {
   {
     assert("createGroup", [assert.numArgs([].slice.call(arguments), 1), assert.arrayOfType(["RouteGroup", "RouteBuilder"], "groupItems", groupItems)]);
   }
@@ -1736,6 +1754,15 @@ function createGroup(groupItems) {
 function isRouteGroup(value) {
   return !!value.routeNames;
 }
+function createGroup_fromRouteDefs(routeDefs) {
+  var core = createRouter(routeDefs);
+  var group = createGroup_fromItems(Object.values(core.routes));
+  core.stopListening();
+  return group;
+}
+function createGroup(arg) {
+  return arg instanceof Array ? createGroup_fromItems(arg) : createGroup_fromRouteDefs(arg);
+}
 
 exports.createGroup = createGroup;
 exports.createRouter = createRouter;
diff --git a/node_modules/type-route/core/type-route.cjs.development.js.map b/node_modules/type-route/core/type-route.cjs.development.js.map
index 7335a30..c079fa7 100644
--- a/node_modules/type-route/core/type-route.cjs.development.js.map
+++ b/node_modules/type-route/core/type-route.cjs.development.js.map
@@ -1 +1 @@
-{"version":3,"file":"type-route.cjs.development.js","sources":["../src/typeOf.ts","../src/TypeRouteError.ts","../src/asArray.ts","../src/assert.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/getStateMatch.ts","../src/getQueryMatch.ts","../src/createMatcher.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  App_should_be_wrapped_in_a_RouteProvider_component: {\n    errorCode: 1020,\n    getDetails() {\n      return [\n        \"Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook.\",\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session: {\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n    },\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n"],"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","App_should_be_wrapped_in_a_RouteProvider_component","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","_loop","_paramDef$Internal$v","paramValue","undefined","urlEncodeDefault","urlEncode","valueSerializer","getValue","valueSerializerId","id","_ret","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","router","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","_opts$arrayFormat3","_getRouterContext","defineRoute","assertDefineRouteOrExtendArgs","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup","groupItems","routeNames","isRouteGroup","has"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"type-route.cjs.development.js","sources":["../src/typeOf.ts","../src/TypeRouteError.ts","../src/asArray.ts","../src/assert.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/getStateMatch.ts","../src/getQueryMatch.ts","../src/createMatcher.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  App_should_be_wrapped_in_a_RouteProvider_component: {\n    errorCode: 1020,\n    getDetails() {\n      return [\n        \"Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook.\",\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const session: UmbrellaCoreRouter[\"session\"] = {\n\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n\n  };\n\n  const { getRoute } = (() => {\n    let route_current = session.getInitialRoute();\n\n    session.listen(route => (route_current = route));\n\n    function getRoute() {\n        return route_current;\n    }\n\n    return { getRoute };\n  })();\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session,\n    stopListening: ()=> unlisten?.(),\n    getRoute\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder, CoreRouter } from \"./types\";\nimport { assert } from \"./assert\";\nimport { createRouter as coreCreateRouter } from \"./createRouter\";\n\nfunction createGroup_fromItems<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n\nexport function createGroup_fromRouteDefs<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n> {\n  const core = coreCreateRouter(routeDefs);\n\n  const group= createGroup_fromItems(\n    Object.values(core.routes)\n  );\n\n  core.stopListening();\n\n  return group;\n}\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;\nexport function createGroup<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n>;\nexport function createGroup(\n  arg: any[] | Record<string, unknown>\n): RouteGroup<any> {\n  return arg instanceof Array\n    ? createGroup_fromItems(arg)\n    : createGroup_fromRouteDefs(arg);\n}\n\n\n"],"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","App_should_be_wrapped_in_a_RouteProvider_component","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","_loop","_paramDef$Internal$v","paramValue","undefined","urlEncodeDefault","urlEncode","valueSerializer","getValue","valueSerializerId","id","_ret","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","route_current","getRoute","router","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","_opts$arrayFormat3","_getRouterContext","defineRoute","assertDefineRouteOrExtendArgs","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup_fromItems","groupItems","routeNames","isRouteGroup","has","createGroup_fromRouteDefs","core","coreCreateRouter","group","values","createGroup","arg"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/type-route/core/type-route.cjs.production.min.js b/node_modules/type-route/core/type-route.cjs.production.min.js
index 3792670..40f4322 100644
--- a/node_modules/type-route/core/type-route.cjs.production.min.js
+++ b/node_modules/type-route/core/type-route.cjs.production.min.js
@@ -1,2 +1,2 @@
-"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var r=require("history");function e(){return(e=Object.assign||function(r){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(r[a]=n[a])}return r}).apply(this,arguments)}function n(r,e){(null==e||e>r.length)&&(e=r.length);for(var n=0,a=new Array(e);n<e;n++)a[n]=r[n];return a}function a(r,e){var a="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(a)return(a=a.call(r)).next.bind(a);if(Array.isArray(r)||(a=function(r,e){if(r){if("string"==typeof r)return n(r,void 0);var a=Object.prototype.toString.call(r).slice(8,-1);return"Object"===a&&r.constructor&&(a=r.constructor.name),"Map"===a||"Set"===a?Array.from(r):"Arguments"===a||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)?n(r,void 0):void 0}}(r))||e&&r&&"number"==typeof r.length){a&&(r=a);var t=0;return function(){return t>=r.length?{done:!0}:{done:!1,value:r[t++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function t(r){return Array.isArray(r)?r:[r]}function i(r){return"${p."+r+"}"}function o(r,e){var n={};return Object.keys(e).forEach((function(a){var t=e[a];t["~internal"].kind===r&&(n[a]=t)})),n}function u(r,e,n){var a=r["~internal"].valueSerializer.stringify(e);return n?encodeURIComponent(a):a}var l={__noMatch:!0},f=function(r,e){for(var n=0;n<e.length;n++)if(e[n]!==r[n])return!1;return!0},c=function(r,e){for(var n=1;n<=e.length;n++)if(e[e.length-n]!==r[r.length-n])return!1;return!0},s=function(r,e){var n=r.split(e);return[n[0],n.slice(1).join(e)]},p=c,m=f;function v(r){for(var n,t=r.object,i=r.paramDefs,o=r.urlEncodeDefault,u=r.arraySeparator,f={},c=Object.keys(i).map((function(r){return e({name:r},i[r])})),s=e({},t),p=function(){var r=n.value,e=t[r.name];if(delete s[r.name],void 0===e)return r["~internal"].optional?"continue":{v:!1};var a=void 0;if(null===e){if(!r["~internal"].array)return r["~internal"].optional?"continue":{v:!1};a=[]}else if(r["~internal"].array){if((a=e.split(u).map((function(e){var n;return r["~internal"].valueSerializer.parse((null!=(n=r["~internal"].valueSerializer.urlEncode)?n:o)?decodeURIComponent(e):e)}))).some((function(r){return r===l})))return r["~internal"].optional?"continue":{v:!1}}else{var i;if((a=r["~internal"].valueSerializer.parse((null!=(i=r["~internal"].valueSerializer.urlEncode)?i:o)?decodeURIComponent(e):e))===l)return r["~internal"].optional?"continue":{v:!1}}f[r.name]=a},m=a(c);!(n=m()).done;){var v=p();if("continue"!==v&&"object"==typeof v)return v.v}return{params:f,numExtraneousParams:Object.keys(s).length}}function d(r){var n=r.pathDefs,a=r.params,t=o("query",a),i=o("state",a),u={};return Object.keys(a).forEach((function(r){var e=a[r];void 0!==e["~internal"].default&&(u[r]=e["~internal"].default)})),function(r){var a=r.routerLocation,o=r.arraySeparator,f=r.queryStringSerializer;if(void 0===a.path)return!1;var c=function(r){for(var n=r.path,a=r.pathDefs,t=r.arraySeparator,i=0;i<a.length;i++){var o=u(a[i]);if(!1!==o)return e({},o,{primaryPath:0===i})}return!1;function u(r){var e={};if("/"===n&&0===r.length)return{params:e,numExtraneousParams:0};var a=n.length>1&&p(n,"/");a&&(n=n.slice(0,n.length-1));for(var i=n.split("/").slice(1),o=function(n){var o,u,f,c=n>=r.length?null:r[n],s=n>=i.length?null:i[n];if(null===c)return{v:!1};if(null===s)return 0==r.length-1-n&&null!=(f=c.namedParamDef)&&f["~internal"].optional?"break":{v:!1};if(null!=(o=c.namedParamDef)&&o["~internal"].trailing&&(s=i.slice(n).join("/")),!m(s,c.leading))return{v:!1};var v=s.slice(c.leading.length);if(!p(v,c.trailing))return{v:!1};var d=v.slice(0,v.length-c.trailing.length);if(!c.namedParamDef)return""===d?"continue":{v:!1};if(""===d)return c.namedParamDef["~internal"].optional?"continue":{v:!1};var y=null!=(u=c.namedParamDef["~internal"].valueSerializer.urlEncode)?u:!c.namedParamDef["~internal"].trailing,h=void 0;if(c.namedParamDef["~internal"].array){if((h=d.split(t).map((function(r){var e;return null==(e=c.namedParamDef)?void 0:e["~internal"].valueSerializer.parse(y?decodeURIComponent(r):r)}))).some((function(r){return r===l})))return{v:!1}}else if((h=c.namedParamDef["~internal"].valueSerializer.parse(y?decodeURIComponent(d):d))===l)return{v:!1};return c.namedParamDef["~internal"].trailing&&a&&""===c.trailing&&(h+="/"),e[c.namedParamDef.paramName]=h,c.namedParamDef["~internal"].trailing?"break":void 0},u=0;u<Math.max(r.length,i.length);u++){var f=o(u);if("break"===f)break;if("continue"!==f&&"object"==typeof f)return f.v}return{params:e,numExtraneousParams:0}}}({path:a.path,pathDefs:n,arraySeparator:o});if(!1===c)return!1;var s=function(r,e,n,a){var t={};return r&&(t=n.parse(r)),v({object:t,paramDefs:e,urlEncodeDefault:!0,arraySeparator:a})}(a.query,t,f,o);if(!1===s)return!1;var d=function(r,e,n){return v({object:null!=r?r:{},paramDefs:e,urlEncodeDefault:!1,arraySeparator:n})}(a.state,i,o);return!1!==d&&{primaryPath:c.primaryPath,params:e({},u,c.params,s.params,d.params),numExtraneousParams:c.numExtraneousParams+s.numExtraneousParams+d.numExtraneousParams}}}function y(r){return void 0===r&&(r={}),!(r.target&&r.target.target&&"_self"!==r.target.target||r.defaultPrevented||0!==r.button||r.metaKey||r.altKey||r.ctrlKey||r.shiftKey||(r&&r.preventDefault&&r.preventDefault(),0))}var h=f;function g(r){var n=r.routeName,a=r.params,t=r.location,i=r.routerContext,o=i.navigate,u=i.history.createHref({pathname:!1===n?t.fullPath:t.path,search:t.query?"?"+t.query:""});h(u,"#")&&(u="/"+u),!1!==n&&"/"!==i.baseUrl&&(u=i.baseUrl+u);var l={name:n,params:a,href:u,link:{href:u,onClick:function(r){if(y(r))return l.push()}},action:null,push:function(){return o(e({},l,{action:"push"}),!0)},replace:function(){return o(e({},l,{action:"replace"}),!0)}};return l}function S(r,n,l){var f,c,s,p,m=(f=o("path",n["~internal"].params),c=n["~internal"].path,s=Object.keys(f).map((function(r){return e({paramName:r},f[r])})),p={},s.forEach((function(r){var e=r.paramName;p[e]=i(e)})),t(c(p)).map((function(r){if(1===r.length)return[];for(var e,n=r.split("/").slice(1),t={},o=[],u=a(n);!(e=u()).done;){for(var l,f=e.value,c=null,p=a(s);!(l=p()).done;){var m=l.value;f.indexOf(i(m.paramName))>=0&&(c=m,t[m.paramName]=!0)}if(c){var v=f.split(i(c.paramName));o.push({leading:v[0],trailing:v[1],namedParamDef:c})}else o.push({leading:f,trailing:"",namedParamDef:null})}return s.map((function(r){return r.paramName})).filter((function(r){return!t[r]})),o}))),v=function(a){void 0===a&&(a={});var t=l(),i=t.arraySeparator,o=t.queryStringSerializer,f=t.baseUrl,c=e({},a);Object.keys(n["~internal"].params).forEach((function(r){var e=n["~internal"].params[r];void 0===c[r]&&void 0!==e["~internal"].default&&(c[r]=e["~internal"].default)}));var s=function(r){var n=r.paramCollection,a=r.paramDefCollection,t=r.arraySeparator,i=r.queryStringSerializer,o=r.pathDefs,l=r.baseUrl,f={path:{},query:{},state:{}},c=function(r){var e,i=n[r];if(void 0===i)return"continue";var o=a[r],l=null!=(e=o["~internal"].valueSerializer.urlEncode)?e:"state"!==o["~internal"].kind&&!o["~internal"].trailing,c=function(r){return o["~internal"].array?0===r.length?null:r.map((function(r){return u(o,r,l)})).join(t):u(o,r,l)},s=c(i);if("query"===o["~internal"].kind&&void 0!==o["~internal"].default&&c(o["~internal"].default)===s)return"continue";f[o["~internal"].kind][r]={valueSerializerId:o["~internal"].valueSerializer.id,array:o["~internal"].array,value:s}};for(var s in a)c(s);var p="/"+o[0].filter((function(r){var e=r.namedParamDef;return!(null!=e&&e["~internal"].optional&&void 0===f.path[e.paramName])})).map((function(r){var e=r.namedParamDef;return r.leading+(e?f.path[e.paramName].value:"")+r.trailing})).join("/");return{fullPath:("/"===l?"":l)+p,path:p,query:Object.keys(f.query).length>0?i.stringify(f.query):void 0,state:0===Object.keys(f.state).length?void 0:Object.keys(f.state).reduce((function(r,n){var a;return e({},r,((a={})[n]=f.state[n].value,a))}),{})}}({paramCollection:a,paramDefCollection:n["~internal"].params,arraySeparator:i,queryStringSerializer:o,pathDefs:m,baseUrl:f});return g({routeName:r,params:c,location:s,routerContext:t})};return Object.defineProperty(v,"name",{value:r}),v["~internal"]={type:"RouteBuilder",match:d({pathDefs:m,params:n["~internal"].params}),pathDefs:m,Route:null},v}function b(r){var e,n;void 0===r&&(r={});var t=null!=(e=r.queryStringArrayFormat)?e:"singleKeyWithBracket",i=null!=(n=r.arraySeparator)?n:",",o="multiKey"===t||"multiKeyWithBracket"===t,u="multiKey"===t||"singleKey"===t?"":"[]";return{parse:function(r){for(var e,n={},t=a(r.split("&"));!(e=t()).done;){var l=e.value.split("="),f=l[0],s=l[1],p=l.slice(2);if(!(void 0===f||p.length>0)){var m=decodeURIComponent(c(f,u)?f.slice(0,f.length-u.length):f);void 0===s?n[m]=null:n[m]&&o?n[m]+=""+i+s:n[m]=s}}return n},stringify:function(r){return Object.keys(r).map((function(e){var n=encodeURIComponent(e),a=r[e].array?""+n+u:n,t=r[e].value;return null===t?a:r[e].array&&o?t.split(i).map((function(r){return a+"="+r})).join("&"):a+"="+t})).join("&")}}}function P(r,n){var a=n.queryStringSerializer,t=n.arraySeparator,i=(0,n.getRoutes)(),o=!1;for(var u in i){var l=i[u]["~internal"].match({routerLocation:r,queryStringSerializer:a,arraySeparator:t});if(!1!==l){if(0===l.numExtraneousParams)return{route:i[u](l.params),primaryPath:l.primaryPath};(!1===o||l.numExtraneousParams<o.numExtraneousParams)&&(o=e({},l,{routeName:u}))}}return o?{route:i[o.routeName](o.params),primaryPath:o.primaryPath}:{route:g({routeName:!1,params:{},location:r,routerContext:n}),primaryPath:!0}}var D=f;function j(r,e){return{fullPath:r.pathname,path:D(r.pathname,e)?"/"!==e?r.pathname.replace(e,""):r.pathname:void 0,query:r.search?D(r.search,"?")?r.search.slice(1):r.search:void 0,state:"object"==typeof r.state&&null!==r.state?r.state.state:void 0}}var k=s;function w(r,e,n){var a=k(r,"?");return P(j({pathname:a[0],search:a[1],state:e},n.baseUrl),n)}function x(r){var e=r.startListening,n=r.stopListening,a=[],t=0;return{add:function(r){var i=t++;return a.push({id:i,handler:r}),1===a.length&&e(),function(){var r=a.map((function(r){return r.id})).indexOf(i);r>=0&&(a.splice(r,1),0===a.length&&n())}},getHandlers:function(){return a.map((function(r){return r.handler}))}}}function O(r,e){if("push"===r.action&&"object"==typeof window&&null!==window&&"function"==typeof window.scroll&&!1!==e&&"object"==typeof navigator&&null!==navigator&&"string"==typeof navigator.userAgent&&!(navigator.userAgent.indexOf("Node.js")>0||navigator.userAgent.indexOf("jsdom")>0))try{window.scroll(0,0)}catch(r){}}function E(r,e){var n={};if(r.name)for(var t,i=a(Object.keys(r.params).sort());!(t=i()).done;){var o=t.value,u=e[r.name]["~internal"].params[o]["~internal"];"state"===u.kind&&(n[o]=u.valueSerializer.stringify(r.params[o]))}return n}var q=s;function z(r){return{routeDefs:1===r.length?r[0]:r[1],opts:1===r.length?{}:r[0]}}function N(r){var e={},n=r().routeDefs;for(var a in n)e[a]=S(a,n[a],r);return e}function C(r){return 1===r.length?{params:{},path:function(){return r[0]}}:{params:r[0],path:r[1]}}var R={id:"boolean",parse:function(r){return"true"===r||"false"!==r&&l},stringify:function(r){return r?"true":"false"}},A={id:"number",parse:function(r){return e=r,isNaN(parseFloat(e))||!/^-?\d*\.?\d*$/.test(e)?l:parseFloat(r);var e},stringify:function(r){return r.toString()}},U={id:"string",parse:function(r){return r},stringify:function(r){return r}},I={path:e({},K("path",!1),{trailing:K("path",!0)}),query:K("query",!1),state:K("state",!1)};function K(r,n){return e({},a(!1,!1),{array:a(!1,!0),optional:e({},a(!0,!1),{array:a(!0,!0)})});function a(e,a){return{string:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:e,valueSerializer:U,trailing:n,default:void 0}}),number:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:e,valueSerializer:A,trailing:n,default:void 0}}),boolean:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:e,valueSerializer:R,trailing:n,default:void 0}}),ofType:function(i){return void 0===i&&(i={id:"json",parse:function(r){var e;try{e=JSON.parse(r)}catch(r){return l}return e},stringify:function(r){return JSON.stringify(r)}}),t({"~internal":{type:"ParamDef",array:a,kind:r,optional:e,valueSerializer:i,trailing:n,default:void 0}})}}}function t(r){var n=r["~internal"];return n.optional?{"~internal":n,default:function(r){return{"~internal":e({},n,{default:r})}}}:{"~internal":n}}}exports.createGroup=function(r){var e={};return r.forEach((function(r){r.routeNames?r.routeNames.forEach((function(r){e[r]=!0})):e[r.name]=!0})),{"~internal":{type:"RouteGroup",Route:null},routeNames:Object.keys(e),has:function(r){return!1!==r.name&&!!e[r.name]}}},exports.createRouter=function(){for(var n,t,i,o,u,l=arguments.length,f=new Array(l),c=0;c<l;c++)f[c]=arguments[c];var s,p,m=z(f),v=m.routeDefs,d=m.opts,y=x({startListening:function(){p=s.listen((function(r){if(D)D=!1;else{var n=j(r.location,h),a=r.action.toLowerCase(),t=P(n,F()),i=t.primaryPath;H(e({},t.route,{action:a}),i)}}))},stopListening:function(){return null==p?void 0:p()}}),h=null!=(n=d.baseUrl)?n:"/",g=null!=(t=null==(i=d.arrayFormat)?void 0:i.separator)?t:",",S=null!=(o=d.queryStringSerializer)?o:b({queryStringArrayFormat:null==(u=d.arrayFormat)?void 0:u.queryString,arraySeparator:g}),D=!1,k=!1,C=null,R=null,A=[];K(d.session);var U=N(F),I={routes:U,session:{push:function(r,n){var a=w(r,n,F()),t=a.primaryPath;return L(e({},a.route,{action:"push"}),t)},replace:function(r,n){var a=w(r,n,F()),t=a.primaryPath;return L(e({},a.route,{action:"replace"}),t)},back:function(r){void 0===r&&(r=1),s.go(-r)},forward:function(r){void 0===r&&(r=1),s.go(r)},getInitialRoute:function(){if(!C){var r=P(j(s.location,h),F());r.primaryPath||(k=!0,r.route.replace(),r=P(j(s.location,h),F())),C=r.route}return C},reset:function(r){return K(r)},block:function(r){A.push(r);var n=s.block((function(n){var a=P(j(n.location,h),F()).route,t=n.action.toLowerCase();r({route:e({},a,{action:t}),retry:n.retry})}));return function(){A.splice(A.findIndex((function(e){return e===r})),1),n()}},listen:function(r){return y.add(r)}}};return I;function K(e){void 0===e&&(e={type:"undefined"!=typeof window&&void 0!==window.document?"browser":"memory"}),C=null,s="memory"===e.type?r.createMemoryHistory({initialEntries:e.initialEntries,initialIndex:e.initialIndex}):"hash"===e.type?r.createHashHistory({window:e.window}):r.createBrowserHistory({window:e.window})}function L(r,e){var n;if(A.length>0)A.forEach((function(e){e({route:r,retry:function(){r["push"===r.action?"push":"replace"]()}})}));else{var a=E(r,v);if((null==(n=R)?void 0:n.href)!==r.href||JSON.stringify(E(R,v))!==JSON.stringify(a)){k?k=!1:H(r,e),D=!0;var t=q(r.href,"?"),i=t[1];s["replace"===r.action?"replace":"push"]({pathname:t[0],search:i?"?"+i:"",hash:""},a?{state:a}:void 0)}}}function H(r,e){if(e){for(var n,t=a(y.getHandlers());!(n=t()).done;)(0,n.value)(r);O(r,d.scrollToTop),R=r}else r.replace()}function F(){return{queryStringSerializer:S,arraySeparator:g,navigate:L,history:s,routeDefs:v,getRoutes:function(){return U},baseUrl:h}}},exports.defineRoute=function r(){for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];var o=C(a),u={"~internal":{type:"RouteDef",params:o.params,path:o.path},extend:function(){for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];var u=C(a),l=u.params,f=u.path,c=Object.keys(o.params),s=Object.keys(l);return c.filter((function(r){return s.indexOf(r)>=0})),r(e({},l,o.params),(function(r){var e,n=t(o.path(i(c))),a=t(f(i(s)));return(e=[]).concat.apply(e,n.map((function(r){return a.map((function(e){return"/"===r?e:r+("/"===e?"":e)}))})));function i(e){var n={};return e.forEach((function(e){n[e]=r[e]})),n}}))}};return u},exports.noMatch=l,exports.param=I,exports.preventDefaultLinkClickBehavior=y;
+"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var r=require("history");function e(){return(e=Object.assign||function(r){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(r[a]=n[a])}return r}).apply(this,arguments)}function n(r,e){(null==e||e>r.length)&&(e=r.length);for(var n=0,a=new Array(e);n<e;n++)a[n]=r[n];return a}function a(r,e){var a="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(a)return(a=a.call(r)).next.bind(a);if(Array.isArray(r)||(a=function(r,e){if(r){if("string"==typeof r)return n(r,void 0);var a=Object.prototype.toString.call(r).slice(8,-1);return"Object"===a&&r.constructor&&(a=r.constructor.name),"Map"===a||"Set"===a?Array.from(r):"Arguments"===a||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)?n(r,void 0):void 0}}(r))||e&&r&&"number"==typeof r.length){a&&(r=a);var t=0;return function(){return t>=r.length?{done:!0}:{done:!1,value:r[t++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function t(r){return Array.isArray(r)?r:[r]}function i(r){return"${p."+r+"}"}function o(r,e){var n={};return Object.keys(e).forEach((function(a){var t=e[a];t["~internal"].kind===r&&(n[a]=t)})),n}function u(r,e,n){var a=r["~internal"].valueSerializer.stringify(e);return n?encodeURIComponent(a):a}var l={__noMatch:!0},f=function(r,e){for(var n=0;n<e.length;n++)if(e[n]!==r[n])return!1;return!0},c=function(r,e){for(var n=1;n<=e.length;n++)if(e[e.length-n]!==r[r.length-n])return!1;return!0},s=function(r,e){var n=r.split(e);return[n[0],n.slice(1).join(e)]},p=c,m=f;function v(r){for(var n,t=r.object,i=r.paramDefs,o=r.urlEncodeDefault,u=r.arraySeparator,f={},c=Object.keys(i).map((function(r){return e({name:r},i[r])})),s=e({},t),p=function(){var r=n.value,e=t[r.name];if(delete s[r.name],void 0===e)return r["~internal"].optional?"continue":{v:!1};var a=void 0;if(null===e){if(!r["~internal"].array)return r["~internal"].optional?"continue":{v:!1};a=[]}else if(r["~internal"].array){if((a=e.split(u).map((function(e){var n;return r["~internal"].valueSerializer.parse((null!=(n=r["~internal"].valueSerializer.urlEncode)?n:o)?decodeURIComponent(e):e)}))).some((function(r){return r===l})))return r["~internal"].optional?"continue":{v:!1}}else{var i;if((a=r["~internal"].valueSerializer.parse((null!=(i=r["~internal"].valueSerializer.urlEncode)?i:o)?decodeURIComponent(e):e))===l)return r["~internal"].optional?"continue":{v:!1}}f[r.name]=a},m=a(c);!(n=m()).done;){var v=p();if("continue"!==v&&"object"==typeof v)return v.v}return{params:f,numExtraneousParams:Object.keys(s).length}}function d(r){var n=r.pathDefs,a=r.params,t=o("query",a),i=o("state",a),u={};return Object.keys(a).forEach((function(r){var e=a[r];void 0!==e["~internal"].default&&(u[r]=e["~internal"].default)})),function(r){var a=r.routerLocation,o=r.arraySeparator,f=r.queryStringSerializer;if(void 0===a.path)return!1;var c=function(r){for(var n=r.path,a=r.pathDefs,t=r.arraySeparator,i=0;i<a.length;i++){var o=u(a[i]);if(!1!==o)return e({},o,{primaryPath:0===i})}return!1;function u(r){var e={};if("/"===n&&0===r.length)return{params:e,numExtraneousParams:0};var a=n.length>1&&p(n,"/");a&&(n=n.slice(0,n.length-1));for(var i=n.split("/").slice(1),o=function(n){var o,u,f,c=n>=r.length?null:r[n],s=n>=i.length?null:i[n];if(null===c)return{v:!1};if(null===s)return 0==r.length-1-n&&null!=(f=c.namedParamDef)&&f["~internal"].optional?"break":{v:!1};if(null!=(o=c.namedParamDef)&&o["~internal"].trailing&&(s=i.slice(n).join("/")),!m(s,c.leading))return{v:!1};var v=s.slice(c.leading.length);if(!p(v,c.trailing))return{v:!1};var d=v.slice(0,v.length-c.trailing.length);if(!c.namedParamDef)return""===d?"continue":{v:!1};if(""===d)return c.namedParamDef["~internal"].optional?"continue":{v:!1};var y=null!=(u=c.namedParamDef["~internal"].valueSerializer.urlEncode)?u:!c.namedParamDef["~internal"].trailing,h=void 0;if(c.namedParamDef["~internal"].array){if((h=d.split(t).map((function(r){var e;return null==(e=c.namedParamDef)?void 0:e["~internal"].valueSerializer.parse(y?decodeURIComponent(r):r)}))).some((function(r){return r===l})))return{v:!1}}else if((h=c.namedParamDef["~internal"].valueSerializer.parse(y?decodeURIComponent(d):d))===l)return{v:!1};return c.namedParamDef["~internal"].trailing&&a&&""===c.trailing&&(h+="/"),e[c.namedParamDef.paramName]=h,c.namedParamDef["~internal"].trailing?"break":void 0},u=0;u<Math.max(r.length,i.length);u++){var f=o(u);if("break"===f)break;if("continue"!==f&&"object"==typeof f)return f.v}return{params:e,numExtraneousParams:0}}}({path:a.path,pathDefs:n,arraySeparator:o});if(!1===c)return!1;var s=function(r,e,n,a){var t={};return r&&(t=n.parse(r)),v({object:t,paramDefs:e,urlEncodeDefault:!0,arraySeparator:a})}(a.query,t,f,o);if(!1===s)return!1;var d=function(r,e,n){return v({object:null!=r?r:{},paramDefs:e,urlEncodeDefault:!1,arraySeparator:n})}(a.state,i,o);return!1!==d&&{primaryPath:c.primaryPath,params:e({},u,c.params,s.params,d.params),numExtraneousParams:c.numExtraneousParams+s.numExtraneousParams+d.numExtraneousParams}}}function y(r){return void 0===r&&(r={}),!(r.target&&r.target.target&&"_self"!==r.target.target||r.defaultPrevented||0!==r.button||r.metaKey||r.altKey||r.ctrlKey||r.shiftKey||(r&&r.preventDefault&&r.preventDefault(),0))}var h=f;function g(r){var n=r.routeName,a=r.params,t=r.location,i=r.routerContext,o=i.navigate,u=i.history.createHref({pathname:!1===n?t.fullPath:t.path,search:t.query?"?"+t.query:""});h(u,"#")&&(u="/"+u),!1!==n&&"/"!==i.baseUrl&&(u=i.baseUrl+u);var l={name:n,params:a,href:u,link:{href:u,onClick:function(r){if(y(r))return l.push()}},action:null,push:function(){return o(e({},l,{action:"push"}),!0)},replace:function(){return o(e({},l,{action:"replace"}),!0)}};return l}function b(r,n,l){var f,c,s,p,m=(f=o("path",n["~internal"].params),c=n["~internal"].path,s=Object.keys(f).map((function(r){return e({paramName:r},f[r])})),p={},s.forEach((function(r){var e=r.paramName;p[e]=i(e)})),t(c(p)).map((function(r){if(1===r.length)return[];for(var e,n=r.split("/").slice(1),t={},o=[],u=a(n);!(e=u()).done;){for(var l,f=e.value,c=null,p=a(s);!(l=p()).done;){var m=l.value;f.indexOf(i(m.paramName))>=0&&(c=m,t[m.paramName]=!0)}if(c){var v=f.split(i(c.paramName));o.push({leading:v[0],trailing:v[1],namedParamDef:c})}else o.push({leading:f,trailing:"",namedParamDef:null})}return s.map((function(r){return r.paramName})).filter((function(r){return!t[r]})),o}))),v=function(a){void 0===a&&(a={});var t=l(),i=t.arraySeparator,o=t.queryStringSerializer,f=t.baseUrl,c=e({},a);Object.keys(n["~internal"].params).forEach((function(r){var e=n["~internal"].params[r];void 0===c[r]&&void 0!==e["~internal"].default&&(c[r]=e["~internal"].default)}));var s=function(r){var n=r.paramCollection,a=r.paramDefCollection,t=r.arraySeparator,i=r.queryStringSerializer,o=r.pathDefs,l=r.baseUrl,f={path:{},query:{},state:{}},c=function(r){var e,i=n[r];if(void 0===i)return"continue";var o=a[r],l=null!=(e=o["~internal"].valueSerializer.urlEncode)?e:"state"!==o["~internal"].kind&&!o["~internal"].trailing,c=function(r){return o["~internal"].array?0===r.length?null:r.map((function(r){return u(o,r,l)})).join(t):u(o,r,l)},s=c(i);if("query"===o["~internal"].kind&&void 0!==o["~internal"].default&&c(o["~internal"].default)===s)return"continue";f[o["~internal"].kind][r]={valueSerializerId:o["~internal"].valueSerializer.id,array:o["~internal"].array,value:s}};for(var s in a)c(s);var p="/"+o[0].filter((function(r){var e=r.namedParamDef;return!(null!=e&&e["~internal"].optional&&void 0===f.path[e.paramName])})).map((function(r){var e=r.namedParamDef;return r.leading+(e?f.path[e.paramName].value:"")+r.trailing})).join("/");return{fullPath:("/"===l?"":l)+p,path:p,query:Object.keys(f.query).length>0?i.stringify(f.query):void 0,state:0===Object.keys(f.state).length?void 0:Object.keys(f.state).reduce((function(r,n){var a;return e({},r,((a={})[n]=f.state[n].value,a))}),{})}}({paramCollection:a,paramDefCollection:n["~internal"].params,arraySeparator:i,queryStringSerializer:o,pathDefs:m,baseUrl:f});return g({routeName:r,params:c,location:s,routerContext:t})};return Object.defineProperty(v,"name",{value:r}),v["~internal"]={type:"RouteBuilder",match:d({pathDefs:m,params:n["~internal"].params}),pathDefs:m,Route:null},v}function S(r){var e,n;void 0===r&&(r={});var t=null!=(e=r.queryStringArrayFormat)?e:"singleKeyWithBracket",i=null!=(n=r.arraySeparator)?n:",",o="multiKey"===t||"multiKeyWithBracket"===t,u="multiKey"===t||"singleKey"===t?"":"[]";return{parse:function(r){for(var e,n={},t=a(r.split("&"));!(e=t()).done;){var l=e.value.split("="),f=l[0],s=l[1],p=l.slice(2);if(!(void 0===f||p.length>0)){var m=decodeURIComponent(c(f,u)?f.slice(0,f.length-u.length):f);void 0===s?n[m]=null:n[m]&&o?n[m]+=""+i+s:n[m]=s}}return n},stringify:function(r){return Object.keys(r).map((function(e){var n=encodeURIComponent(e),a=r[e].array?""+n+u:n,t=r[e].value;return null===t?a:r[e].array&&o?t.split(i).map((function(r){return a+"="+r})).join("&"):a+"="+t})).join("&")}}}function P(r,n){var a=n.queryStringSerializer,t=n.arraySeparator,i=(0,n.getRoutes)(),o=!1;for(var u in i){var l=i[u]["~internal"].match({routerLocation:r,queryStringSerializer:a,arraySeparator:t});if(!1!==l){if(0===l.numExtraneousParams)return{route:i[u](l.params),primaryPath:l.primaryPath};(!1===o||l.numExtraneousParams<o.numExtraneousParams)&&(o=e({},l,{routeName:u}))}}return o?{route:i[o.routeName](o.params),primaryPath:o.primaryPath}:{route:g({routeName:!1,params:{},location:r,routerContext:n}),primaryPath:!0}}var D=f;function j(r,e){return{fullPath:r.pathname,path:D(r.pathname,e)?"/"!==e?r.pathname.replace(e,""):r.pathname:void 0,query:r.search?D(r.search,"?")?r.search.slice(1):r.search:void 0,state:"object"==typeof r.state&&null!==r.state?r.state.state:void 0}}var k=s;function w(r,e,n){var a=k(r,"?");return P(j({pathname:a[0],search:a[1],state:e},n.baseUrl),n)}function x(r){var e=r.startListening,n=r.stopListening,a=[],t=0;return{add:function(r){var i=t++;return a.push({id:i,handler:r}),1===a.length&&e(),function(){var r=a.map((function(r){return r.id})).indexOf(i);r>=0&&(a.splice(r,1),0===a.length&&n())}},getHandlers:function(){return a.map((function(r){return r.handler}))}}}function O(r,e){if("push"===r.action&&"object"==typeof window&&null!==window&&"function"==typeof window.scroll&&!1!==e&&"object"==typeof navigator&&null!==navigator&&"string"==typeof navigator.userAgent&&!(navigator.userAgent.indexOf("Node.js")>0||navigator.userAgent.indexOf("jsdom")>0))try{window.scroll(0,0)}catch(r){}}function E(r,e){var n={};if(r.name)for(var t,i=a(Object.keys(r.params).sort());!(t=i()).done;){var o=t.value,u=e[r.name]["~internal"].params[o]["~internal"];"state"===u.kind&&(n[o]=u.valueSerializer.stringify(r.params[o]))}return n}var q=s;function z(){for(var n,t,i,o,u,l=arguments.length,f=new Array(l),c=0;c<l;c++)f[c]=arguments[c];var s,p,m=N(f),v=m.routeDefs,d=m.opts,y=x({startListening:function(){p=s.listen((function(r){if(D)D=!1;else{var n=j(r.location,h),a=r.action.toLowerCase(),t=P(n,J()),i=t.primaryPath;_(e({},t.route,{action:a}),i)}}))},stopListening:function(){return null==p?void 0:p()}}),h=null!=(n=d.baseUrl)?n:"/",g=null!=(t=null==(i=d.arrayFormat)?void 0:i.separator)?t:",",b=null!=(o=d.queryStringSerializer)?o:S({queryStringArrayFormat:null==(u=d.arrayFormat)?void 0:u.queryString,arraySeparator:g}),D=!1,k=!1,z=null,C=null,A=[];M(d.session);var I,U=R(J),L={push:function(r,n){var a=w(r,n,J()),t=a.primaryPath;return B(e({},a.route,{action:"push"}),t)},replace:function(r,n){var a=w(r,n,J()),t=a.primaryPath;return B(e({},a.route,{action:"replace"}),t)},back:function(r){void 0===r&&(r=1),s.go(-r)},forward:function(r){void 0===r&&(r=1),s.go(r)},getInitialRoute:function(){if(!z){var r=P(j(s.location,h),J());r.primaryPath||(k=!0,r.route.replace(),r=P(j(s.location,h),J())),z=r.route}return z},reset:function(r){return M(r)},block:function(r){A.push(r);var n=s.block((function(n){var a=P(j(n.location,h),J()).route,t=n.action.toLowerCase();r({route:e({},a,{action:t}),retry:n.retry})}));return function(){A.splice(A.findIndex((function(e){return e===r})),1),n()}},listen:function(r){return y.add(r)}},K=(I=L.getInitialRoute(),L.listen((function(r){return I=r})),{getRoute:function(){return I}}),H=K.getRoute,F={routes:U,session:L,stopListening:function(){return null==p?void 0:p()},getRoute:H};return F;function M(e){void 0===e&&(e={type:"undefined"!=typeof window&&void 0!==window.document?"browser":"memory"}),z=null,s="memory"===e.type?r.createMemoryHistory({initialEntries:e.initialEntries,initialIndex:e.initialIndex}):"hash"===e.type?r.createHashHistory({window:e.window}):r.createBrowserHistory({window:e.window})}function B(r,e){var n;if(A.length>0)A.forEach((function(e){e({route:r,retry:function(){r["push"===r.action?"push":"replace"]()}})}));else{var a=E(r,v);if((null==(n=C)?void 0:n.href)!==r.href||JSON.stringify(E(C,v))!==JSON.stringify(a)){k?k=!1:_(r,e),D=!0;var t=q(r.href,"?"),i=t[1];s["replace"===r.action?"replace":"push"]({pathname:t[0],search:i?"?"+i:"",hash:""},a?{state:a}:void 0)}}}function _(r,e){if(e){for(var n,t=a(y.getHandlers());!(n=t()).done;)(0,n.value)(r);O(r,d.scrollToTop),C=r}else r.replace()}function J(){return{queryStringSerializer:b,arraySeparator:g,navigate:B,history:s,routeDefs:v,getRoutes:function(){return U},baseUrl:h}}}function N(r){return{routeDefs:1===r.length?r[0]:r[1],opts:1===r.length?{}:r[0]}}function R(r){var e={},n=r().routeDefs;for(var a in n)e[a]=b(a,n[a],r);return e}function C(r){return 1===r.length?{params:{},path:function(){return r[0]}}:{params:r[0],path:r[1]}}var A={id:"boolean",parse:function(r){return"true"===r||"false"!==r&&l},stringify:function(r){return r?"true":"false"}},I={id:"number",parse:function(r){return e=r,isNaN(parseFloat(e))||!/^-?\d*\.?\d*$/.test(e)?l:parseFloat(r);var e},stringify:function(r){return r.toString()}},U={id:"string",parse:function(r){return r},stringify:function(r){return r}},L={path:e({},K("path",!1),{trailing:K("path",!0)}),query:K("query",!1),state:K("state",!1)};function K(r,n){return e({},a(!1,!1),{array:a(!1,!0),optional:e({},a(!0,!1),{array:a(!0,!0)})});function a(e,a){return{string:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:e,valueSerializer:U,trailing:n,default:void 0}}),number:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:e,valueSerializer:I,trailing:n,default:void 0}}),boolean:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:e,valueSerializer:A,trailing:n,default:void 0}}),ofType:function(i){return void 0===i&&(i={id:"json",parse:function(r){var e;try{e=JSON.parse(r)}catch(r){return l}return e},stringify:function(r){return JSON.stringify(r)}}),t({"~internal":{type:"ParamDef",array:a,kind:r,optional:e,valueSerializer:i,trailing:n,default:void 0}})}}}function t(r){var n=r["~internal"];return n.optional?{"~internal":n,default:function(r){return{"~internal":e({},n,{default:r})}}}:{"~internal":n}}}function H(r){var e={};return r.forEach((function(r){r.routeNames?r.routeNames.forEach((function(r){e[r]=!0})):e[r.name]=!0})),{"~internal":{type:"RouteGroup",Route:null},routeNames:Object.keys(e),has:function(r){return!1!==r.name&&!!e[r.name]}}}exports.createGroup=function(r){return r instanceof Array?H(r):(e=z(r),n=H(Object.values(e.routes)),e.stopListening(),n);var e,n},exports.createRouter=z,exports.defineRoute=function r(){for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];var o=C(a),u={"~internal":{type:"RouteDef",params:o.params,path:o.path},extend:function(){for(var n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];var u=C(a),l=u.params,f=u.path,c=Object.keys(o.params),s=Object.keys(l);return c.filter((function(r){return s.indexOf(r)>=0})),r(e({},l,o.params),(function(r){var e,n=t(o.path(i(c))),a=t(f(i(s)));return(e=[]).concat.apply(e,n.map((function(r){return a.map((function(e){return"/"===r?e:r+("/"===e?"":e)}))})));function i(e){var n={};return e.forEach((function(e){n[e]=r[e]})),n}}))}};return u},exports.noMatch=l,exports.param=L,exports.preventDefaultLinkClickBehavior=y;
 //# sourceMappingURL=type-route.cjs.production.min.js.map
diff --git a/node_modules/type-route/core/type-route.cjs.production.min.js.map b/node_modules/type-route/core/type-route.cjs.production.min.js.map
index d4cc01d..426fd7b 100644
--- a/node_modules/type-route/core/type-route.cjs.production.min.js.map
+++ b/node_modules/type-route/core/type-route.cjs.production.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"type-route.cjs.production.min.js","sources":["../src/asArray.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/createMatcher.ts","../src/getQueryMatch.ts","../src/getStateMatch.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts"],"sourcesContent":["export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session: {\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n    },\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n"],"names":["asArray","value","Array","isArray","getParamId","parameterName","getParamDefsOfType","type","paramDefCollection","filteredParamDefCollection","Object","keys","forEach","name","paramDef","kind","stringify","urlEncode","result","valueSerializer","encodeURIComponent","noMatch","__noMatch","stringUtils","start","i","length","end","split","_value$split","slice","join","endsWith","startsWith","getObjectMatch","_ref","_step","object","paramDefs","urlEncodeDefault","arraySeparator","params","namedParamDefs","map","_extends","extraneousParams","_loop","raw","undefined","optional","v","array","part","parse","_paramDef$Internal$v","decodeURIComponent","some","_paramDef$Internal$v2","_iterator","_createForOfIteratorHelperLoose","done","_ret","numExtraneousParams","createMatcher","pathDefs","queryParamDefCollection","stateParamDefCollection","defaultParams","paramName","param","_ref2","routerLocation","queryStringSerializer","path","pathMatch","index","match","primaryPath","pathDef","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","_pathSegmentDef$named","pathSegmentDef","pathSegment","namedParamDef","trailing","leading","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","Math","max","getPathMatch","queryMatch","query","getQueryMatch","stateMatch","state","getStateMatch","preventDefaultLinkClickBehavior","event","target","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","preventDefault","buildRoute","routeName","location","routerContext","navigate","href","history","createHref","pathname","fullPath","search","baseUrl","route","link","onClick","push","action","replace","createRouteBuilder","routeDef","getRouterContext","pathParamDefCollection","getRawPath","namedPathParamDefs","paramIdCollection","rawPath","rawPathSegments","usedPathParams","_step2","rawSegment","includedParamDef","_iterator2","indexOf","_rawSegment$split","filter","build","paramsWithDefault","paramCollection","paramValue","getValue","valueSerializerId","id","_ref3","reduce","key","_extends2","createLocation","defineProperty","Route","createQueryStringSerializer","args","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","rest","encodedName","getMatchingRoute","routes","getRoutes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","splitFirst","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","handler","splice","getHandlers","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sort","parseArgs","opts","createRouteBuilderCollection","boolean","number","isNaN","parseFloat","test","toString","string","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","~internal","default","ofType","JSON","internal","groupItems","routeNames","item","has","_len","_key","arguments","unlisten","_parseArgs","navigationHandlerManager","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","router","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","retry","findIndex","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","defineRoute","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","x","parentPathArray","childPathArray","concat","apply","parentPath","childPath","allowedKeys","filteredX"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"type-route.cjs.production.min.js","sources":["../src/asArray.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/createMatcher.ts","../src/getQueryMatch.ts","../src/getStateMatch.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts"],"sourcesContent":["export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const session: UmbrellaCoreRouter[\"session\"] = {\n\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n\n  };\n\n  const { getRoute } = (() => {\n    let route_current = session.getInitialRoute();\n\n    session.listen(route => (route_current = route));\n\n    function getRoute() {\n        return route_current;\n    }\n\n    return { getRoute };\n  })();\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session,\n    stopListening: ()=> unlisten?.(),\n    getRoute\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder, CoreRouter } from \"./types\";\nimport { assert } from \"./assert\";\nimport { createRouter as coreCreateRouter } from \"./createRouter\";\n\nfunction createGroup_fromItems<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n\nexport function createGroup_fromRouteDefs<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n> {\n  const core = coreCreateRouter(routeDefs);\n\n  const group= createGroup_fromItems(\n    Object.values(core.routes)\n  );\n\n  core.stopListening();\n\n  return group;\n}\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;\nexport function createGroup<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n>;\nexport function createGroup(\n  arg: any[] | Record<string, unknown>\n): RouteGroup<any> {\n  return arg instanceof Array\n    ? createGroup_fromItems(arg)\n    : createGroup_fromRouteDefs(arg);\n}\n\n\n"],"names":["asArray","value","Array","isArray","getParamId","parameterName","getParamDefsOfType","type","paramDefCollection","filteredParamDefCollection","Object","keys","forEach","name","paramDef","kind","stringify","urlEncode","result","valueSerializer","encodeURIComponent","noMatch","__noMatch","stringUtils","start","i","length","end","split","_value$split","slice","join","endsWith","startsWith","getObjectMatch","_ref","_step","object","paramDefs","urlEncodeDefault","arraySeparator","params","namedParamDefs","map","_extends","extraneousParams","_loop","raw","undefined","optional","v","array","part","parse","_paramDef$Internal$v","decodeURIComponent","some","_paramDef$Internal$v2","_iterator","_createForOfIteratorHelperLoose","done","_ret","numExtraneousParams","createMatcher","pathDefs","queryParamDefCollection","stateParamDefCollection","defaultParams","paramName","param","_ref2","routerLocation","queryStringSerializer","path","pathMatch","index","match","primaryPath","pathDef","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","_pathSegmentDef$named","pathSegmentDef","pathSegment","namedParamDef","trailing","leading","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","Math","max","getPathMatch","queryMatch","query","getQueryMatch","stateMatch","state","getStateMatch","preventDefaultLinkClickBehavior","event","target","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","preventDefault","buildRoute","routeName","location","routerContext","navigate","href","history","createHref","pathname","fullPath","search","baseUrl","route","link","onClick","push","action","replace","createRouteBuilder","routeDef","getRouterContext","pathParamDefCollection","getRawPath","namedPathParamDefs","paramIdCollection","rawPath","rawPathSegments","usedPathParams","_step2","rawSegment","includedParamDef","_iterator2","indexOf","_rawSegment$split","filter","build","paramsWithDefault","paramCollection","paramValue","getValue","valueSerializerId","id","_ref3","reduce","key","_extends2","createLocation","defineProperty","Route","createQueryStringSerializer","args","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","rest","encodedName","getMatchingRoute","routes","getRoutes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","splitFirst","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","handler","splice","getHandlers","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sort","createRouter","_len","_key","arguments","unlisten","_parseArgs","parseArgs","opts","navigationHandlerManager","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","route_current","createRouteBuilderCollection","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","retry","findIndex","item","getRoute","router","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","JSON","hash","boolean","number","isNaN","parseFloat","test","toString","string","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","~internal","default","ofType","internal","createGroup_fromItems","groupItems","routeNames","has","arg","core","coreCreateRouter","group","values","defineRoute","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","x","parentPathArray","childPathArray","concat","apply","parentPath","childPath","allowedKeys","filteredX"],"mappings":"qnCAAgBA,EAAWC,GACzB,OAAOC,MAAMC,QAAQF,GAASA,EAAQ,CAACA,GC4OzC,SAASG,EAAWC,GAClB,MAAO,OAASA,EAAgB,aC5OlBC,EACdC,EACAC,GAEA,IAAMC,EAA6D,GAUnE,OARAC,OAAOC,KAAKH,GAAoBI,SAAQ,SAACC,GACvC,IAAMC,EAAWN,EAAmBK,GAChCC,EAAS,aAAaC,OAASR,IACjCE,EAA2BI,GACzBC,MAICL,ECkIT,SAASO,EACPF,EACAb,EACAgB,GAEA,IAAMC,EAASJ,EAAS,aAAaK,gBAAgBH,UAAUf,GAQ/D,OAAOgB,EAAYG,mBAAmBF,GAAUA,MC/JrCG,EAAU,CAAEC,WAAW,GCAvBC,EAEb,SAAoBtB,EAAeuB,GACjC,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAChC,GAAID,EAAMC,KAAOxB,EAAMwB,GACrB,OAAO,EAGX,OAAO,GARIF,EAWb,SAAkBtB,EAAe0B,GAC/B,IAAK,IAAIF,EAAI,EAAGA,GAAKE,EAAID,OAAQD,IAC/B,GAAIE,EAAIA,EAAID,OAASD,KAAOxB,EAAMA,EAAMyB,OAASD,GAC/C,OAAO,EAGX,OAAO,GAjBIF,EAoBb,SAAoBtB,EAAe2B,GACjC,IAAAC,EAAyB5B,EAAM2B,MAAMA,GACrC,MAAO,CADKC,KAASA,EAAAC,SACDC,KAAKH,KClBnBI,EAAyBT,EAAfU,EAAeV,WCDjBW,EAAcC,GAmB5B,QAAqCC,EAlBrCC,EAAMF,EAANE,OACAC,EAASH,EAATG,UACAC,EAAgBJ,EAAhBI,iBACAC,EAAcL,EAAdK,eAOMC,EAAkC,GAElCC,EAAiBhC,OAAOC,KAAK2B,GAAWK,KAAI,SAAC9B,GACjD,OAAA+B,GAAS/B,KAAAA,GAASyB,EAAUzB,OAGxBgC,EAAgBD,KAAQP,GAASS,aAAA,IAE5BhC,EAAQsB,EAAAnC,MACb8C,EAAMV,EAAOvB,EAASD,MAG1B,UAFOgC,EAAiB/B,EAASD,WAErBmC,IAARD,EACF,OAAIjC,EAAS,aAAamC,qBAI1BC,GAAO,GAGT,IAAIjD,SAEJ,GAAY,OAAR8C,EAAc,CAChB,IAAIjC,EAAS,aAAaqC,MAEnB,OAAIrC,EAAS,aAAamC,qBAG/BC,GAAO,GAJPjD,EAAQ,QAML,GAAIa,EAAS,aAAaqC,OAS/B,IARAlD,EAAQ8C,EAAInB,MAAMY,GAAgBG,KAAI,SAACS,SACrC,OAAOtC,EAAS,aAAaK,gBAAgBkC,cAC3CC,EAAAxC,EAAS,aAAaK,gBAAgBF,WAASqC,EAAIf,GAC/CgB,mBAAmBH,GACnBA,OAIEI,MAAK,SAACJ,GAAI,OAAKA,IAAS/B,KAChC,OAAIP,EAAS,aAAamC,qBAI1BC,GAAO,OAEJ,CAAA,IAAAO,EAOL,IANAxD,EAAQa,EAAS,aAAaK,gBAAgBkC,cAC5CI,EAAA3C,EAAS,aAAaK,gBAAgBF,WAASwC,EAAIlB,GAC/CgB,mBAAmBR,GACnBA,MAGQ1B,EACZ,OAAIP,EAAS,aAAamC,qBAI1BC,GAAO,GAIXT,EAAO3B,EAASD,MAAQZ,GAtD1ByD,EAAAC,EAAuBjB,KAAcN,EAAAsB,KAAAE,MAAE,CAAA,IAAAC,EAAAf,IAAA,gBAAAe,oBA+CtBA,SAAAA,EAAAX,EAUjB,MAAO,CAAET,OAAAA,EAAQqB,oBAAqBpD,OAAOC,KAAKkC,GAAkBnB,iBCpEtDqC,EAAa5B,OAC3B6B,EAAQ7B,EAAR6B,SACAvB,EAAMN,EAANM,OAKMwB,EAA0B3D,EAAmB,QAASmC,GACtDyB,EAA0B5D,EAAmB,QAASmC,GAEtD0B,EAAyC,GAU/C,OARAzD,OAAOC,KAAK8B,GAAQ7B,SAAQ,SAACwD,GAC3B,IAAMC,EAAQ5B,EAAO2B,QACcpB,IAA/BqB,EAAM,uBAGVF,EAAcC,GAAaC,EAAM,yBAG5B,SAAAC,OACLC,EAAcD,EAAdC,eACA/B,EAAc8B,EAAd9B,eACAgC,EAAqBF,EAArBE,sBAMA,QAA4BxB,IAAxBuB,EAAeE,KACjB,OAAO,EAGT,IAAMC,WFtCkBvC,GAS1B,QARAsC,EAAItC,EAAJsC,KACAT,EAAQ7B,EAAR6B,SACAxB,EAAcL,EAAdK,eAMSmC,EAAQ,EAAGA,EAAQX,EAAStC,OAAQiD,IAAS,CACpD,IAAMzD,EAAS0D,EAAMZ,EAASW,IAC9B,IAAe,IAAXzD,EACF,OAAA0B,KAAY1B,GAAQ2D,YAAuB,IAAVF,IAIrC,OAAO,EAEP,SAASC,EAAME,GACb,IAAMrC,EAAkC,GAExC,GAAa,MAATgC,GAAmC,IAAnBK,EAAQpD,OAC1B,MAAO,CAAEe,OAAAA,EAAQqB,oBAAqB,GAGxC,IAAMiB,EAAuBN,EAAK/C,OAAS,GAAKM,EAASyC,EAAM,KAE3DM,IACFN,EAAOA,EAAK3C,MAAM,EAAG2C,EAAK/C,OAAS,IAKrC,IAFA,IAAMsD,EAAkBP,EAAK7C,MAAM,KAAKE,MAAM,GAAGgB,WAG3CmC,GAAY,IAAAC,EAAAC,EAiBUC,EAbpBC,EACJJ,GAAgBH,EAAQpD,OAAS,KAAOoD,EAAQG,GAC9CK,EACFL,GAAgBD,EAAgBtD,OAC5B,KACAsD,EAAgBC,GAEtB,GAAuB,OAAnBI,EACF,OAAAnC,GAAO,GAKT,GAAoB,OAAhBoC,EACF,OACkC,GAJAR,EAAQpD,OAAS,EAAIuD,UAKrDG,EAACC,EAAeE,gBAAfH,EAA+B,aAAanC,kBAE7CC,GAAO,GAUX,UAJAgC,EAAIG,EAAeE,gBAAfL,EAA+B,aAAaM,WAC9CF,EAAcN,EAAgBlD,MAAMmD,GAAclD,KAAK,OAGpDE,EAAWqD,EAAaD,EAAeI,SAC1C,OAAAvC,GAAO,GAGT,IAAMwC,EAA0BJ,EAAYxD,MAC1CuD,EAAeI,QAAQ/D,QAGzB,IAAKM,EAAS0D,EAAyBL,EAAeG,UACpD,OAAAtC,GAAO,GAGT,IAAMyC,EAAqCD,EAAwB5D,MACjE,EACA4D,EAAwBhE,OAAS2D,EAAeG,SAAS9D,QAG3D,IAAK2D,EAAeE,cAClB,MAA2C,KAAvCI,cAIJzC,GAAO,GAGT,GAA2C,KAAvCyC,EACF,OAAIN,EAAeE,cAAc,aAAatC,qBAI9CC,GAAO,GAGT,IAAMjC,SAASkE,EACbE,EAAeE,cAAc,aAAapE,gBAAgBF,WAASkE,GAClEE,EAAeE,cAAc,aAAaC,SAEzCvF,SAEJ,GAAIoF,EAAeE,cAAc,aAAapC,OAW5C,IAVAlD,EAAQ0F,EACL/D,MAAMY,GACNG,KAAI,SAACS,SACJ,cAAAwC,EAAOP,EAAeE,sBAAfK,EACL,aACAzE,gBAAgBkC,MAChBpC,EAAYsC,mBAAmBH,GAAQA,OAInCI,MAAK,SAACJ,GAAI,OAAKA,IAAS/B,KAChC,OAAA6B,GAAO,QAST,IANAjD,EAAQoF,EAAeE,cAAc,aAAapE,gBAAgBkC,MAChEpC,EACIsC,mBAAmBoC,GACnBA,MAGQtE,EACZ,OAAA6B,GAAO,GAcX,OATEmC,EAAeE,cAAc,aAAaC,UAC1CT,GAC4B,KAA5BM,EAAeG,WAEfvF,QAGFwC,EAAO4C,EAAeE,cAAcnB,WAAanE,EAE7CoF,EAAeE,cAAc,aAAaC,sBAA9C,GA3GIP,EAAe,EACnBA,EAAeY,KAAKC,IAAIhB,EAAQpD,OAAQsD,EAAgBtD,QACxDuD,IACA,CAAA,IAAApB,EAAAf,EAHImC,GAAY,aAAApB,EA4Gd,MAAM,gBAAAA,oBAjDKA,SAAAA,EAAAX,EAqDf,MAAO,CAAET,OAAAA,EAAQqB,oBAAqB,IE5GpBiC,CAAa,CAC7BtB,KAAMF,EAAeE,KACrBT,SAAAA,EACAxB,eAAAA,IAGF,IAAkB,IAAdkC,EACF,OAAO,EAGT,IAAMsB,WCjDRC,EACA3D,EACAkC,EACAhC,GAEA,IAAIH,EAAwC,GAgB5C,OAdI4D,IACF5D,EAASmC,EAAsBnB,MAAM4C,IAahC/D,EAAe,CACpBG,OAAAA,EACAC,UAAAA,EACAC,kBAAkB,EAClBC,eAAAA,IDwBmB0D,CACjB3B,EAAe0B,MACfhC,EACAO,EACAhC,GAEF,IAAmB,IAAfwD,EACF,OAAO,EAGT,IAAMG,WE5DRC,EACA9D,EACAE,GAEA,OAAON,EAAe,CACpBG,aAAQ+D,EAAAA,EAAS,GACjB9D,UAAAA,EACAC,kBAAkB,EAClBC,eAAAA,IFoDmB6D,CACjB9B,EAAe6B,MACflC,EACA1B,GAEF,OAAmB,IAAf2D,GAIG,CACLtB,YAAaH,EAAUG,YACvBpC,OAAMG,KACDuB,EACAO,EAAUjC,OACVuD,EAAWvD,OACX0D,EAAW1D,QAEhBqB,oBACEY,EAAUZ,oBACVkC,EAAWlC,oBACXqC,EAAWrC,+BGlFHwC,EAAgCC,GAO9C,gBAP8CA,IAAAA,EAAa,MACjDA,EAILC,QAJKD,EAIQC,OAAOA,QAA8B,UAJ7CD,EAI2BC,OAAOA,QAJlCD,EAQLE,kBACU,IATLF,EASNG,QATMH,EACmBI,SADnBJ,EACgCK,QADhCL,EAC4CM,SAD5CN,EACyDO,WADzDP,GAAAA,EAYGQ,gBAZHR,EAaJQ,iBAGG,ICfX,IAAQ9E,EAAeV,WAEPyF,EAAU7E,OACxB8E,EAAS9E,EAAT8E,UACAxE,EAAMN,EAANM,OACAyE,EAAQ/E,EAAR+E,SACAC,EAAahF,EAAbgF,cAOQC,EAAsBD,EAAtBC,SAEJC,EAF0BF,EAAZG,QAECC,WAAW,CAC5BC,UAAwB,IAAdP,EAAsBC,EAASO,SAAWP,EAASzC,KAC7DiD,OAAQR,EAASjB,MAAQ,IAAMiB,EAASjB,MAAQ,KAG9ChE,EAAWoF,EAAM,OACnBA,EAAO,IAAMA,IAGG,IAAdJ,GAAiD,MAA1BE,EAAcQ,UACvCN,EAAOF,EAAcQ,QAAUN,GAGjC,IAAMO,EAAuB,CAC3B/G,KAAMoG,EACNxE,OAAAA,EACA4E,KAAAA,EACAQ,KAAM,CACJR,KAAAA,EACAS,QAAS,SAACvB,GACR,GAAID,EAAgCC,GAClC,OAAOqB,EAAMG,SAInBC,OAAQ,KACRD,KAAM,WAAA,OAAMX,EAAQxE,KAAMgF,GAAOI,OAAQ,UAAU,IACnDC,QAAS,WAAA,OAAMb,EAAQxE,KAAMgF,GAAOI,OAAQ,aAAa,KAG3D,OAAOJ,WCxCOM,EACdjB,EACAkB,EACAC,GAEA,IZAAC,EACAC,EAEMC,EAWAC,EYdAxE,GZANqE,EYEE/H,EAAmB,OAAQ6H,EAAS,aAAa1F,QZDnD6F,EYEEH,EAAS,aAAa1D,KZAlB8D,EAAqB7H,OAAOC,KAAK0H,GAAwB1F,KAC7D,SAACyB,GAMC,OALkCxB,GAChCwB,UAAAA,GACGiE,EAAuBjE,OAO1BoE,EAAuC,GAE7CD,EAAmB3H,SAAQ,SAAAuB,OAAGiC,EAASjC,EAATiC,UAe5BoE,EAAkBpE,GAAahE,EAAWgE,MAkBrCpE,EAfSsI,EAAWE,IAeH7F,KAAI,SAAC8F,GAoB3B,GAAuB,IAAnBA,EAAQ/G,OACV,MAAO,GAgBT,IALA,IAKwCU,EALlCsG,EAAkBD,EAAQ7G,MAAM,KAAKE,MAAM,GAE3C6G,EAAuC,GACvC7D,EAAmB,GAEzBpB,EAAAC,EAAyB+E,KAAetG,EAAAsB,KAAAE,MAAE,CAWxC,IAXwC,IAWCgF,EAXhCC,EAAUzG,EAAAnC,MASf6I,EAAsD,KAE1DC,EAAApF,EAAuB4E,KAAkBK,EAAAG,KAAAnF,MAAE,CAAA,IAAhC9C,EAAQ8H,EAAA3I,MACb4I,EAAWG,QAAQ5I,EAAWU,EAASsD,aAAe,IAiBxD0E,EAAmBhI,EACnB6H,EAAe7H,EAASsD,YAAa,GAIzC,GAAI0E,EAAkB,CACpB,IAAAG,EAA4BJ,EAAWjH,MACrCxB,EAAW0I,EAAiB1E,YA+B9BU,EAAQiD,KAAK,CACXtC,QAjCYwD,KAkCZzD,SAlCsByD,KAmCtB1D,cAAeuD,SAYjBhE,EAAQiD,KAAK,CACXtC,QAASoD,EACTrD,SAAU,GACVD,cAAe,OAgDrB,OAbuCgD,EACpC5F,KAAI,SAAA2B,GAAY,OAAMA,EAAfF,aACP8E,QAAO,SAACrI,GAAI,OAAM8H,EAAe9H,MAW7BiE,MYrNHqE,EAA8B,SAClC1G,YAAAA,IAAAA,EAAkC,IAuClC,IAAM0E,EAAgBiB,IAEd5F,EAAmD2E,EAAnD3E,eAAgBgC,EAAmC2C,EAAnC3C,sBAAuBmD,EAAYR,EAAZQ,QAEzCyB,EAAiBxG,KAAQH,GAE/B/B,OAAOC,KAAKwH,EAAS,aAAa1F,QAAQ7B,SAAQ,SAACwD,GACjD,IAAMtD,EAAWqH,EAAS,aAAa1F,OAAO2B,QAGXpB,IAAjCoG,EAAkBhF,SACgBpB,IAAlClC,EAAS,uBAETsI,EAAkBhF,GAAatD,EAAS,yBAI5C,IAAMoG,WV7DoB/E,OAC5BkH,EAAelH,EAAfkH,gBACA7I,EAAkB2B,EAAlB3B,mBACAgC,EAAcL,EAAdK,eACAgC,EAAqBrC,EAArBqC,sBACAR,EAAQ7B,EAAR6B,SACA2D,EAAOxF,EAAPwF,QASMlF,EAAS,CACbgC,KAAM,GACNwB,MAAO,GACPG,MAAO,IACPtD,WAESsB,GAAS,IAAAd,EACZgG,EAAaD,EAAgBjF,GAEnC,QAAmBpB,IAAfsG,EACF,iBAGF,IAAMxI,EAAWN,EAAmB4D,GAG9BnD,SAASqC,EACbxC,EAAS,aAAaK,gBAAgBF,WAASqC,EAFhB,UAA/BxC,EAAS,aAAaC,OAAqBD,EAAS,aAAa0E,SAI7D+D,EAAW,SAACD,GA4BhB,OAzBIxI,EAAS,aAAaqC,MAgBe,IAApCmG,EAAyB5H,OACtB,KACC4H,EACE3G,KAAI,SAACS,GAAI,OAAKpC,EAAUF,EAAUsC,EAAMnC,MACxCc,KAAKS,GAENxB,EAAUF,EAAUwI,EAAYrI,IAMtChB,EAAQsJ,EAASD,GAEvB,GACiC,UAA/BxI,EAAS,aAAaC,WACYiC,IAAlClC,EAAS,sBACTyI,EAASzI,EAAS,wBAA0Bb,EAE5C,iBAGFwC,EAAO3B,EAAS,aAAaC,MAAMqD,GAAa,CAC9CoF,kBAAmB1I,EAAS,aAAaK,gBAAgBsI,GACzDtG,MAAOrC,EAAS,aAAaqC,MAC7BlD,MAAAA,IAzDJ,IAAK,IAAMmE,KAAa5D,EAAoBsC,EAAjCsB,GA6DX,IAAMK,EACJ,IACAT,EAAS,GACNkF,QAAO,SAAA5E,OAAGiB,EAAajB,EAAbiB,cACT,cACEA,GAAAA,EAAgB,aAAatC,eACYD,IAAzCP,EAAOgC,KAAKc,EAAcnB,eAG7BzB,KAAI,SAAA+G,OAAGnE,EAAamE,EAAbnE,cAIN,OAJ4BmE,EAAPjE,SACJF,EACb9C,EAAOgC,KAAKc,EAAcnB,WAAWnE,MACrC,IAHkCyJ,EAARlE,YAM/BzD,KAAK,KAyBV,MAAO,CACL0F,UAAuB,MAAZE,EAAkB,GAAKA,GAAWlD,EAC7CA,KAAAA,EACAwB,MA1BqBvF,OAAOC,KAAK8B,EAAOwD,OAAOvE,OAAS,EAGtD8C,EAAsBxD,UAAUyB,EAAOwD,YACvCjD,EAuBFoD,MAdqC,IAArC1F,OAAOC,KAAK8B,EAAO2D,OAAO1E,YACtBsB,EACAtC,OAAOC,KAAK8B,EAAO2D,OAAOuD,QACxB,SAACvD,EAAOwD,GAAG,IAAAC,EAAA,OAAAjH,KACNwD,IAAKyD,MACPD,GAAMnH,EAAO2D,MAAMwD,GAAK3J,MAAK4J,MAEhC,KU1DWC,CAAe,CAC9BT,gBAAiB5G,EACjBjC,mBAAoB2H,EAAS,aAAa1F,OAC1CD,eAAAA,EACAgC,sBAAAA,EACAR,SAAAA,EACA2D,QAAAA,IAGF,OAAOX,EAAW,CAChBC,UAAAA,EACAxE,OAAQ2G,EACRlC,SAAAA,EACAC,cAAAA,KAgBJ,OAZAzG,OAAOqJ,eAAeZ,EAAO,OAAQ,CAAElJ,MAAOgH,IAE9CkC,EAAM,aAAe,CACnB5I,KAAM,eACNqE,MAAOb,EAAc,CACnBC,SAAAA,EACAvB,OAAQ0F,EAAS,aAAa1F,SAEhCuB,SAAAA,EACAgG,MAAO,MAGFb,WCvGOc,EACdC,oBAAAA,IAAAA,EAGI,IAEJ,IAAMC,SAAsBC,EAC1BF,EAAKC,wBAAsBC,EAAI,uBAC3B5H,SAAc6H,EAAGH,EAAK1H,gBAAc6H,EAAI,IAExCC,EACuB,aAA3BH,GAC2B,wBAA3BA,EAEII,EACuB,aAA3BJ,GAC2B,cAA3BA,EACI,GACA,KAEN,MAAO,CACL9G,MAAO,SAACN,GAGN,IAFA,IAEiCX,EAF3BoI,EAA6C,GAEnD9G,EAAAC,EAAmBZ,EAAInB,MAAM,QAAIQ,EAAAsB,KAAAE,MAAE,CAAA,IACjC6G,EADarI,EAAAnC,MACuC2B,MAAM,KAAnD8I,EAAYD,KAAEE,EAAaF,KAAKG,EAAIH,EAAA3I,SAE3C,UAAqBkB,IAAjB0H,GAA8BE,EAAKlJ,OAAS,GAAhD,CAIA,IAAMkI,EAAMrG,mBACVhC,EAAqBmJ,EAAcH,GAC/BG,EAAa5I,MAAM,EAAG4I,EAAahJ,OAAS6I,EAAe7I,QAC3DgJ,QAGgB1H,IAAlB2H,EACFH,EAAYZ,GAAO,KACVY,EAAYZ,IAAQU,EAC7BE,EAAYZ,OAAWpH,EAAiBmI,EAExCH,EAAYZ,GAAOe,GAIvB,OAAOH,GAGTxJ,UAAW,SAACwJ,GACV,OAAO9J,OAAOC,KAAK6J,GAChB7H,KAAI,SAAC9B,GACJ,IAAMgK,EAAczJ,mBAAmBP,GACjC+I,EAAMY,EAAY3J,GAAMsC,SACvB0H,EAAcN,EACjBM,EACE5K,EAAQuK,EAAY3J,GAAMZ,MAEhC,OAAc,OAAVA,EACK2J,EAGLY,EAAY3J,GAAMsC,OAASmH,EACVrK,EAAM2B,MAAMY,GACbG,KAAI,SAACS,GAAI,OAAQwG,MAAOxG,KAAQrB,KAAK,KAG/C6H,MAAO3J,KAElB8B,KAAK,gBCrEE+I,EACd5D,EACAC,GAEA,IAAmB3C,EAA0C2C,EAA1C3C,sBAAuBhC,EAAmB2E,EAAnB3E,eAEpCuI,GAASC,EAF8C7D,EAArD6D,aAIJC,GAAyD,EAE7D,IAAK,IAAMhE,KAAa8D,EAAQ,CAC9B,IAAMnG,EAAQmG,EAAO9D,GAAW,aAAarC,MAAM,CACjDL,eAAgB2C,EAChB1C,sBAAAA,EACAhC,eAAAA,IAGF,IAAc,IAAVoC,EAAJ,CAIA,GAAkC,IAA9BA,EAAMd,oBACR,MAAO,CACL8D,MAAOmD,EAAO9D,GAAWrC,EAAMnC,QAC/BoC,YAAaD,EAAMC,eAKH,IAAlBoG,GACArG,EAAMd,oBAAsBmH,EAAcnH,uBAE1CmH,EAAarI,KAAQgC,GAAOqC,UAAAA,MAIhC,OAAIgE,EACK,CACLrD,MAAOmD,EAAOE,EAAchE,WAAWgE,EAAcxI,QACrDoC,YAAaoG,EAAcpG,aAIxB,CACL+C,MAAOZ,EAAW,CAChBC,WAAW,EACXxE,OAAQ,GACRyE,SAAAA,EACAC,cAAAA,IAEFtC,aAAa,GCjDjB,IAAQ5C,EAAeV,WAEP2J,EACdC,EACAxD,GAEA,MAAO,CACLF,SAAU0D,EAAY3D,SACtB/C,KAAMxC,EAAWkJ,EAAY3D,SAAUG,GACvB,MAAZA,EACEwD,EAAY3D,SAASS,QAAQN,EAAS,IACtCwD,EAAY3D,cACdxE,EACJiD,MAAOkF,EAAYzD,OACfzF,EAAWkJ,EAAYzD,OAAQ,KAC7ByD,EAAYzD,OAAO5F,MAAM,GACzBqJ,EAAYzD,YACd1E,EACJoD,MAC+B,iBAAtB+E,EAAY/E,OAA4C,OAAtB+E,EAAY/E,MAChD+E,EAAY/E,MAA6CA,WAC1DpD,GCpBV,IAAQoI,EAAe7J,EAEvB,SAAgB8J,EACdhE,EACAjB,EACAe,GAEA,IAAAmE,EAA2BF,EAAW/D,EAAM,KAW5C,OAAOyD,EATUI,EACf,CACE1D,SAJW8D,KAKX5D,OALmB4D,KAMnBlF,MAAAA,GAEFe,EAAcQ,SAGkBR,YCrBpBoE,EAA8BpJ,OAC5CqJ,EAAcrJ,EAAdqJ,eACAC,EAAatJ,EAAbsJ,cAKMC,EAGA,GACFC,EAAY,EAEhB,MAAO,CAAEC,IAMT,SAAaC,GACX,IAAMpC,EAAKkC,IAOX,OANAD,EAAc3D,KAAK,CAAE0B,GAAAA,EAAIoC,QAAAA,IAEI,IAAzBH,EAAchK,QAChB8J,IAKF,WACE,IAAM7G,EAAQ+G,EAAc/I,KAAI,SAAA+G,GAAK,OAAAA,EAAFD,MAAaT,QAAQS,GACpD9E,GAAS,IACX+G,EAAcI,OAAOnH,EAAO,GACC,IAAzB+G,EAAchK,QAChB+J,OArBMM,YAEd,WACE,OAAOL,EAAc/I,KAAI,SAAA2B,GAAU,OAAAA,EAAPuH,sBChBhBG,EACdpE,EACAqE,GAEA,GACmB,SAAjBrE,EAAMI,QACY,iBAAXkE,QACI,OAAXA,QACyB,mBAAlBA,OAAOC,SACE,IAAhBF,GACqB,iBAAdG,WACO,OAAdA,WAC+B,iBAAxBA,UAAUC,aAEfD,UAAUC,UAAUrD,QAAQ,WAAa,GACzCoD,UAAUC,UAAUrD,QAAQ,SAAW,GAGzC,IACEkD,OAAOC,OAAO,EAAG,GACjB,MAAAG,cCpBUC,EACd3E,EACA4E,GAEA,IAAMpG,EAAgC,GAEtC,GAAIwB,EAAM/G,KAER,IADA,IACoCuB,EAApCsB,EAAAC,EADqBjD,OAAOC,KAAKiH,EAAMnF,QAAQgK,UACXrK,EAAAsB,KAAAE,MAAE,CAAA,IAA3BQ,EAAShC,EAAAnC,MACZa,EACJ0L,EAAU5E,EAAM/G,MAAM,aAAa4B,OAAO2B,GAAW,aAEjC,UAAlBtD,EAASC,OAEXqF,EAAMhC,GAAatD,EAASK,gBAAgBH,UAD9B4G,EAAMnF,OAAO2B,KAMjC,OAAOgC,MCSWgF,EAAe7J,EAWnC,SAAgBmL,yCAAgBxC,MAAWhK,MAAAyM,GAAAC,IAAAA,EAAAD,EAAAC,IAAX1C,EAAW0C,GAAAC,UAAAD,GACzC,IAmCItF,EACAwF,EApCJC,EAA4BC,EAAU9C,GAA9BsC,EAASO,EAATP,UAAWS,EAAIF,EAAJE,KAEbC,EAA2B3B,EAA+B,CAC9DC,eAAgB,WACdsB,EAAWxF,EAAQ6F,QAAO,SAACC,GACzB,GAAIC,EACFA,GAAyC,MAD3C,CAKA,IAAMnG,EAAWgE,EACfkC,EAAOlG,SACPS,GAEIK,EAASoF,EAAOpF,OAAOsF,cAC7BC,EAA+BzC,EAC7B5D,EACAkB,KAFavD,EAAW0I,EAAX1I,YAKf2I,EAAgB5K,KALH2K,EAAL3F,OAKqBI,OAAAA,IAAUnD,QAG3C4G,cAAe,WAAA,aAAMqB,SAAAA,OAGjBnF,SAAO8F,EAAGR,EAAKtF,SAAO8F,EAAI,IAC1BjL,SAAckL,SAAAC,EAAGV,EAAKW,oBAALD,EAAkBE,WAASH,EAAI,IAChDlJ,SAAqBsJ,EACzBb,EAAKzI,uBAAqBsJ,EAC1B7D,EAA4B,CAC1BE,8BAAsB4D,EAAEd,EAAKW,oBAALG,EAAkBC,YAC1CxL,eAAAA,IAKA6K,GAAyC,EACzCY,GAAiD,EACjDC,EAAqC,KACrCC,EAAsC,KACtCC,EAAuC,GAE3CC,EAAiBpB,EAAKqB,SAEtB,IAmIMC,EAnIAxD,EAASyD,EAA6BpG,GAEtCkG,EAAyC,CAE3CvG,cAAKV,EAAMjB,GAST,IAAAqI,EAA+BpD,EAC7BhE,EACAjB,EACAgC,KAHavD,EAAW4J,EAAX5J,YAMf,OAAOuC,EAAQxE,KANF6L,EAAL7G,OAMoBI,OAAQ,SAAUnD,IAEhDoD,iBAAQZ,EAAMjB,GASZ,IAAAsI,EAA+BrD,EAC7BhE,EACAjB,EACAgC,KAHavD,EAAW6J,EAAX7J,YAMf,OAAOuC,EAAQxE,KANF8L,EAAL9G,OAMoBI,OAAQ,YAAanD,IAEnD8J,cAAKC,YAAAA,IAAAA,EAAS,GAQZtH,EAAQuH,IAAID,IAEdE,iBAAQF,YAAAA,IAAAA,EAAS,GAQftH,EAAQuH,GAAGD,IAEbG,2BAOE,IAAKb,EAAc,CACjB,IAAIhN,EAAS4J,EACXI,EACE5D,EAAQJ,SACRS,GAEFS,KAGGlH,EAAO2D,cACVoJ,GAAiD,EACjD/M,EAAO0G,MAAMK,UACb/G,EAAS4J,EACPI,EACE5D,EAAQJ,SACRS,GAEFS,MAGJ8F,EAAehN,EAAO0G,MAGxB,OAAOsG,GAETc,eAAMV,GAQJ,OAAOD,EAAiBC,IAE1BW,eAAMC,GACJd,EAAkBrG,KAAKmH,GAEvB,IAAMC,EAAU7H,EAAQ2H,OAAM,SAAC7B,GAC7B,IAAQxF,EAAUkD,EAChBI,EACEkC,EAAOlG,SACPS,GAEFS,KALMR,MAQFI,EAASoF,EAAOpF,OAAOsF,cAE7B4B,EAAQ,CAAEtH,MAAKhF,KAAOgF,GAAOI,OAAAA,IAAUoH,MAAOhC,EAAOgC,WAGvD,OAAO,WACLhB,EAAkBtC,OAChBsC,EAAkBiB,WAAU,SAACC,GAAI,OAAKA,IAASJ,KAC/C,GAGFC,MAGJhC,OAAQ,SAACtB,GAAO,OAAKqB,EAAyBtB,IAAIC,KAItD1J,GACMoM,EAAgBD,EAAQS,kBAE5BT,EAAQnB,QAAO,SAAAvF,GAAK,OAAK2G,EAAgB3G,KAMlC,CAAE2H,SAJT,WACI,OAAOhB,KANLgB,EAAQpN,EAARoN,SAYFC,EAA6B,CACjCzE,OAAAA,EACAuD,QAAAA,EACA7C,cAAe,WAAA,aAAKqB,SAAAA,KACpByC,SAAAA,GAGF,OAAOC,EAEP,SAASnB,EACPoB,YAAAA,IAAAA,EAA2B,CACzBlP,KACoB,oBAAX2L,aAAqD,IAApBA,OAAOwD,SAC3C,UACA,WAGRxB,EAAe,KAEb5G,EADuB,WAArBmI,EAAYlP,KACJoP,sBAAoB,CAC5BC,eAAgBH,EAAYG,eAC5BC,aAAcJ,EAAYI,eAEE,SAArBJ,EAAYlP,KACXuP,oBAAkB,CAC1B5D,OAAQuD,EAAYvD,SAGZ6D,uBAAqB,CAC7B7D,OAAQuD,EAAYvD,SAK1B,SAAS9E,EAASQ,EAAsB/C,SACtC,GAAIuJ,EAAkB1M,OAAS,EAC7B0M,EAAkBxN,SAAQ,SAACsO,GACzBA,EAAQ,CACNtH,MAAAA,EACAwH,MAAO,WACLxH,EAAuB,SAAjBA,EAAMI,OAAoB,OAAS,uBALjD,CAaA,IAAM5B,EAAQmG,EAAqB3E,EAAO4E,GAE1C,WACEwD,EAAA7B,UAAA6B,EAAe3I,QAASO,EAAMP,MAC9B4I,KAAKjP,UAAUuL,EAAqB4B,EAAe3B,MACjDyD,KAAKjP,UAAUoF,GAHnB,CAQI6H,EACFA,GAAiD,EAEjDT,EAAiB5F,EAAO/C,GAG1BwI,GAAyC,EAEzC,IAAA/B,EAA2BF,EAAWxD,EAAMP,KAAM,KAAjCK,EAAM4D,KAEvBhE,EAAyB,YAAjBM,EAAMI,OAAuB,UAAY,QAC/C,CACER,SAJW8D,KAKX5D,OAAQA,MAAaA,EAAW,GAChCwI,KAAM,IAER9J,EAAQ,CAAEA,MAAAA,QAAUpD,KAIxB,SAASwK,EAAiB5F,EAAsB/C,GAC9C,GAAKA,EAAL,CAKA,QAA4DzC,EAA5DsB,EAAAC,EAAsBuJ,EAAyBnB,iBAAa3J,EAAAsB,KAAAE,OAC1DiI,EADgBzJ,EAAAnC,OACR2H,GAGVoE,EAAmBpE,EAAOqF,EAAKhB,aAE/BkC,EAAgBvG,OAVdA,EAAMK,UAaV,SAASG,IACP,MAAO,CACL5D,sBAAAA,EACAhC,eAAAA,EACA4E,SAAAA,EACAE,QAAAA,EACAkF,UAAAA,EACAxB,UAAW,WAAA,OAAMD,GACjBpD,QAAAA,aAKUqF,EAAU9C,GAmCxB,MAAO,CAAEsC,UAjCS,IAAhBtC,EAAKxI,OAAewI,EAAK,GAAKA,EAAK,GAiCjB+C,KAhCqB,IAAhB/C,EAAKxI,OAAe,GAAKwI,EAAK,IAmCzD,SAASsE,EAA6BpG,GACpC,IAAM2C,EAA+C,GAC7CyB,EAAcpE,IAAdoE,UAER,IAAK,IAAMvF,KAAauF,EAEtBzB,EAAO9D,GAAaiB,EAClBjB,EAFeuF,EAAUvF,GAIzBmB,GAIJ,OAAO2C,EC1RT,SAASiC,EAAU9C,GAIjB,OAAuB,IAAhBA,EAAKxI,OACR,CACEe,OAAQ,GACRgC,KAAM,WAAA,OAAMyF,EAAK,KAEnB,CACEzH,OAAQyH,EAAK,GACbzF,KAAMyF,EAAK,QC/GbiG,EAAoC,CACxC1G,GAAI,UACJpG,MAAO,SAACN,GAAG,MAAc,SAARA,GAAgC,UAARA,GAA0B1B,GACnEL,UAAW,SAACf,GAAK,OAAMA,EAAQ,OAAS,UAGpCmQ,EAAkC,CACtC3G,GAAI,SACJpG,MAAO,SAACN,GACN,OASe9C,EATA8C,EAUTsN,MAAMC,WAAWrQ,MAAW,gBAAgBsQ,KAAKtQ,GAT9CoB,EAGFiP,WAAWvN,GAKtB,IAAmB9C,GAHjBe,UAAW,SAACf,GAAK,OAAKA,EAAMuQ,aAOxBC,EAAkC,CACtChH,GAAI,SACJpG,MAAO,SAACN,GAAG,OAAKA,GAChB/B,UAAW,SAACf,GAAK,OAAKA,IAuBXoE,EAAQ,CACnBI,KAAI7B,KACC8N,EAAuB,QAAQ,IAClClL,SAAUkL,EAAuB,QAAQ,KAE3CzK,MAAOyK,EAAuB,SAAS,GACvCtK,MAAOsK,EAAuB,SAAS,IAGzC,SAASA,EAGP3P,EAAayE,GACb,OAAA5C,KACK+N,GAA8B,GAAO,IACxCxN,MAAOwN,GAA8B,GAAO,GAC5C1N,SAAQL,KACH+N,GAA8B,GAAM,IACvCxN,MAAOwN,GAA8B,GAAM,OAI/C,SAASA,EAGP1N,EAAqBE,GACrB,MAAO,CACLsN,OAAQG,EAAY,CAClBC,YAAa,CACXtQ,KAAM,WACN4C,MAAAA,EACApC,KAAAA,EACAkC,SAAAA,EACA9B,gBAAiBsP,EACjBjL,SAAAA,EACAsL,aAAS9N,KAIboN,OAAQQ,EAAY,CAClBC,YAAa,CACXtQ,KAAM,WACN4C,MAAAA,EACApC,KAAAA,EACAkC,SAAAA,EACA9B,gBAAiBiP,EACjB5K,SAAAA,EACAsL,aAAS9N,KAIbmN,QAASS,EAAY,CACnBC,YAAa,CACXtQ,KAAM,WACN4C,MAAAA,EACApC,KAAAA,EACAkC,SAAAA,EACA9B,gBAAiBgP,EACjB3K,SAAAA,EACAsL,aAAS9N,KAIb+N,gBACE5P,GASA,gBATAA,IAAAA,EAnF2C,CAC/CsI,GAAI,OACJpG,MAAO,SAACN,GACN,IAAI9C,EAEJ,IACEA,EAAQgQ,KAAK5M,MAAMN,GACnB,MAAAuJ,GACA,OAAOjL,EAGT,OAAOpB,GAETe,UAAW,SAACf,GAAK,OAAKgQ,KAAKjP,UAAUf,MA+E1B2Q,EAAY,CACjBC,YAAa,CACXtQ,KAAM,WACN4C,MAAAA,EACApC,KAAAA,EACAkC,SAAAA,EACA9B,gBAAAA,EACAqE,SAAAA,EACAsL,aAAS9N,OAyBnB,SAAS4N,EAAWzO,OACL6O,EAAQ7O,EAArB,aAEA,OAAK6O,EAAS/N,SAIP,CACL4N,YAAaG,EAAQF,iBACb7Q,GAON,MAAO,CACL4Q,YAAWjO,KAAOoO,GAAUF,QAAS7Q,OAblC,CAAE4Q,YAAaG,IC9J5B,SAASC,EAAuCC,GAY9C,IAAMC,EAAmC,GAYzC,OAVAD,EAAWtQ,SAAQ,SAAC0O,GACDA,EAmCY6B,WAlC3B7B,EAAK6B,WAAWvQ,SAAQ,SAACC,GACvBsQ,EAAWtQ,IAAQ,KAGrBsQ,EAAW7B,EAAKzO,OAAQ,KAIrB,CACLgQ,YAAa,CACXtQ,KAAM,aACNyJ,MAAO,MAETmH,WAAYzQ,OAAOC,KAAKwQ,GACxBC,aAAIxJ,GAQF,OAAmB,IAAfA,EAAM/G,QAIDsQ,EAAWvJ,EAAM/G,qCAsC9BwQ,GAEA,OAAOA,aAAenR,MAClB+Q,EAAsBI,IAvBpBC,EAAOC,EAwBiBF,GAtBxBG,EAAOP,EACXvQ,OAAO+Q,OAAOH,EAAKvG,SAGrBuG,EAAK7F,gBAEE+F,OARDF,EAEAE,uDFnDQE,+BAAexH,MAAWhK,MAAAyM,GAAAC,IAAAA,EAAAD,EAAAC,IAAX1C,EAAW0C,GAAAC,UAAAD,GAGxC,IAAM+E,EAAS3E,EAAU9C,GAEnB/B,EAA6B,CACjC0I,YAAa,CACXtQ,KAAM,WACNkC,OAAQkP,EAAOlP,OACfgC,KAAMkN,EAAOlN,MAEfmN,6CAAU1H,MAAWhK,MAAA2R,GAAAC,IAAAA,EAAAD,EAAAC,IAAX5H,EAAW4H,GAAAjF,UAAAiF,GAGnB,IAAA/E,EAAyBC,EAAU9C,GAA3BzH,EAAMsK,EAANtK,OAAQgC,EAAIsI,EAAJtI,KAEVsN,EAAmBrR,OAAOC,KAAKgR,EAAOlP,QACtCuP,EAAsBtR,OAAOC,KAAK8B,GAcxC,OAZ4BsP,EAAiB7I,QAC3C,SAACrI,GAAI,OAAKmR,EAAoBhJ,QAAQnI,IAAS,KAW1C6Q,EAAW9O,KAEXH,EACAkP,EAAOlP,SAEZ,SAACwP,SACOC,EAAkBlS,EACtB2R,EAAOlN,KAAKyE,EAAO6I,KAEfI,EAAiBnS,EAAQyE,EAAKyE,EAAO8I,KAE3C,OAAQ7P,MAAgBiQ,OAAMC,MAAAlQ,EACzB+P,EAAgBvP,KAAI,SAAC2P,GAAU,OAChCH,EAAexP,KAAI,SAAC4P,GAClB,MAAmB,MAAfD,EACKC,EAGFD,GAA4B,MAAdC,EAAoB,GAAKA,UAKpD,SAASrJ,EAAOsJ,GACd,IAAMC,EAAoC,GAM1C,OAJAD,EAAY5R,SAAQ,SAACgJ,GACnB6I,EAAU7I,GAAQqI,EAA6BrI,MAG1C6I,QAOjB,OAAOtK"}
\ No newline at end of file
diff --git a/node_modules/type-route/core/type-route.esm.js b/node_modules/type-route/core/type-route.esm.js
index 2f56c86..c2d8337 100644
--- a/node_modules/type-route/core/type-route.esm.js
+++ b/node_modules/type-route/core/type-route.esm.js
@@ -1267,95 +1267,113 @@ function createRouter() {
   var blockerCollection = [];
   applySessionOpts(opts.session);
   var routes = createRouteBuilderCollection(getRouterContext);
-  var router = {
-    routes: routes,
-    session: {
-      push: function push(href, state) {
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].push", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
-        }
-        var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),
-          route = _getRouteByHref.route,
-          primaryPath = _getRouteByHref.primaryPath;
-        return navigate(_extends({}, route, {
-          action: "push"
-        }), primaryPath);
-      },
-      replace: function replace(href, state) {
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].replace", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
-        }
-        var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),
-          route = _getRouteByHref2.route,
-          primaryPath = _getRouteByHref2.primaryPath;
-        return navigate(_extends({}, route, {
-          action: "replace"
-        }), primaryPath);
-      },
-      back: function back(amount) {
-        if (amount === void 0) {
-          amount = 1;
-        }
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].back", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
-        }
-        history.go(-amount);
-      },
-      forward: function forward(amount) {
-        if (amount === void 0) {
-          amount = 1;
-        }
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].forward", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
-        }
-        history.go(amount);
-      },
-      getInitialRoute: function getInitialRoute() {
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].getInitialRoute", [assert.numArgs([].slice.call(arguments), 0)]);
-        }
-        if (!initialRoute) {
-          var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());
-          if (!result.primaryPath) {
-            skipHandlingNextApplicationTriggeredNavigation = true;
-            result.route.replace();
-            result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());
-          }
-          initialRoute = result.route;
-        }
-        return initialRoute;
-      },
-      reset: function reset(session) {
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].reset", [assert.numArgs([].slice.call(arguments), 1), assert.type("object", "session", session)]);
+  var session = {
+    push: function push(href, state) {
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].push", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
+      }
+      var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),
+        route = _getRouteByHref.route,
+        primaryPath = _getRouteByHref.primaryPath;
+      return navigate(_extends({}, route, {
+        action: "push"
+      }), primaryPath);
+    },
+    replace: function replace(href, state) {
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].replace", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
+      }
+      var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),
+        route = _getRouteByHref2.route,
+        primaryPath = _getRouteByHref2.primaryPath;
+      return navigate(_extends({}, route, {
+        action: "replace"
+      }), primaryPath);
+    },
+    back: function back(amount) {
+      if (amount === void 0) {
+        amount = 1;
+      }
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].back", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
+      }
+      history.go(-amount);
+    },
+    forward: function forward(amount) {
+      if (amount === void 0) {
+        amount = 1;
+      }
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].forward", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
+      }
+      history.go(amount);
+    },
+    getInitialRoute: function getInitialRoute() {
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].getInitialRoute", [assert.numArgs([].slice.call(arguments), 0)]);
+      }
+      if (!initialRoute) {
+        var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());
+        if (!result.primaryPath) {
+          skipHandlingNextApplicationTriggeredNavigation = true;
+          result.route.replace();
+          result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());
         }
-        return applySessionOpts(session);
-      },
-      block: function block(blocker) {
-        blockerCollection.push(blocker);
-        var unblock = history.block(function (update) {
-          var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),
-            route = _getMatchingRoute2.route;
-          var action = update.action.toLowerCase();
-          blocker({
-            route: _extends({}, route, {
-              action: action
-            }),
-            retry: update.retry
-          });
-        });
-        return function () {
-          blockerCollection.splice(blockerCollection.findIndex(function (item) {
-            return item === blocker;
-          }), 1);
-          unblock();
-        };
-      },
-      listen: function listen(handler) {
-        return navigationHandlerManager.add(handler);
+        initialRoute = result.route;
       }
+      return initialRoute;
+    },
+    reset: function reset(session) {
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].reset", [assert.numArgs([].slice.call(arguments), 1), assert.type("object", "session", session)]);
+      }
+      return applySessionOpts(session);
+    },
+    block: function block(blocker) {
+      blockerCollection.push(blocker);
+      var unblock = history.block(function (update) {
+        var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),
+          route = _getMatchingRoute2.route;
+        var action = update.action.toLowerCase();
+        blocker({
+          route: _extends({}, route, {
+            action: action
+          }),
+          retry: update.retry
+        });
+      });
+      return function () {
+        blockerCollection.splice(blockerCollection.findIndex(function (item) {
+          return item === blocker;
+        }), 1);
+        unblock();
+      };
+    },
+    listen: function listen(handler) {
+      return navigationHandlerManager.add(handler);
     }
   };
+  var _ref = function () {
+      var route_current = session.getInitialRoute();
+      session.listen(function (route) {
+        return route_current = route;
+      });
+      function getRoute() {
+        return route_current;
+      }
+      return {
+        getRoute: getRoute
+      };
+    }(),
+    getRoute = _ref.getRoute;
+  var router = {
+    routes: routes,
+    session: session,
+    stopListening: function stopListening() {
+      return unlisten == null ? void 0 : unlisten();
+    },
+    getRoute: getRoute
+  };
   return router;
   function applySessionOpts(sessionOpts) {
     if (sessionOpts === void 0) {
@@ -1698,7 +1716,7 @@ function getParamDefKindSection(kind, trailing) {
   }
 }
 
-function createGroup(groupItems) {
+function createGroup_fromItems(groupItems) {
   if (process.env.NODE_ENV !== "production") {
     assert("createGroup", [assert.numArgs([].slice.call(arguments), 1), assert.arrayOfType(["RouteGroup", "RouteBuilder"], "groupItems", groupItems)]);
   }
@@ -1732,6 +1750,15 @@ function createGroup(groupItems) {
 function isRouteGroup(value) {
   return !!value.routeNames;
 }
+function createGroup_fromRouteDefs(routeDefs) {
+  var core = createRouter(routeDefs);
+  var group = createGroup_fromItems(Object.values(core.routes));
+  core.stopListening();
+  return group;
+}
+function createGroup(arg) {
+  return arg instanceof Array ? createGroup_fromItems(arg) : createGroup_fromRouteDefs(arg);
+}
 
 export { createGroup, createRouter, defineRoute, noMatch, param, preventDefaultLinkClickBehavior };
 //# sourceMappingURL=type-route.esm.js.map
diff --git a/node_modules/type-route/core/type-route.esm.js.map b/node_modules/type-route/core/type-route.esm.js.map
index ce6bd29..1b36523 100644
--- a/node_modules/type-route/core/type-route.esm.js.map
+++ b/node_modules/type-route/core/type-route.esm.js.map
@@ -1 +1 @@
-{"version":3,"file":"type-route.esm.js","sources":["../src/typeOf.ts","../src/TypeRouteError.ts","../src/asArray.ts","../src/assert.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/getStateMatch.ts","../src/getQueryMatch.ts","../src/createMatcher.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  App_should_be_wrapped_in_a_RouteProvider_component: {\n    errorCode: 1020,\n    getDetails() {\n      return [\n        \"Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook.\",\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session: {\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n    },\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n"],"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","App_should_be_wrapped_in_a_RouteProvider_component","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","process","env","NODE_ENV","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","_loop","_paramDef$Internal$v","paramValue","undefined","urlEncodeDefault","urlEncode","valueSerializer","getValue","valueSerializerId","id","_ret","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","router","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","_opts$arrayFormat3","_getRouterContext","defineRoute","assertDefineRouteOrExtendArgs","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup","groupItems","routeNames","isRouteGroup","has"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"type-route.esm.js","sources":["../src/typeOf.ts","../src/TypeRouteError.ts","../src/asArray.ts","../src/assert.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/getStateMatch.ts","../src/getQueryMatch.ts","../src/createMatcher.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  App_should_be_wrapped_in_a_RouteProvider_component: {\n    errorCode: 1020,\n    getDetails() {\n      return [\n        \"Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook.\",\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const session: UmbrellaCoreRouter[\"session\"] = {\n\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n\n  };\n\n  const { getRoute } = (() => {\n    let route_current = session.getInitialRoute();\n\n    session.listen(route => (route_current = route));\n\n    function getRoute() {\n        return route_current;\n    }\n\n    return { getRoute };\n  })();\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session,\n    stopListening: ()=> unlisten?.(),\n    getRoute\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder, CoreRouter } from \"./types\";\nimport { assert } from \"./assert\";\nimport { createRouter as coreCreateRouter } from \"./createRouter\";\n\nfunction createGroup_fromItems<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n\nexport function createGroup_fromRouteDefs<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n> {\n  const core = coreCreateRouter(routeDefs);\n\n  const group= createGroup_fromItems(\n    Object.values(core.routes)\n  );\n\n  core.stopListening();\n\n  return group;\n}\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;\nexport function createGroup<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n>;\nexport function createGroup(\n  arg: any[] | Record<string, unknown>\n): RouteGroup<any> {\n  return arg instanceof Array\n    ? createGroup_fromItems(arg)\n    : createGroup_fromRouteDefs(arg);\n}\n\n\n"],"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","App_should_be_wrapped_in_a_RouteProvider_component","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","process","env","NODE_ENV","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","_loop","_paramDef$Internal$v","paramValue","undefined","urlEncodeDefault","urlEncode","valueSerializer","getValue","valueSerializerId","id","_ret","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","route_current","getRoute","router","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","_opts$arrayFormat3","_getRouterContext","defineRoute","assertDefineRouteOrExtendArgs","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup_fromItems","groupItems","routeNames","isRouteGroup","has","createGroup_fromRouteDefs","core","coreCreateRouter","group","values","createGroup","arg"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/type-route/dist/index.d.ts b/node_modules/type-route/dist/index.d.ts
index 75b6f96..165a266 100644
--- a/node_modules/type-route/dist/index.d.ts
+++ b/node_modules/type-route/dist/index.d.ts
@@ -1,3 +1,5 @@
+import { History } from 'history';
+
 declare const noMatch: {
     readonly __noMatch: true;
 };
@@ -11,6 +13,14 @@ declare type KeysMatching<TObject, TCondition> = {
 declare type KeysDiffering<TObject, TCondition> = {
     [TKey in keyof TObject]: TObject[TKey] extends TCondition ? never : TKey;
 }[keyof TObject];
+declare type ErrorDef = {
+    errorCode: number;
+    getDetails: (...args: any[]) => string[];
+};
+declare type BuildPathDefErrorContext = {
+    routeName: string;
+    rawPath: string;
+};
 /**
  * Object for configuring a custom query string serializer. You likely
  * do not need this level of customization for your application.
@@ -40,6 +50,7 @@ declare type QueryStringSerializer = {
         value: string | null;
     }>) => string;
 };
+declare type ParamDefKind = "path" | "query" | "state";
 /**
  * Object for configuring a custom parameter value serializer.
  *
@@ -62,6 +73,20 @@ declare type ParamDef<TParamDefKind, TValue = unknown> = {
         trailing?: boolean;
     };
 };
+declare type UmbrellaParamDef = ParamDef<ParamDefKind>;
+declare type RouterContext = {
+    queryStringSerializer: QueryStringSerializer;
+    navigate: NavigateFunction;
+    arraySeparator: string;
+    history: History;
+    routeDefs: UmbrellaRouteDefCollection;
+    getRoutes: () => Record<string, UmbrellaRouteBuilder>;
+    baseUrl: string;
+};
+declare type ParamDefCollection<TParamDefKind> = {
+    [parameterName: string]: ParamDef<TParamDefKind>;
+};
+declare type UmbrellaParamDefCollection = ParamDefCollection<ParamDefKind>;
 declare type PathParamDef<TValue = unknown> = ParamDef<"path", TValue>;
 declare type NamedPathParamDef<TValue = unknown> = PathParamDef<TValue> & {
     paramName: string;
@@ -78,6 +103,10 @@ declare type PathSegmentDef = {
     namedParamDef: NamedPathParamDef | null;
 };
 declare type PathDef = PathSegmentDef[];
+declare type ParamIdCollection = {
+    [paramName: string]: string;
+};
+declare type GetRawPath = (paramIdCollection: ParamIdCollection) => string | string[];
 declare type PathParamNames<TParamDefCollection> = KeysMatching<TParamDefCollection, {
     ["~internal"]: {
         kind: "path";
@@ -139,6 +168,8 @@ declare type RouteDef<TParamDefCollection> = {
      */
     extend(path: string | string[]): RouteDef<TParamDefCollection>;
 };
+declare type UmbrellaRouteDef = RouteDef<UmbrellaParamDefCollection>;
+declare type NavigateFunction = (route: UmbrellaRoute, primaryPath: boolean) => void;
 declare type OnClickHandler = (event?: any) => void;
 declare type Link = {
     href: string;
@@ -166,6 +197,19 @@ declare type RouteBuilder<TRouteName, TParamDefCollection> = RouteParamsFunction
         Route: Route<TRouteName, TParamDefCollection>;
     };
 };
+declare type UmbrellaRouteBuilder = RouteBuilder<string, UmbrellaParamDefCollection>;
+declare type ClickEvent = {
+    preventDefault?: () => void;
+    button?: number | null;
+    defaultPrevented?: boolean | null;
+    metaKey?: boolean | null;
+    altKey?: boolean | null;
+    ctrlKey?: boolean | null;
+    shiftKey?: boolean | null;
+    target?: {
+        target?: string | null;
+    } | null;
+};
 declare type Action = "push" | "replace" | "pop";
 declare type RouteDefCollectionRoute<TRouteDefCollection> = TRouteDefCollection extends Record<string, RouteDef<any>> ? {
     [TRouteName in keyof TRouteDefCollection]: Route<TRouteName, TRouteDefCollection[TRouteName]["~internal"]["params"]>;
@@ -227,7 +271,9 @@ declare type GetRoute<T> = T extends {
         Route: any;
     };
 }> ? T[keyof T]["~internal"]["Route"] | NotFoundRoute : never;
+declare type UmbrellaRoute = Route<string | false, Record<string, any>>;
 declare type NavigationHandler<TRouteDefCollection> = (route: RouteDefCollectionRoute<TRouteDefCollection>) => void;
+declare type UmbrellaNavigationHandler = NavigationHandler<UmbrellaRouteDefCollection>;
 declare type Unblock = () => void;
 declare type Blocker<TRouteDefCollection> = (update: {
     /**
@@ -241,6 +287,7 @@ declare type Blocker<TRouteDefCollection> = (update: {
      */
     retry: () => void;
 }) => void;
+declare type UmbrellaBlocker = Blocker<UmbrellaRouteDefCollection>;
 /**
  * Functions for interacting with the current history session.
  */
@@ -285,6 +332,7 @@ declare type RouterSession<TRouteDefCollection> = {
      */
     listen(handler: NavigationHandler<TRouteDefCollection>): Unlisten;
 };
+declare type UmbrellaRouterSession = RouterSession<UmbrellaRouteDefCollection>;
 declare type MemoryHistorySessionOpts = {
     type: "memory";
     /**
@@ -362,6 +410,7 @@ declare type RouterOpts = {
 declare type Unlisten = {
     (): void;
 };
+declare type UmbrellaRouteDefCollection = Record<string, UmbrellaRouteDef>;
 declare type CoreRouter<TRouteDefCollection extends {
     [routeName: string]: any;
 }> = {
@@ -372,7 +421,10 @@ declare type CoreRouter<TRouteDefCollection extends {
         [TRouteName in keyof TRouteDefCollection]: RouteBuilder<TRouteName, TRouteDefCollection[TRouteName]["~internal"]["params"]>;
     };
     session: RouterSession<TRouteDefCollection>;
+    stopListening: () => void;
+    getRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;
 };
+declare type UmbrellaCoreRouter = CoreRouter<UmbrellaRouteDefCollection>;
 declare type RouteGroup<T extends any[] = any[]> = {
     ["~internal"]: {
         type: "RouteGroup";
@@ -388,6 +440,134 @@ declare type RouteGroup<T extends any[] = any[]> = {
     has(route: Route<any, any>): route is T[number]["~internal"]["Route"];
 };
 
+type types_d_Compute<A extends any> = Compute<A>;
+type types_d_KeysMatching<TObject, TCondition> = KeysMatching<TObject, TCondition>;
+type types_d_KeysDiffering<TObject, TCondition> = KeysDiffering<TObject, TCondition>;
+type types_d_ErrorDef = ErrorDef;
+type types_d_BuildPathDefErrorContext = BuildPathDefErrorContext;
+type types_d_QueryStringSerializer = QueryStringSerializer;
+type types_d_ParamDefKind = ParamDefKind;
+type types_d_ValueSerializer<TValue = unknown> = ValueSerializer<TValue>;
+type types_d_ParamDef<TParamDefKind, TValue = unknown> = ParamDef<TParamDefKind, TValue>;
+type types_d_UmbrellaParamDef = UmbrellaParamDef;
+type types_d_RouterContext = RouterContext;
+type types_d_ParamDefCollection<TParamDefKind> = ParamDefCollection<TParamDefKind>;
+type types_d_UmbrellaParamDefCollection = UmbrellaParamDefCollection;
+type types_d_PathParamDef<TValue = unknown> = PathParamDef<TValue>;
+type types_d_NamedPathParamDef<TValue = unknown> = NamedPathParamDef<TValue>;
+type types_d_RouterLocation = RouterLocation;
+type types_d_PathSegmentDef = PathSegmentDef;
+type types_d_PathDef = PathDef;
+type types_d_ParamIdCollection = ParamIdCollection;
+type types_d_GetRawPath = GetRawPath;
+type types_d_PathParamNames<TParamDefCollection> = PathParamNames<TParamDefCollection>;
+type types_d_ParamValue<TParamDef> = ParamValue<TParamDef>;
+type types_d_PathParams<TParamDefCollection> = PathParams<TParamDefCollection>;
+type types_d_PathFn<TParamDefCollection> = PathFn<TParamDefCollection>;
+type types_d_RouteDef<TParamDefCollection> = RouteDef<TParamDefCollection>;
+type types_d_UmbrellaRouteDef = UmbrellaRouteDef;
+type types_d_NavigateFunction = NavigateFunction;
+type types_d_OnClickHandler = OnClickHandler;
+type types_d_Link = Link;
+type types_d_Match = Match;
+type types_d_RouteBuilder<TRouteName, TParamDefCollection> = RouteBuilder<TRouteName, TParamDefCollection>;
+type types_d_UmbrellaRouteBuilder = UmbrellaRouteBuilder;
+type types_d_ClickEvent = ClickEvent;
+type types_d_Action = Action;
+type types_d_RouteDefCollectionRoute<TRouteDefCollection> = RouteDefCollectionRoute<TRouteDefCollection>;
+type types_d_NotFoundRoute = NotFoundRoute;
+type types_d_Route<TName, TParamDefCollection> = Route<TName, TParamDefCollection>;
+type types_d_GetRoute<T> = GetRoute<T>;
+type types_d_UmbrellaRoute = UmbrellaRoute;
+type types_d_NavigationHandler<TRouteDefCollection> = NavigationHandler<TRouteDefCollection>;
+type types_d_UmbrellaNavigationHandler = UmbrellaNavigationHandler;
+type types_d_Blocker<TRouteDefCollection> = Blocker<TRouteDefCollection>;
+type types_d_UmbrellaBlocker = UmbrellaBlocker;
+type types_d_RouterSession<TRouteDefCollection> = RouterSession<TRouteDefCollection>;
+type types_d_UmbrellaRouterSession = UmbrellaRouterSession;
+type types_d_MemoryHistorySessionOpts = MemoryHistorySessionOpts;
+type types_d_HashHistorySessionOpts = HashHistorySessionOpts;
+type types_d_BrowserHistorySessionOpts = BrowserHistorySessionOpts;
+type types_d_SessionOpts = SessionOpts;
+type types_d_QueryStringArrayFormat = QueryStringArrayFormat;
+type types_d_ArrayFormat = ArrayFormat;
+type types_d_RouterOpts = RouterOpts;
+type types_d_Unlisten = Unlisten;
+type types_d_UmbrellaRouteDefCollection = UmbrellaRouteDefCollection;
+type types_d_CoreRouter<TRouteDefCollection extends {
+    [routeName: string]: any;
+}> = CoreRouter<TRouteDefCollection>;
+type types_d_UmbrellaCoreRouter = UmbrellaCoreRouter;
+type types_d_RouteGroup<T extends any[] = any[]> = RouteGroup<T>;
+declare namespace types_d {
+  export {
+    types_d_Compute as Compute,
+    types_d_KeysMatching as KeysMatching,
+    types_d_KeysDiffering as KeysDiffering,
+    types_d_ErrorDef as ErrorDef,
+    types_d_BuildPathDefErrorContext as BuildPathDefErrorContext,
+    types_d_QueryStringSerializer as QueryStringSerializer,
+    types_d_ParamDefKind as ParamDefKind,
+    types_d_ValueSerializer as ValueSerializer,
+    types_d_ParamDef as ParamDef,
+    types_d_UmbrellaParamDef as UmbrellaParamDef,
+    types_d_RouterContext as RouterContext,
+    types_d_ParamDefCollection as ParamDefCollection,
+    types_d_UmbrellaParamDefCollection as UmbrellaParamDefCollection,
+    types_d_PathParamDef as PathParamDef,
+    types_d_NamedPathParamDef as NamedPathParamDef,
+    types_d_RouterLocation as RouterLocation,
+    types_d_PathSegmentDef as PathSegmentDef,
+    types_d_PathDef as PathDef,
+    types_d_ParamIdCollection as ParamIdCollection,
+    types_d_GetRawPath as GetRawPath,
+    types_d_PathParamNames as PathParamNames,
+    types_d_ParamValue as ParamValue,
+    types_d_PathParams as PathParams,
+    types_d_PathFn as PathFn,
+    types_d_RouteDef as RouteDef,
+    types_d_UmbrellaRouteDef as UmbrellaRouteDef,
+    types_d_NavigateFunction as NavigateFunction,
+    types_d_OnClickHandler as OnClickHandler,
+    types_d_Link as Link,
+    types_d_Match as Match,
+    types_d_RouteBuilder as RouteBuilder,
+    types_d_UmbrellaRouteBuilder as UmbrellaRouteBuilder,
+    types_d_ClickEvent as ClickEvent,
+    types_d_Action as Action,
+    types_d_RouteDefCollectionRoute as RouteDefCollectionRoute,
+    types_d_NotFoundRoute as NotFoundRoute,
+    types_d_Route as Route,
+    types_d_GetRoute as GetRoute,
+    types_d_UmbrellaRoute as UmbrellaRoute,
+    types_d_NavigationHandler as NavigationHandler,
+    types_d_UmbrellaNavigationHandler as UmbrellaNavigationHandler,
+    types_d_Blocker as Blocker,
+    types_d_UmbrellaBlocker as UmbrellaBlocker,
+    types_d_RouterSession as RouterSession,
+    types_d_UmbrellaRouterSession as UmbrellaRouterSession,
+    types_d_MemoryHistorySessionOpts as MemoryHistorySessionOpts,
+    types_d_HashHistorySessionOpts as HashHistorySessionOpts,
+    types_d_BrowserHistorySessionOpts as BrowserHistorySessionOpts,
+    types_d_SessionOpts as SessionOpts,
+    types_d_QueryStringArrayFormat as QueryStringArrayFormat,
+    types_d_ArrayFormat as ArrayFormat,
+    types_d_RouterOpts as RouterOpts,
+    types_d_Unlisten as Unlisten,
+    types_d_UmbrellaRouteDefCollection as UmbrellaRouteDefCollection,
+    types_d_CoreRouter as CoreRouter,
+    types_d_UmbrellaCoreRouter as UmbrellaCoreRouter,
+    types_d_RouteGroup as RouteGroup,
+  };
+}
+
+declare function createRouter$1<TRouteDefCollection extends {
+    [routeName: string]: any;
+}>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;
+declare function createRouter$1<TRouteDefCollection extends {
+    [routeName: string]: any;
+}>(opts: RouterOpts, routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;
+
 declare function defineRoute<TParamDefCollection>(params: TParamDefCollection, path: PathFn<TParamDefCollection>): RouteDef<TParamDefCollection>;
 declare function defineRoute(path: string | string[]): RouteDef<{}>;
 
@@ -1483,18 +1663,25 @@ declare const param: {
 };
 
 declare function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;
+declare function createGroup<TRouteDefCollection extends {
+    [routeName: string]: any;
+}>(routeDefs: TRouteDefCollection): RouteGroup<CoreRouter<TRouteDefCollection>["routes"][keyof TRouteDefCollection][]>;
 
 declare function preventDefaultLinkClickBehavior(event?: any): boolean;
 
 declare type Router<TRouteDefCollection extends {
     [routeName: string]: any;
-}> = CoreRouter<TRouteDefCollection> & {
+}> = Omit<CoreRouter<TRouteDefCollection>, "stopListening"> & {
     /**
      * React hook for retrieving the current route.
      *
      * @see https://type-route.zilch.dev/api-reference/router/use-route
      */
     useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;
+    /**
+     * Get current route synchronously outside of react.
+     */
+    getRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;
     /**
      * React component which connects React to Type Route and provides the current route to the rest of the application.
      *
@@ -1511,4 +1698,4 @@ declare function createRouter<TRouteDefCollection extends {
     [routeName: string]: any;
 }>(opts: RouterOpts, routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;
 
-export { Link, QueryStringSerializer, GetRoute as Route, RouterOpts, SessionOpts, ValueSerializer, createGroup, createRouter, defineRoute, noMatch, param, preventDefaultLinkClickBehavior };
+export { Link, QueryStringSerializer, GetRoute as Route, RouterOpts, SessionOpts, ValueSerializer, createRouter$1 as coreCreateRouter, createGroup, createRouter, defineRoute, noMatch, param, preventDefaultLinkClickBehavior, types_d as types };
diff --git a/node_modules/type-route/dist/tools/createForwardingProxy.d.ts b/node_modules/type-route/dist/tools/createForwardingProxy.d.ts
new file mode 100644
index 0000000..36c6a31
--- /dev/null
+++ b/node_modules/type-route/dist/tools/createForwardingProxy.d.ts
@@ -0,0 +1,11 @@
+/**
+ * Creates a proxy that forwards EVERYTHING to the current target.
+ * The proxy has a stable identity, and you can update the target at runtime.
+ */
+export declare function createForwardingProxy<T extends object>(params: {
+    accessBeforeSetErrorMessage?: string;
+    isFunction: boolean;
+}): {
+    proxy: T;
+    updateTarget(newTarget: T): void;
+};
diff --git a/node_modules/type-route/dist/type-route.cjs.development.js b/node_modules/type-route/dist/type-route.cjs.development.js
index c3294b6..7a4f2d8 100644
--- a/node_modules/type-route/dist/type-route.cjs.development.js
+++ b/node_modules/type-route/dist/type-route.cjs.development.js
@@ -1272,95 +1272,113 @@ function createRouter() {
   var blockerCollection = [];
   applySessionOpts(opts.session);
   var routes = createRouteBuilderCollection(getRouterContext);
-  var router = {
-    routes: routes,
-    session: {
-      push: function push(href, state) {
-        {
-          assert("[RouterSessionHistory].push", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
-        }
-        var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),
-          route = _getRouteByHref.route,
-          primaryPath = _getRouteByHref.primaryPath;
-        return navigate(_extends({}, route, {
-          action: "push"
-        }), primaryPath);
-      },
-      replace: function replace(href, state) {
-        {
-          assert("[RouterSessionHistory].replace", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
-        }
-        var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),
-          route = _getRouteByHref2.route,
-          primaryPath = _getRouteByHref2.primaryPath;
-        return navigate(_extends({}, route, {
-          action: "replace"
-        }), primaryPath);
-      },
-      back: function back(amount) {
-        if (amount === void 0) {
-          amount = 1;
-        }
-        {
-          assert("[RouterSessionHistory].back", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
-        }
-        history$1.go(-amount);
-      },
-      forward: function forward(amount) {
-        if (amount === void 0) {
-          amount = 1;
-        }
-        {
-          assert("[RouterSessionHistory].forward", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
-        }
-        history$1.go(amount);
-      },
-      getInitialRoute: function getInitialRoute() {
-        {
-          assert("[RouterSessionHistory].getInitialRoute", [assert.numArgs([].slice.call(arguments), 0)]);
-        }
-        if (!initialRoute) {
-          var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history$1.location, baseUrl), getRouterContext());
-          if (!result.primaryPath) {
-            skipHandlingNextApplicationTriggeredNavigation = true;
-            result.route.replace();
-            result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history$1.location, baseUrl), getRouterContext());
-          }
-          initialRoute = result.route;
-        }
-        return initialRoute;
-      },
-      reset: function reset(session) {
-        {
-          assert("[RouterSessionHistory].reset", [assert.numArgs([].slice.call(arguments), 1), assert.type("object", "session", session)]);
+  var session = {
+    push: function push(href, state) {
+      {
+        assert("[RouterSessionHistory].push", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
+      }
+      var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),
+        route = _getRouteByHref.route,
+        primaryPath = _getRouteByHref.primaryPath;
+      return navigate(_extends({}, route, {
+        action: "push"
+      }), primaryPath);
+    },
+    replace: function replace(href, state) {
+      {
+        assert("[RouterSessionHistory].replace", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
+      }
+      var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),
+        route = _getRouteByHref2.route,
+        primaryPath = _getRouteByHref2.primaryPath;
+      return navigate(_extends({}, route, {
+        action: "replace"
+      }), primaryPath);
+    },
+    back: function back(amount) {
+      if (amount === void 0) {
+        amount = 1;
+      }
+      {
+        assert("[RouterSessionHistory].back", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
+      }
+      history$1.go(-amount);
+    },
+    forward: function forward(amount) {
+      if (amount === void 0) {
+        amount = 1;
+      }
+      {
+        assert("[RouterSessionHistory].forward", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
+      }
+      history$1.go(amount);
+    },
+    getInitialRoute: function getInitialRoute() {
+      {
+        assert("[RouterSessionHistory].getInitialRoute", [assert.numArgs([].slice.call(arguments), 0)]);
+      }
+      if (!initialRoute) {
+        var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history$1.location, baseUrl), getRouterContext());
+        if (!result.primaryPath) {
+          skipHandlingNextApplicationTriggeredNavigation = true;
+          result.route.replace();
+          result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history$1.location, baseUrl), getRouterContext());
         }
-        return applySessionOpts(session);
-      },
-      block: function block(blocker) {
-        blockerCollection.push(blocker);
-        var unblock = history$1.block(function (update) {
-          var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),
-            route = _getMatchingRoute2.route;
-          var action = update.action.toLowerCase();
-          blocker({
-            route: _extends({}, route, {
-              action: action
-            }),
-            retry: update.retry
-          });
-        });
-        return function () {
-          blockerCollection.splice(blockerCollection.findIndex(function (item) {
-            return item === blocker;
-          }), 1);
-          unblock();
-        };
-      },
-      listen: function listen(handler) {
-        return navigationHandlerManager.add(handler);
+        initialRoute = result.route;
+      }
+      return initialRoute;
+    },
+    reset: function reset(session) {
+      {
+        assert("[RouterSessionHistory].reset", [assert.numArgs([].slice.call(arguments), 1), assert.type("object", "session", session)]);
       }
+      return applySessionOpts(session);
+    },
+    block: function block(blocker) {
+      blockerCollection.push(blocker);
+      var unblock = history$1.block(function (update) {
+        var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),
+          route = _getMatchingRoute2.route;
+        var action = update.action.toLowerCase();
+        blocker({
+          route: _extends({}, route, {
+            action: action
+          }),
+          retry: update.retry
+        });
+      });
+      return function () {
+        blockerCollection.splice(blockerCollection.findIndex(function (item) {
+          return item === blocker;
+        }), 1);
+        unblock();
+      };
+    },
+    listen: function listen(handler) {
+      return navigationHandlerManager.add(handler);
     }
   };
+  var _ref = function () {
+      var route_current = session.getInitialRoute();
+      session.listen(function (route) {
+        return route_current = route;
+      });
+      function getRoute() {
+        return route_current;
+      }
+      return {
+        getRoute: getRoute
+      };
+    }(),
+    getRoute = _ref.getRoute;
+  var router = {
+    routes: routes,
+    session: session,
+    stopListening: function stopListening() {
+      return unlisten == null ? void 0 : unlisten();
+    },
+    getRoute: getRoute
+  };
   return router;
   function applySessionOpts(sessionOpts) {
     if (sessionOpts === void 0) {
@@ -1480,6 +1498,84 @@ function createRouteBuilderCollection(getRouterContext) {
   return routes;
 }
 
+/**
+ * Creates a proxy that forwards EVERYTHING to the current target.
+ * The proxy has a stable identity, and you can update the target at runtime.
+ */
+function createForwardingProxy(params) {
+  var _params$accessBeforeS = params.accessBeforeSetErrorMessage,
+    accessBeforeSetErrorMessage = _params$accessBeforeS === void 0 ? "Assertion error: Forwarded proxy accessed too early" : _params$accessBeforeS,
+    isFunction = params.isFunction;
+  var checkSet = function checkSet() {
+    if (target === undefined) {
+      throw new Error(accessBeforeSetErrorMessage);
+    }
+  };
+  var target = undefined;
+  var handler = {
+    get: function get(_t, prop, receiver) {
+      checkSet();
+      return Reflect.get(target, prop, receiver);
+    },
+    set: function set(_t, prop, value, receiver) {
+      checkSet();
+      return Reflect.set(target, prop, value, receiver);
+    },
+    has: function has(_t, prop) {
+      checkSet();
+      return Reflect.has(target, prop);
+    },
+    deleteProperty: function deleteProperty(_t, prop) {
+      checkSet();
+      return Reflect.deleteProperty(target, prop);
+    },
+    ownKeys: function ownKeys(_t) {
+      checkSet();
+      return Reflect.ownKeys(target);
+    },
+    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(_t, prop) {
+      checkSet();
+      return Reflect.getOwnPropertyDescriptor(target, prop);
+    },
+    defineProperty: function defineProperty(_t, prop, descriptor) {
+      checkSet();
+      return Reflect.defineProperty(target, prop, descriptor);
+    },
+    getPrototypeOf: function getPrototypeOf(_t) {
+      checkSet();
+      return Reflect.getPrototypeOf(target);
+    },
+    setPrototypeOf: function setPrototypeOf(_t, proto) {
+      checkSet();
+      return Reflect.setPrototypeOf(target, proto);
+    },
+    isExtensible: function isExtensible(_t) {
+      checkSet();
+      return Reflect.isExtensible(target);
+    },
+    preventExtensions: function preventExtensions(_t) {
+      checkSet();
+      return Reflect.preventExtensions(target);
+    },
+    apply: function apply(_t, thisArg, args) {
+      checkSet();
+      return Reflect.apply(target, thisArg, args);
+    },
+    construct: function construct(_t, args, newTarget) {
+      checkSet();
+      return Reflect.construct(target, args, newTarget);
+    }
+  };
+  // Use a dummy callable so proxy can stand in for both functions and objects
+  var proxy = new Proxy(isFunction ? function () {} : {}, handler);
+  return {
+    proxy: proxy,
+    updateTarget: function updateTarget(newTarget) {
+      target = newTarget;
+    }
+  };
+}
+
 function defineRoute() {
   for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
     args[_key] = arguments[_key];
@@ -1703,7 +1799,7 @@ function getParamDefKindSection(kind, trailing) {
   }
 }
 
-function createGroup(groupItems) {
+function createGroup_fromItems(groupItems) {
   {
     assert("createGroup", [assert.numArgs([].slice.call(arguments), 1), assert.arrayOfType(["RouteGroup", "RouteBuilder"], "groupItems", groupItems)]);
   }
@@ -1737,6 +1833,15 @@ function createGroup(groupItems) {
 function isRouteGroup(value) {
   return !!value.routeNames;
 }
+function createGroup_fromRouteDefs(routeDefs) {
+  var core = createRouter(routeDefs);
+  var group = createGroup_fromItems(Object.values(core.routes));
+  core.stopListening();
+  return group;
+}
+function createGroup(arg) {
+  return arg instanceof Array ? createGroup_fromItems(arg) : createGroup_fromRouteDefs(arg);
+}
 
 {
   var _React$version$split$ = /*#__PURE__*/React.version.split(".").map(function (value) {
@@ -1748,6 +1853,21 @@ function isRouteGroup(value) {
     throw TypeRouteError.Invalid_React_version.create(React.version);
   }
 }
+var fpRoutes = /*#__PURE__*/createForwardingProxy({
+  isFunction: false
+});
+var fpSession = /*#__PURE__*/createForwardingProxy({
+  isFunction: false
+});
+var fpRouteProvider = /*#__PURE__*/createForwardingProxy({
+  isFunction: true
+});
+var fpUseRoute = /*#__PURE__*/createForwardingProxy({
+  isFunction: true
+});
+var fpGetRoute = /*#__PURE__*/createForwardingProxy({
+  isFunction: true
+});
 function createRouter$1() {
   for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
     args[_key] = arguments[_key];
@@ -1755,20 +1875,19 @@ function createRouter$1() {
   var _parseArgs = parseArgs(args),
     opts = _parseArgs.opts,
     routeDefs = _parseArgs.routeDefs;
-  var router = createRouter(_extends({}, opts, {
-    scrollToTop: false
-  }), routeDefs);
+  var _coreCreateRouter = createRouter(_extends({}, opts, {
+      scrollToTop: false
+    }), routeDefs),
+    routes = _coreCreateRouter.routes,
+    session = _coreCreateRouter.session,
+    getRoute = _coreCreateRouter.getRoute;
   var routeContext = React.createContext(null);
-  return _extends({}, router, {
-    RouteProvider: RouteProvider,
-    useRoute: useRoute
-  });
   function RouteProvider(props) {
-    var _React$useState = React.useState(router.session.getInitialRoute()),
+    var _React$useState = React.useState(session.getInitialRoute()),
       route = _React$useState[0],
       setRoute = _React$useState[1];
     React.useLayoutEffect(function () {
-      return router.session.listen(setRoute);
+      return session.listen(setRoute);
     }, []);
     React.useEffect(function () {
       attemptScrollToTop(route, opts.scrollToTop);
@@ -1786,8 +1905,21 @@ function createRouter$1() {
     }
     return route;
   }
+  fpRoutes.updateTarget(routes);
+  fpSession.updateTarget(session);
+  fpRouteProvider.updateTarget(RouteProvider);
+  fpUseRoute.updateTarget(useRoute);
+  fpGetRoute.updateTarget(getRoute);
+  return {
+    routes: fpRoutes.proxy,
+    session: fpSession.proxy,
+    RouteProvider: fpRouteProvider.proxy,
+    useRoute: fpUseRoute.proxy,
+    getRoute: fpGetRoute.proxy
+  };
 }
 
+exports.coreCreateRouter = createRouter;
 exports.createGroup = createGroup;
 exports.createRouter = createRouter$1;
 exports.defineRoute = defineRoute;
diff --git a/node_modules/type-route/dist/type-route.cjs.development.js.map b/node_modules/type-route/dist/type-route.cjs.development.js.map
index bbb1b1c..dc6af6c 100644
--- a/node_modules/type-route/dist/type-route.cjs.development.js.map
+++ b/node_modules/type-route/dist/type-route.cjs.development.js.map
@@ -1 +1 @@
-{"version":3,"file":"type-route.cjs.development.js","sources":["../src/typeOf.ts","../src/TypeRouteError.ts","../src/asArray.ts","../src/assert.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/getStateMatch.ts","../src/getQueryMatch.ts","../src/createMatcher.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts","../src/react.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  App_should_be_wrapped_in_a_RouteProvider_component: {\n    errorCode: 1020,\n    getDetails() {\n      return [\n        \"Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook.\",\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session: {\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n    },\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n","import {\n  CoreRouter,\n  UmbrellaRouteDefCollection,\n  UmbrellaRoute,\n  RouteDefCollectionRoute,\n  RouterOpts,\n} from \"./types\";\nimport { createRouter as coreCreateRouter, parseArgs } from \"./createRouter\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport * as React from \"react\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\n\nif (typeof __DEV__ === \"boolean\" && __DEV__) {\n  const [major, minor] = React.version\n    .split(\".\")\n    .map((value: string) => parseInt(value, 10));\n\n  if (major < 16 || (major === 16 && minor < 8)) {\n    throw TypeRouteError.Invalid_React_version.create(React.version);\n  }\n}\n\nexport { defineRoute } from \"./defineRoute\";\nexport { param } from \"./param\";\nexport { createGroup } from \"./createGroup\";\nexport { noMatch } from \"./noMatch\";\nexport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nexport {\n  GetRoute as Route,\n  Link,\n  ValueSerializer,\n  QueryStringSerializer,\n  SessionOpts,\n  RouterOpts,\n} from \"./types\";\n\ntype Router<TRouteDefCollection extends { [routeName: string]: any }> =\n  CoreRouter<TRouteDefCollection> & {\n    /**\n     * React hook for retrieving the current route.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/use-route\n     */\n    useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;\n\n    /**\n     * React component which connects React to Type Route and provides the current route to the rest of the application.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/route-provider\n     */\n    RouteProvider: (props: { children?: any }) => any;\n  };\ntype UmbrellaRouter = Router<UmbrellaRouteDefCollection>;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): Router<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaRouter {\n  const { opts, routeDefs } = parseArgs(args);\n  const router = coreCreateRouter({ ...opts, scrollToTop: false }, routeDefs);\n  const routeContext = React.createContext<UmbrellaRoute | null>(null);\n\n  return {\n    ...router,\n    RouteProvider,\n    useRoute,\n  };\n\n  function RouteProvider(props: { children?: any }) {\n    const [route, setRoute] = React.useState(router.session.getInitialRoute());\n\n    React.useLayoutEffect(() => router.session.listen(setRoute), []);\n\n    React.useEffect(() => {\n      attemptScrollToTop(route, opts.scrollToTop);\n    }, [route]);\n\n    return React.createElement(\n      routeContext.Provider,\n      { value: route },\n      props.children\n    );\n  }\n\n  function useRoute() {\n    const route = React.useContext(routeContext);\n\n    if (__DEV__) {\n      if (route === null) {\n        throw TypeRouteError.App_should_be_wrapped_in_a_RouteProvider_component.create();\n      }\n    }\n\n    return route!;\n  }\n}\n"],"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","App_should_be_wrapped_in_a_RouteProvider_component","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","_loop","_paramDef$Internal$v","paramValue","undefined","urlEncodeDefault","urlEncode","valueSerializer","getValue","valueSerializerId","id","_ret","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","router","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","_opts$arrayFormat3","_getRouterContext","defineRoute","assertDefineRouteOrExtendArgs","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup","groupItems","routeNames","isRouteGroup","has","_React$version$split$","React","parseInt","major","minor","coreCreateRouter","routeContext","RouteProvider","useRoute","props","_React$useState","setRoute","Provider","children"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"type-route.cjs.development.js","sources":["../src/typeOf.ts","../src/TypeRouteError.ts","../src/asArray.ts","../src/assert.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/getStateMatch.ts","../src/getQueryMatch.ts","../src/createMatcher.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/tools/createForwardingProxy.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts","../src/react.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  App_should_be_wrapped_in_a_RouteProvider_component: {\n    errorCode: 1020,\n    getDetails() {\n      return [\n        \"Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook.\",\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const session: UmbrellaCoreRouter[\"session\"] = {\n\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n\n  };\n\n  const { getRoute } = (() => {\n    let route_current = session.getInitialRoute();\n\n    session.listen(route => (route_current = route));\n\n    function getRoute() {\n        return route_current;\n    }\n\n    return { getRoute };\n  })();\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session,\n    stopListening: ()=> unlisten?.(),\n    getRoute\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","/**\n * Creates a proxy that forwards EVERYTHING to the current target.\n * The proxy has a stable identity, and you can update the target at runtime.\n */\nexport function createForwardingProxy<T extends object>(params: {\n  accessBeforeSetErrorMessage?: string;\n  isFunction: boolean;\n}) {\n  const { accessBeforeSetErrorMessage = \"Assertion error: Forwarded proxy accessed too early\", isFunction } =\n    params;\n\n  const checkSet = () => {\n    if (target === undefined) {\n      throw new Error(accessBeforeSetErrorMessage);\n    }\n  };\n\n  let target: any = undefined;\n\n  const handler: ProxyHandler<any> = {\n    get(_t, prop, receiver) {\n      checkSet();\n      return Reflect.get(target, prop, receiver);\n    },\n    set(_t, prop, value, receiver) {\n      checkSet();\n      return Reflect.set(target, prop, value, receiver);\n    },\n    has(_t, prop) {\n      checkSet();\n      return Reflect.has(target, prop);\n    },\n    deleteProperty(_t, prop) {\n      checkSet();\n      return Reflect.deleteProperty(target, prop);\n    },\n    ownKeys(_t) {\n      checkSet();\n      return Reflect.ownKeys(target);\n    },\n    getOwnPropertyDescriptor(_t, prop) {\n      checkSet();\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    },\n    defineProperty(_t, prop, descriptor) {\n      checkSet();\n      return Reflect.defineProperty(target, prop, descriptor);\n    },\n    getPrototypeOf(_t) {\n      checkSet();\n      return Reflect.getPrototypeOf(target);\n    },\n    setPrototypeOf(_t, proto) {\n      checkSet();\n      return Reflect.setPrototypeOf(target, proto);\n    },\n    isExtensible(_t) {\n      checkSet();\n      return Reflect.isExtensible(target);\n    },\n    preventExtensions(_t) {\n      checkSet();\n      return Reflect.preventExtensions(target);\n    },\n    apply(_t, thisArg, args) {\n      checkSet();\n      return Reflect.apply(target, thisArg, args);\n    },\n    construct(_t, args, newTarget) {\n      checkSet();\n      return Reflect.construct(target, args, newTarget);\n    },\n  };\n\n  // Use a dummy callable so proxy can stand in for both functions and objects\n  const proxy = new Proxy(isFunction ? (function (){}) : {}, handler) as T;\n\n  return {\n    proxy,\n    updateTarget(newTarget: T) {\n      target = newTarget;\n    },\n  };\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder, CoreRouter } from \"./types\";\nimport { assert } from \"./assert\";\nimport { createRouter as coreCreateRouter } from \"./createRouter\";\n\nfunction createGroup_fromItems<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n\nexport function createGroup_fromRouteDefs<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n> {\n  const core = coreCreateRouter(routeDefs);\n\n  const group= createGroup_fromItems(\n    Object.values(core.routes)\n  );\n\n  core.stopListening();\n\n  return group;\n}\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;\nexport function createGroup<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n>;\nexport function createGroup(\n  arg: any[] | Record<string, unknown>\n): RouteGroup<any> {\n  return arg instanceof Array\n    ? createGroup_fromItems(arg)\n    : createGroup_fromRouteDefs(arg);\n}\n\n\n","import {\n  CoreRouter,\n  UmbrellaRouteDefCollection,\n  UmbrellaRoute,\n  RouteDefCollectionRoute,\n  RouterOpts,\n} from \"./types\";\nimport { createRouter as coreCreateRouter, parseArgs } from \"./createRouter\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport * as React from \"react\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { createForwardingProxy } from \"./tools/createForwardingProxy\";\n\nimport * as types from \"./types\";\n\nexport type { types };\nexport { coreCreateRouter };\n\nif (typeof __DEV__ === \"boolean\" && __DEV__) {\n  const [major, minor] = React.version\n    .split(\".\")\n    .map((value: string) => parseInt(value, 10));\n\n  if (major < 16 || (major === 16 && minor < 8)) {\n    throw TypeRouteError.Invalid_React_version.create(React.version);\n  }\n}\n\nexport { defineRoute } from \"./defineRoute\";\nexport { param } from \"./param\";\nexport { createGroup } from \"./createGroup\";\nexport { noMatch } from \"./noMatch\";\nexport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nexport {\n  GetRoute as Route,\n  Link,\n  ValueSerializer,\n  QueryStringSerializer,\n  SessionOpts,\n  RouterOpts,\n} from \"./types\";\n\ntype Router<TRouteDefCollection extends { [routeName: string]: any }> =\n  Omit<CoreRouter<TRouteDefCollection>, \"stopListening\"> & {\n    /**\n     * React hook for retrieving the current route.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/use-route\n     */\n    useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;\n\n    /**\n     * Get current route synchronously outside of react.\n     */\n    getRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;\n\n    /**\n     * React component which connects React to Type Route and provides the current route to the rest of the application.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/route-provider\n     */\n    RouteProvider: (props: { children?: any }) => any;\n  };\ntype UmbrellaRouter = Router<UmbrellaRouteDefCollection>;\n\nconst fpRoutes = createForwardingProxy<UmbrellaRouter[\"routes\"]>({\n  isFunction: false\n});\nconst fpSession = createForwardingProxy<UmbrellaRouter[\"session\"]>({\n  isFunction: false\n});\nconst fpRouteProvider = createForwardingProxy<UmbrellaRouter[\"RouteProvider\"]>({\n  isFunction: true\n});\nconst fpUseRoute = createForwardingProxy<UmbrellaRouter[\"useRoute\"]>({\n  isFunction: true\n});\nconst fpGetRoute = createForwardingProxy<UmbrellaRouter[\"getRoute\"]>({\n  isFunction: true\n});\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): Router<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaRouter {\n  const { opts, routeDefs } = parseArgs(args);\n  const { routes, session, getRoute } = coreCreateRouter({ ...opts, scrollToTop: false }, routeDefs);\n  const routeContext = React.createContext<UmbrellaRoute | null>(null);\n\n  function RouteProvider(props: { children?: any }) {\n    const [route, setRoute] = React.useState(session.getInitialRoute());\n\n    React.useLayoutEffect(() => session.listen(setRoute), []);\n\n    React.useEffect(() => {\n      attemptScrollToTop(route, opts.scrollToTop);\n    }, [route]);\n\n    return React.createElement(\n      routeContext.Provider,\n      { value: route },\n      props.children\n    );\n  }\n\n  function useRoute() {\n    const route = React.useContext(routeContext);\n\n    if (__DEV__) {\n      if (route === null) {\n        throw TypeRouteError.App_should_be_wrapped_in_a_RouteProvider_component.create();\n      }\n    }\n\n    return route!;\n  }\n\n  fpRoutes.updateTarget(routes);\n  fpSession.updateTarget(session);\n  fpRouteProvider.updateTarget(RouteProvider);\n  fpUseRoute.updateTarget(useRoute);\n  fpGetRoute.updateTarget(getRoute);\n\n  return {\n    routes: fpRoutes.proxy,\n    session: fpSession.proxy,\n    RouteProvider: fpRouteProvider.proxy,\n    useRoute: fpUseRoute.proxy,\n    getRoute: fpGetRoute.proxy\n  };\n\n}\n"],"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","App_should_be_wrapped_in_a_RouteProvider_component","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","_loop","_paramDef$Internal$v","paramValue","undefined","urlEncodeDefault","urlEncode","valueSerializer","getValue","valueSerializerId","id","_ret","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","route_current","getRoute","router","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","_opts$arrayFormat3","_getRouterContext","createForwardingProxy","_params$accessBeforeS","accessBeforeSetErrorMessage","isFunction","checkSet","get","_t","prop","receiver","Reflect","set","has","deleteProperty","ownKeys","getOwnPropertyDescriptor","descriptor","getPrototypeOf","setPrototypeOf","proto","isExtensible","preventExtensions","thisArg","construct","newTarget","proxy","Proxy","updateTarget","defineRoute","assertDefineRouteOrExtendArgs","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup_fromItems","groupItems","routeNames","isRouteGroup","createGroup_fromRouteDefs","core","coreCreateRouter","group","values","createGroup","arg","_React$version$split$","React","parseInt","major","minor","fpRoutes","fpSession","fpRouteProvider","fpUseRoute","fpGetRoute","_coreCreateRouter","routeContext","RouteProvider","props","_React$useState","setRoute","Provider","children","useRoute"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/type-route/dist/type-route.cjs.production.min.js b/node_modules/type-route/dist/type-route.cjs.production.min.js
index 1679dad..729fdce 100644
--- a/node_modules/type-route/dist/type-route.cjs.production.min.js
+++ b/node_modules/type-route/dist/type-route.cjs.production.min.js
@@ -1,2 +1,2 @@
-"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var r=require("history"),e=require("react");function n(){return(n=Object.assign||function(r){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(r[a]=n[a])}return r}).apply(this,arguments)}function a(r,e){(null==e||e>r.length)&&(e=r.length);for(var n=0,a=new Array(e);n<e;n++)a[n]=r[n];return a}function t(r,e){var n="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(n)return(n=n.call(r)).next.bind(n);if(Array.isArray(r)||(n=function(r,e){if(r){if("string"==typeof r)return a(r,void 0);var n=Object.prototype.toString.call(r).slice(8,-1);return"Object"===n&&r.constructor&&(n=r.constructor.name),"Map"===n||"Set"===n?Array.from(r):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?a(r,void 0):void 0}}(r))||e&&r&&"number"==typeof r.length){n&&(r=n);var t=0;return function(){return t>=r.length?{done:!0}:{done:!1,value:r[t++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function i(r){return Array.isArray(r)?r:[r]}function o(r){return"${p."+r+"}"}function u(r,e){var n={};return Object.keys(e).forEach((function(a){var t=e[a];t["~internal"].kind===r&&(n[a]=t)})),n}function l(r,e,n){var a=r["~internal"].valueSerializer.stringify(e);return n?encodeURIComponent(a):a}var f={__noMatch:!0},c=function(r,e){for(var n=0;n<e.length;n++)if(e[n]!==r[n])return!1;return!0},s=function(r,e){for(var n=1;n<=e.length;n++)if(e[e.length-n]!==r[r.length-n])return!1;return!0},p=function(r,e){var n=r.split(e);return[n[0],n.slice(1).join(e)]},v=s,m=c;function d(r){for(var e,a=r.object,i=r.paramDefs,o=r.urlEncodeDefault,u=r.arraySeparator,l={},c=Object.keys(i).map((function(r){return n({name:r},i[r])})),s=n({},a),p=function(){var r=e.value,n=a[r.name];if(delete s[r.name],void 0===n)return r["~internal"].optional?"continue":{v:!1};var t=void 0;if(null===n){if(!r["~internal"].array)return r["~internal"].optional?"continue":{v:!1};t=[]}else if(r["~internal"].array){if((t=n.split(u).map((function(e){var n;return r["~internal"].valueSerializer.parse((null!=(n=r["~internal"].valueSerializer.urlEncode)?n:o)?decodeURIComponent(e):e)}))).some((function(r){return r===f})))return r["~internal"].optional?"continue":{v:!1}}else{var i;if((t=r["~internal"].valueSerializer.parse((null!=(i=r["~internal"].valueSerializer.urlEncode)?i:o)?decodeURIComponent(n):n))===f)return r["~internal"].optional?"continue":{v:!1}}l[r.name]=t},v=t(c);!(e=v()).done;){var m=p();if("continue"!==m&&"object"==typeof m)return m.v}return{params:l,numExtraneousParams:Object.keys(s).length}}function y(r){var e=r.pathDefs,a=r.params,t=u("query",a),i=u("state",a),o={};return Object.keys(a).forEach((function(r){var e=a[r];void 0!==e["~internal"].default&&(o[r]=e["~internal"].default)})),function(r){var a=r.routerLocation,u=r.arraySeparator,l=r.queryStringSerializer;if(void 0===a.path)return!1;var c=function(r){for(var e=r.path,a=r.pathDefs,t=r.arraySeparator,i=0;i<a.length;i++){var o=u(a[i]);if(!1!==o)return n({},o,{primaryPath:0===i})}return!1;function u(r){var n={};if("/"===e&&0===r.length)return{params:n,numExtraneousParams:0};var a=e.length>1&&v(e,"/");a&&(e=e.slice(0,e.length-1));for(var i=e.split("/").slice(1),o=function(e){var o,u,l,c=e>=r.length?null:r[e],s=e>=i.length?null:i[e];if(null===c)return{v:!1};if(null===s)return 0==r.length-1-e&&null!=(l=c.namedParamDef)&&l["~internal"].optional?"break":{v:!1};if(null!=(o=c.namedParamDef)&&o["~internal"].trailing&&(s=i.slice(e).join("/")),!m(s,c.leading))return{v:!1};var p=s.slice(c.leading.length);if(!v(p,c.trailing))return{v:!1};var d=p.slice(0,p.length-c.trailing.length);if(!c.namedParamDef)return""===d?"continue":{v:!1};if(""===d)return c.namedParamDef["~internal"].optional?"continue":{v:!1};var y=null!=(u=c.namedParamDef["~internal"].valueSerializer.urlEncode)?u:!c.namedParamDef["~internal"].trailing,h=void 0;if(c.namedParamDef["~internal"].array){if((h=d.split(t).map((function(r){var e;return null==(e=c.namedParamDef)?void 0:e["~internal"].valueSerializer.parse(y?decodeURIComponent(r):r)}))).some((function(r){return r===f})))return{v:!1}}else if((h=c.namedParamDef["~internal"].valueSerializer.parse(y?decodeURIComponent(d):d))===f)return{v:!1};return c.namedParamDef["~internal"].trailing&&a&&""===c.trailing&&(h+="/"),n[c.namedParamDef.paramName]=h,c.namedParamDef["~internal"].trailing?"break":void 0},u=0;u<Math.max(r.length,i.length);u++){var l=o(u);if("break"===l)break;if("continue"!==l&&"object"==typeof l)return l.v}return{params:n,numExtraneousParams:0}}}({path:a.path,pathDefs:e,arraySeparator:u});if(!1===c)return!1;var s=function(r,e,n,a){var t={};return r&&(t=n.parse(r)),d({object:t,paramDefs:e,urlEncodeDefault:!0,arraySeparator:a})}(a.query,t,l,u);if(!1===s)return!1;var p=function(r,e,n){return d({object:null!=r?r:{},paramDefs:e,urlEncodeDefault:!1,arraySeparator:n})}(a.state,i,u);return!1!==p&&{primaryPath:c.primaryPath,params:n({},o,c.params,s.params,p.params),numExtraneousParams:c.numExtraneousParams+s.numExtraneousParams+p.numExtraneousParams}}}function h(r){return void 0===r&&(r={}),!(r.target&&r.target.target&&"_self"!==r.target.target||r.defaultPrevented||0!==r.button||r.metaKey||r.altKey||r.ctrlKey||r.shiftKey||(r&&r.preventDefault&&r.preventDefault(),0))}var g=c;function S(r){var e=r.routeName,a=r.params,t=r.location,i=r.routerContext,o=i.navigate,u=i.history.createHref({pathname:!1===e?t.fullPath:t.path,search:t.query?"?"+t.query:""});g(u,"#")&&(u="/"+u),!1!==e&&"/"!==i.baseUrl&&(u=i.baseUrl+u);var l={name:e,params:a,href:u,link:{href:u,onClick:function(r){if(h(r))return l.push()}},action:null,push:function(){return o(n({},l,{action:"push"}),!0)},replace:function(){return o(n({},l,{action:"replace"}),!0)}};return l}function b(r,e,a){var f,c,s,p,v=(f=u("path",e["~internal"].params),c=e["~internal"].path,s=Object.keys(f).map((function(r){return n({paramName:r},f[r])})),p={},s.forEach((function(r){var e=r.paramName;p[e]=o(e)})),i(c(p)).map((function(r){if(1===r.length)return[];for(var e,n=r.split("/").slice(1),a={},i=[],u=t(n);!(e=u()).done;){for(var l,f=e.value,c=null,p=t(s);!(l=p()).done;){var v=l.value;f.indexOf(o(v.paramName))>=0&&(c=v,a[v.paramName]=!0)}if(c){var m=f.split(o(c.paramName));i.push({leading:m[0],trailing:m[1],namedParamDef:c})}else i.push({leading:f,trailing:"",namedParamDef:null})}return s.map((function(r){return r.paramName})).filter((function(r){return!a[r]})),i}))),m=function(t){void 0===t&&(t={});var i=a(),o=i.arraySeparator,u=i.queryStringSerializer,f=i.baseUrl,c=n({},t);Object.keys(e["~internal"].params).forEach((function(r){var n=e["~internal"].params[r];void 0===c[r]&&void 0!==n["~internal"].default&&(c[r]=n["~internal"].default)}));var s=function(r){var e=r.paramCollection,a=r.paramDefCollection,t=r.arraySeparator,i=r.queryStringSerializer,o=r.pathDefs,u=r.baseUrl,f={path:{},query:{},state:{}},c=function(r){var n,i=e[r];if(void 0===i)return"continue";var o=a[r],u=null!=(n=o["~internal"].valueSerializer.urlEncode)?n:"state"!==o["~internal"].kind&&!o["~internal"].trailing,c=function(r){return o["~internal"].array?0===r.length?null:r.map((function(r){return l(o,r,u)})).join(t):l(o,r,u)},s=c(i);if("query"===o["~internal"].kind&&void 0!==o["~internal"].default&&c(o["~internal"].default)===s)return"continue";f[o["~internal"].kind][r]={valueSerializerId:o["~internal"].valueSerializer.id,array:o["~internal"].array,value:s}};for(var s in a)c(s);var p="/"+o[0].filter((function(r){var e=r.namedParamDef;return!(null!=e&&e["~internal"].optional&&void 0===f.path[e.paramName])})).map((function(r){var e=r.namedParamDef;return r.leading+(e?f.path[e.paramName].value:"")+r.trailing})).join("/");return{fullPath:("/"===u?"":u)+p,path:p,query:Object.keys(f.query).length>0?i.stringify(f.query):void 0,state:0===Object.keys(f.state).length?void 0:Object.keys(f.state).reduce((function(r,e){var a;return n({},r,((a={})[e]=f.state[e].value,a))}),{})}}({paramCollection:t,paramDefCollection:e["~internal"].params,arraySeparator:o,queryStringSerializer:u,pathDefs:v,baseUrl:f});return S({routeName:r,params:c,location:s,routerContext:i})};return Object.defineProperty(m,"name",{value:r}),m["~internal"]={type:"RouteBuilder",match:y({pathDefs:v,params:e["~internal"].params}),pathDefs:v,Route:null},m}function P(r){var e,n;void 0===r&&(r={});var a=null!=(e=r.queryStringArrayFormat)?e:"singleKeyWithBracket",i=null!=(n=r.arraySeparator)?n:",",o="multiKey"===a||"multiKeyWithBracket"===a,u="multiKey"===a||"singleKey"===a?"":"[]";return{parse:function(r){for(var e,n={},a=t(r.split("&"));!(e=a()).done;){var l=e.value.split("="),f=l[0],c=l[1],p=l.slice(2);if(!(void 0===f||p.length>0)){var v=decodeURIComponent(s(f,u)?f.slice(0,f.length-u.length):f);void 0===c?n[v]=null:n[v]&&o?n[v]+=""+i+c:n[v]=c}}return n},stringify:function(r){return Object.keys(r).map((function(e){var n=encodeURIComponent(e),a=r[e].array?""+n+u:n,t=r[e].value;return null===t?a:r[e].array&&o?t.split(i).map((function(r){return a+"="+r})).join("&"):a+"="+t})).join("&")}}}function D(r,e){var a=e.queryStringSerializer,t=e.arraySeparator,i=(0,e.getRoutes)(),o=!1;for(var u in i){var l=i[u]["~internal"].match({routerLocation:r,queryStringSerializer:a,arraySeparator:t});if(!1!==l){if(0===l.numExtraneousParams)return{route:i[u](l.params),primaryPath:l.primaryPath};(!1===o||l.numExtraneousParams<o.numExtraneousParams)&&(o=n({},l,{routeName:u}))}}return o?{route:i[o.routeName](o.params),primaryPath:o.primaryPath}:{route:S({routeName:!1,params:{},location:r,routerContext:e}),primaryPath:!0}}var j=c;function k(r,e){return{fullPath:r.pathname,path:j(r.pathname,e)?"/"!==e?r.pathname.replace(e,""):r.pathname:void 0,query:r.search?j(r.search,"?")?r.search.slice(1):r.search:void 0,state:"object"==typeof r.state&&null!==r.state?r.state.state:void 0}}var w=p;function x(r,e,n){var a=w(r,"?");return D(k({pathname:a[0],search:a[1],state:e},n.baseUrl),n)}function E(r){var e=r.startListening,n=r.stopListening,a=[],t=0;return{add:function(r){var i=t++;return a.push({id:i,handler:r}),1===a.length&&e(),function(){var r=a.map((function(r){return r.id})).indexOf(i);r>=0&&(a.splice(r,1),0===a.length&&n())}},getHandlers:function(){return a.map((function(r){return r.handler}))}}}function O(r,e){if("push"===r.action&&"object"==typeof window&&null!==window&&"function"==typeof window.scroll&&!1!==e&&"object"==typeof navigator&&null!==navigator&&"string"==typeof navigator.userAgent&&!(navigator.userAgent.indexOf("Node.js")>0||navigator.userAgent.indexOf("jsdom")>0))try{window.scroll(0,0)}catch(r){}}function q(r,e){var n={};if(r.name)for(var a,i=t(Object.keys(r.params).sort());!(a=i()).done;){var o=a.value,u=e[r.name]["~internal"].params[o]["~internal"];"state"===u.kind&&(n[o]=u.valueSerializer.stringify(r.params[o]))}return n}var z=p;function N(){for(var e,a,i,o,u,l=arguments.length,f=new Array(l),c=0;c<l;c++)f[c]=arguments[c];var s,p,v=C(f),m=v.routeDefs,d=v.opts,y=E({startListening:function(){p=s.listen((function(r){if(b)b=!1;else{var e=k(r.location,h),a=r.action.toLowerCase(),t=D(e,H()),i=t.primaryPath;T(n({},t.route,{action:a}),i)}}))},stopListening:function(){return null==p?void 0:p()}}),h=null!=(e=d.baseUrl)?e:"/",g=null!=(a=null==(i=d.arrayFormat)?void 0:i.separator)?a:",",S=null!=(o=d.queryStringSerializer)?o:P({queryStringArrayFormat:null==(u=d.arrayFormat)?void 0:u.queryString,arraySeparator:g}),b=!1,j=!1,w=null,N=null,A=[];L(d.session);var I=R(H),U={routes:I,session:{push:function(r,e){var a=x(r,e,H()),t=a.primaryPath;return K(n({},a.route,{action:"push"}),t)},replace:function(r,e){var a=x(r,e,H()),t=a.primaryPath;return K(n({},a.route,{action:"replace"}),t)},back:function(r){void 0===r&&(r=1),s.go(-r)},forward:function(r){void 0===r&&(r=1),s.go(r)},getInitialRoute:function(){if(!w){var r=D(k(s.location,h),H());r.primaryPath||(j=!0,r.route.replace(),r=D(k(s.location,h),H())),w=r.route}return w},reset:function(r){return L(r)},block:function(r){A.push(r);var e=s.block((function(e){var a=D(k(e.location,h),H()).route,t=e.action.toLowerCase();r({route:n({},a,{action:t}),retry:e.retry})}));return function(){A.splice(A.findIndex((function(e){return e===r})),1),e()}},listen:function(r){return y.add(r)}}};return U;function L(e){void 0===e&&(e={type:"undefined"!=typeof window&&void 0!==window.document?"browser":"memory"}),w=null,s="memory"===e.type?r.createMemoryHistory({initialEntries:e.initialEntries,initialIndex:e.initialIndex}):"hash"===e.type?r.createHashHistory({window:e.window}):r.createBrowserHistory({window:e.window})}function K(r,e){var n;if(A.length>0)A.forEach((function(e){e({route:r,retry:function(){r["push"===r.action?"push":"replace"]()}})}));else{var a=q(r,m);if((null==(n=N)?void 0:n.href)!==r.href||JSON.stringify(q(N,m))!==JSON.stringify(a)){j?j=!1:T(r,e),b=!0;var t=z(r.href,"?"),i=t[1];s["replace"===r.action?"replace":"push"]({pathname:t[0],search:i?"?"+i:"",hash:""},a?{state:a}:void 0)}}}function T(r,e){if(e){for(var n,a=t(y.getHandlers());!(n=a()).done;)(0,n.value)(r);O(r,d.scrollToTop),N=r}else r.replace()}function H(){return{queryStringSerializer:S,arraySeparator:g,navigate:K,history:s,routeDefs:m,getRoutes:function(){return I},baseUrl:h}}}function C(r){return{routeDefs:1===r.length?r[0]:r[1],opts:1===r.length?{}:r[0]}}function R(r){var e={},n=r().routeDefs;for(var a in n)e[a]=b(a,n[a],r);return e}function A(r){return 1===r.length?{params:{},path:function(){return r[0]}}:{params:r[0],path:r[1]}}var I={id:"boolean",parse:function(r){return"true"===r||"false"!==r&&f},stringify:function(r){return r?"true":"false"}},U={id:"number",parse:function(r){return e=r,isNaN(parseFloat(e))||!/^-?\d*\.?\d*$/.test(e)?f:parseFloat(r);var e},stringify:function(r){return r.toString()}},L={id:"string",parse:function(r){return r},stringify:function(r){return r}},K={path:n({},T("path",!1),{trailing:T("path",!0)}),query:T("query",!1),state:T("state",!1)};function T(r,e){return n({},a(!1,!1),{array:a(!1,!0),optional:n({},a(!0,!1),{array:a(!0,!0)})});function a(n,a){return{string:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:n,valueSerializer:L,trailing:e,default:void 0}}),number:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:n,valueSerializer:U,trailing:e,default:void 0}}),boolean:t({"~internal":{type:"ParamDef",array:a,kind:r,optional:n,valueSerializer:I,trailing:e,default:void 0}}),ofType:function(i){return void 0===i&&(i={id:"json",parse:function(r){var e;try{e=JSON.parse(r)}catch(r){return f}return e},stringify:function(r){return JSON.stringify(r)}}),t({"~internal":{type:"ParamDef",array:a,kind:r,optional:n,valueSerializer:i,trailing:e,default:void 0}})}}}function t(r){var e=r["~internal"];return e.optional?{"~internal":e,default:function(r){return{"~internal":n({},e,{default:r})}}}:{"~internal":e}}}exports.createGroup=function(r){var e={};return r.forEach((function(r){r.routeNames?r.routeNames.forEach((function(r){e[r]=!0})):e[r.name]=!0})),{"~internal":{type:"RouteGroup",Route:null},routeNames:Object.keys(e),has:function(r){return!1!==r.name&&!!e[r.name]}}},exports.createRouter=function(){for(var r=arguments.length,a=new Array(r),t=0;t<r;t++)a[t]=arguments[t];var i=C(a),o=i.opts,u=i.routeDefs,l=N(n({},o,{scrollToTop:!1}),u),f=e.createContext(null);return n({},l,{RouteProvider:c,useRoute:s});function c(r){var n=e.useState(l.session.getInitialRoute()),a=n[0],t=n[1];return e.useLayoutEffect((function(){return l.session.listen(t)}),[]),e.useEffect((function(){O(a,o.scrollToTop)}),[a]),e.createElement(f.Provider,{value:a},r.children)}function s(){return e.useContext(f)}},exports.defineRoute=function r(){for(var e=arguments.length,a=new Array(e),t=0;t<e;t++)a[t]=arguments[t];var o=A(a),u={"~internal":{type:"RouteDef",params:o.params,path:o.path},extend:function(){for(var e=arguments.length,a=new Array(e),t=0;t<e;t++)a[t]=arguments[t];var u=A(a),l=u.params,f=u.path,c=Object.keys(o.params),s=Object.keys(l);return c.filter((function(r){return s.indexOf(r)>=0})),r(n({},l,o.params),(function(r){var e,n=i(o.path(t(c))),a=i(f(t(s)));return(e=[]).concat.apply(e,n.map((function(r){return a.map((function(e){return"/"===r?e:r+("/"===e?"":e)}))})));function t(e){var n={};return e.forEach((function(e){n[e]=r[e]})),n}}))}};return u},exports.noMatch=f,exports.param=K,exports.preventDefaultLinkClickBehavior=h;
+"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var r=require("history"),e=require("react");function t(){return(t=Object.assign||function(r){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(r[n]=t[n])}return r}).apply(this,arguments)}function n(r,e){(null==e||e>r.length)&&(e=r.length);for(var t=0,n=new Array(e);t<e;t++)n[t]=r[t];return n}function a(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=function(r,e){if(r){if("string"==typeof r)return n(r,void 0);var t=Object.prototype.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?n(r,void 0):void 0}}(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var a=0;return function(){return a>=r.length?{done:!0}:{done:!1,value:r[a++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function i(r){return Array.isArray(r)?r:[r]}function o(r){return"${p."+r+"}"}function u(r,e){var t={};return Object.keys(e).forEach((function(n){var a=e[n];a["~internal"].kind===r&&(t[n]=a)})),t}function l(r,e,t){var n=r["~internal"].valueSerializer.stringify(e);return t?encodeURIComponent(n):n}var f={__noMatch:!0},c=function(r,e){for(var t=0;t<e.length;t++)if(e[t]!==r[t])return!1;return!0},s=function(r,e){for(var t=1;t<=e.length;t++)if(e[e.length-t]!==r[r.length-t])return!1;return!0},p=function(r,e){var t=r.split(e);return[t[0],t.slice(1).join(e)]},v=s,m=c;function d(r){for(var e,n=r.object,i=r.paramDefs,o=r.urlEncodeDefault,u=r.arraySeparator,l={},c=Object.keys(i).map((function(r){return t({name:r},i[r])})),s=t({},n),p=function(){var r=e.value,t=n[r.name];if(delete s[r.name],void 0===t)return r["~internal"].optional?"continue":{v:!1};var a=void 0;if(null===t){if(!r["~internal"].array)return r["~internal"].optional?"continue":{v:!1};a=[]}else if(r["~internal"].array){if((a=t.split(u).map((function(e){var t;return r["~internal"].valueSerializer.parse((null!=(t=r["~internal"].valueSerializer.urlEncode)?t:o)?decodeURIComponent(e):e)}))).some((function(r){return r===f})))return r["~internal"].optional?"continue":{v:!1}}else{var i;if((a=r["~internal"].valueSerializer.parse((null!=(i=r["~internal"].valueSerializer.urlEncode)?i:o)?decodeURIComponent(t):t))===f)return r["~internal"].optional?"continue":{v:!1}}l[r.name]=a},v=a(c);!(e=v()).done;){var m=p();if("continue"!==m&&"object"==typeof m)return m.v}return{params:l,numExtraneousParams:Object.keys(s).length}}function y(r){var e=r.pathDefs,n=r.params,a=u("query",n),i=u("state",n),o={};return Object.keys(n).forEach((function(r){var e=n[r];void 0!==e["~internal"].default&&(o[r]=e["~internal"].default)})),function(r){var n=r.routerLocation,u=r.arraySeparator,l=r.queryStringSerializer;if(void 0===n.path)return!1;var c=function(r){for(var e=r.path,n=r.pathDefs,a=r.arraySeparator,i=0;i<n.length;i++){var o=u(n[i]);if(!1!==o)return t({},o,{primaryPath:0===i})}return!1;function u(r){var t={};if("/"===e&&0===r.length)return{params:t,numExtraneousParams:0};var n=e.length>1&&v(e,"/");n&&(e=e.slice(0,e.length-1));for(var i=e.split("/").slice(1),o=function(e){var o,u,l,c=e>=r.length?null:r[e],s=e>=i.length?null:i[e];if(null===c)return{v:!1};if(null===s)return 0==r.length-1-e&&null!=(l=c.namedParamDef)&&l["~internal"].optional?"break":{v:!1};if(null!=(o=c.namedParamDef)&&o["~internal"].trailing&&(s=i.slice(e).join("/")),!m(s,c.leading))return{v:!1};var p=s.slice(c.leading.length);if(!v(p,c.trailing))return{v:!1};var d=p.slice(0,p.length-c.trailing.length);if(!c.namedParamDef)return""===d?"continue":{v:!1};if(""===d)return c.namedParamDef["~internal"].optional?"continue":{v:!1};var y=null!=(u=c.namedParamDef["~internal"].valueSerializer.urlEncode)?u:!c.namedParamDef["~internal"].trailing,h=void 0;if(c.namedParamDef["~internal"].array){if((h=d.split(a).map((function(r){var e;return null==(e=c.namedParamDef)?void 0:e["~internal"].valueSerializer.parse(y?decodeURIComponent(r):r)}))).some((function(r){return r===f})))return{v:!1}}else if((h=c.namedParamDef["~internal"].valueSerializer.parse(y?decodeURIComponent(d):d))===f)return{v:!1};return c.namedParamDef["~internal"].trailing&&n&&""===c.trailing&&(h+="/"),t[c.namedParamDef.paramName]=h,c.namedParamDef["~internal"].trailing?"break":void 0},u=0;u<Math.max(r.length,i.length);u++){var l=o(u);if("break"===l)break;if("continue"!==l&&"object"==typeof l)return l.v}return{params:t,numExtraneousParams:0}}}({path:n.path,pathDefs:e,arraySeparator:u});if(!1===c)return!1;var s=function(r,e,t,n){var a={};return r&&(a=t.parse(r)),d({object:a,paramDefs:e,urlEncodeDefault:!0,arraySeparator:n})}(n.query,a,l,u);if(!1===s)return!1;var p=function(r,e,t){return d({object:null!=r?r:{},paramDefs:e,urlEncodeDefault:!1,arraySeparator:t})}(n.state,i,u);return!1!==p&&{primaryPath:c.primaryPath,params:t({},o,c.params,s.params,p.params),numExtraneousParams:c.numExtraneousParams+s.numExtraneousParams+p.numExtraneousParams}}}function h(r){return void 0===r&&(r={}),!(r.target&&r.target.target&&"_self"!==r.target.target||r.defaultPrevented||0!==r.button||r.metaKey||r.altKey||r.ctrlKey||r.shiftKey||(r&&r.preventDefault&&r.preventDefault(),0))}var g=c;function P(r){var e=r.routeName,n=r.params,a=r.location,i=r.routerContext,o=i.navigate,u=i.history.createHref({pathname:!1===e?a.fullPath:a.path,search:a.query?"?"+a.query:""});g(u,"#")&&(u="/"+u),!1!==e&&"/"!==i.baseUrl&&(u=i.baseUrl+u);var l={name:e,params:n,href:u,link:{href:u,onClick:function(r){if(h(r))return l.push()}},action:null,push:function(){return o(t({},l,{action:"push"}),!0)},replace:function(){return o(t({},l,{action:"replace"}),!0)}};return l}function b(r,e,n){var f,c,s,p,v=(f=u("path",e["~internal"].params),c=e["~internal"].path,s=Object.keys(f).map((function(r){return t({paramName:r},f[r])})),p={},s.forEach((function(r){var e=r.paramName;p[e]=o(e)})),i(c(p)).map((function(r){if(1===r.length)return[];for(var e,t=r.split("/").slice(1),n={},i=[],u=a(t);!(e=u()).done;){for(var l,f=e.value,c=null,p=a(s);!(l=p()).done;){var v=l.value;f.indexOf(o(v.paramName))>=0&&(c=v,n[v.paramName]=!0)}if(c){var m=f.split(o(c.paramName));i.push({leading:m[0],trailing:m[1],namedParamDef:c})}else i.push({leading:f,trailing:"",namedParamDef:null})}return s.map((function(r){return r.paramName})).filter((function(r){return!n[r]})),i}))),m=function(a){void 0===a&&(a={});var i=n(),o=i.arraySeparator,u=i.queryStringSerializer,f=i.baseUrl,c=t({},a);Object.keys(e["~internal"].params).forEach((function(r){var t=e["~internal"].params[r];void 0===c[r]&&void 0!==t["~internal"].default&&(c[r]=t["~internal"].default)}));var s=function(r){var e=r.paramCollection,n=r.paramDefCollection,a=r.arraySeparator,i=r.queryStringSerializer,o=r.pathDefs,u=r.baseUrl,f={path:{},query:{},state:{}},c=function(r){var t,i=e[r];if(void 0===i)return"continue";var o=n[r],u=null!=(t=o["~internal"].valueSerializer.urlEncode)?t:"state"!==o["~internal"].kind&&!o["~internal"].trailing,c=function(r){return o["~internal"].array?0===r.length?null:r.map((function(r){return l(o,r,u)})).join(a):l(o,r,u)},s=c(i);if("query"===o["~internal"].kind&&void 0!==o["~internal"].default&&c(o["~internal"].default)===s)return"continue";f[o["~internal"].kind][r]={valueSerializerId:o["~internal"].valueSerializer.id,array:o["~internal"].array,value:s}};for(var s in n)c(s);var p="/"+o[0].filter((function(r){var e=r.namedParamDef;return!(null!=e&&e["~internal"].optional&&void 0===f.path[e.paramName])})).map((function(r){var e=r.namedParamDef;return r.leading+(e?f.path[e.paramName].value:"")+r.trailing})).join("/");return{fullPath:("/"===u?"":u)+p,path:p,query:Object.keys(f.query).length>0?i.stringify(f.query):void 0,state:0===Object.keys(f.state).length?void 0:Object.keys(f.state).reduce((function(r,e){var n;return t({},r,((n={})[e]=f.state[e].value,n))}),{})}}({paramCollection:a,paramDefCollection:e["~internal"].params,arraySeparator:o,queryStringSerializer:u,pathDefs:v,baseUrl:f});return P({routeName:r,params:c,location:s,routerContext:i})};return Object.defineProperty(m,"name",{value:r}),m["~internal"]={type:"RouteBuilder",match:y({pathDefs:v,params:e["~internal"].params}),pathDefs:v,Route:null},m}function S(r){var e,t;void 0===r&&(r={});var n=null!=(e=r.queryStringArrayFormat)?e:"singleKeyWithBracket",i=null!=(t=r.arraySeparator)?t:",",o="multiKey"===n||"multiKeyWithBracket"===n,u="multiKey"===n||"singleKey"===n?"":"[]";return{parse:function(r){for(var e,t={},n=a(r.split("&"));!(e=n()).done;){var l=e.value.split("="),f=l[0],c=l[1],p=l.slice(2);if(!(void 0===f||p.length>0)){var v=decodeURIComponent(s(f,u)?f.slice(0,f.length-u.length):f);void 0===c?t[v]=null:t[v]&&o?t[v]+=""+i+c:t[v]=c}}return t},stringify:function(r){return Object.keys(r).map((function(e){var t=encodeURIComponent(e),n=r[e].array?""+t+u:t,a=r[e].value;return null===a?n:r[e].array&&o?a.split(i).map((function(r){return n+"="+r})).join("&"):n+"="+a})).join("&")}}}function x(r,e){var n=e.queryStringSerializer,a=e.arraySeparator,i=(0,e.getRoutes)(),o=!1;for(var u in i){var l=i[u]["~internal"].match({routerLocation:r,queryStringSerializer:n,arraySeparator:a});if(!1!==l){if(0===l.numExtraneousParams)return{route:i[u](l.params),primaryPath:l.primaryPath};(!1===o||l.numExtraneousParams<o.numExtraneousParams)&&(o=t({},l,{routeName:u}))}}return o?{route:i[o.routeName](o.params),primaryPath:o.primaryPath}:{route:P({routeName:!1,params:{},location:r,routerContext:e}),primaryPath:!0}}var D=c;function w(r,e){return{fullPath:r.pathname,path:D(r.pathname,e)?"/"!==e?r.pathname.replace(e,""):r.pathname:void 0,query:r.search?D(r.search,"?")?r.search.slice(1):r.search:void 0,state:"object"==typeof r.state&&null!==r.state?r.state.state:void 0}}var R=p;function j(r,e,t){var n=R(r,"?");return x(w({pathname:n[0],search:n[1],state:e},t.baseUrl),t)}function E(r){var e=r.startListening,t=r.stopListening,n=[],a=0;return{add:function(r){var i=a++;return n.push({id:i,handler:r}),1===n.length&&e(),function(){var r=n.map((function(r){return r.id})).indexOf(i);r>=0&&(n.splice(r,1),0===n.length&&t())}},getHandlers:function(){return n.map((function(r){return r.handler}))}}}function O(r,e){if("push"===r.action&&"object"==typeof window&&null!==window&&"function"==typeof window.scroll&&!1!==e&&"object"==typeof navigator&&null!==navigator&&"string"==typeof navigator.userAgent&&!(navigator.userAgent.indexOf("Node.js")>0||navigator.userAgent.indexOf("jsdom")>0))try{window.scroll(0,0)}catch(r){}}function k(r,e){var t={};if(r.name)for(var n,i=a(Object.keys(r.params).sort());!(n=i()).done;){var o=n.value,u=e[r.name]["~internal"].params[o]["~internal"];"state"===u.kind&&(t[o]=u.valueSerializer.stringify(r.params[o]))}return t}var q=p;function z(){for(var e,n,i,o,u,l=arguments.length,f=new Array(l),c=0;c<l;c++)f[c]=arguments[c];var s,p,v=N(f),m=v.routeDefs,d=v.opts,y=E({startListening:function(){p=s.listen((function(r){if(b)b=!1;else{var e=w(r.location,h),n=r.action.toLowerCase(),a=x(e,_()),i=a.primaryPath;B(t({},a.route,{action:n}),i)}}))},stopListening:function(){return null==p?void 0:p()}}),h=null!=(e=d.baseUrl)?e:"/",g=null!=(n=null==(i=d.arrayFormat)?void 0:i.separator)?n:",",P=null!=(o=d.queryStringSerializer)?o:S({queryStringArrayFormat:null==(u=d.arrayFormat)?void 0:u.queryString,arraySeparator:g}),b=!1,D=!1,R=null,z=null,A=[];H(d.session);var I,U=C(_),T={push:function(r,e){var n=j(r,e,_()),a=n.primaryPath;return M(t({},n.route,{action:"push"}),a)},replace:function(r,e){var n=j(r,e,_()),a=n.primaryPath;return M(t({},n.route,{action:"replace"}),a)},back:function(r){void 0===r&&(r=1),s.go(-r)},forward:function(r){void 0===r&&(r=1),s.go(r)},getInitialRoute:function(){if(!R){var r=x(w(s.location,h),_());r.primaryPath||(D=!0,r.route.replace(),r=x(w(s.location,h),_())),R=r.route}return R},reset:function(r){return H(r)},block:function(r){A.push(r);var e=s.block((function(e){var n=x(w(e.location,h),_()).route,a=e.action.toLowerCase();r({route:t({},n,{action:a}),retry:e.retry})}));return function(){A.splice(A.findIndex((function(e){return e===r})),1),e()}},listen:function(r){return y.add(r)}},F=(I=T.getInitialRoute(),T.listen((function(r){return I=r})),{getRoute:function(){return I}}),L=F.getRoute,K={routes:U,session:T,stopListening:function(){return null==p?void 0:p()},getRoute:L};return K;function H(e){void 0===e&&(e={type:"undefined"!=typeof window&&void 0!==window.document?"browser":"memory"}),R=null,s="memory"===e.type?r.createMemoryHistory({initialEntries:e.initialEntries,initialIndex:e.initialIndex}):"hash"===e.type?r.createHashHistory({window:e.window}):r.createBrowserHistory({window:e.window})}function M(r,e){var t;if(A.length>0)A.forEach((function(e){e({route:r,retry:function(){r["push"===r.action?"push":"replace"]()}})}));else{var n=k(r,m);if((null==(t=z)?void 0:t.href)!==r.href||JSON.stringify(k(z,m))!==JSON.stringify(n)){D?D=!1:B(r,e),b=!0;var a=q(r.href,"?"),i=a[1];s["replace"===r.action?"replace":"push"]({pathname:a[0],search:i?"?"+i:"",hash:""},n?{state:n}:void 0)}}}function B(r,e){if(e){for(var t,n=a(y.getHandlers());!(t=n()).done;)(0,t.value)(r);O(r,d.scrollToTop),z=r}else r.replace()}function _(){return{queryStringSerializer:P,arraySeparator:g,navigate:M,history:s,routeDefs:m,getRoutes:function(){return U},baseUrl:h}}}function N(r){return{routeDefs:1===r.length?r[0]:r[1],opts:1===r.length?{}:r[0]}}function C(r){var e={},t=r().routeDefs;for(var n in t)e[n]=b(n,t[n],r);return e}function A(r){var e=r.accessBeforeSetErrorMessage,t=void 0===e?"Assertion error: Forwarded proxy accessed too early":e,n=function(){if(void 0===a)throw new Error(t)},a=void 0;return{proxy:new Proxy(r.isFunction?function(){}:{},{get:function(r,e,t){return n(),Reflect.get(a,e,t)},set:function(r,e,t,i){return n(),Reflect.set(a,e,t,i)},has:function(r,e){return n(),Reflect.has(a,e)},deleteProperty:function(r,e){return n(),Reflect.deleteProperty(a,e)},ownKeys:function(r){return n(),Reflect.ownKeys(a)},getOwnPropertyDescriptor:function(r,e){return n(),Reflect.getOwnPropertyDescriptor(a,e)},defineProperty:function(r,e,t){return n(),Reflect.defineProperty(a,e,t)},getPrototypeOf:function(r){return n(),Reflect.getPrototypeOf(a)},setPrototypeOf:function(r,e){return n(),Reflect.setPrototypeOf(a,e)},isExtensible:function(r){return n(),Reflect.isExtensible(a)},preventExtensions:function(r){return n(),Reflect.preventExtensions(a)},apply:function(r,e,t){return n(),Reflect.apply(a,e,t)},construct:function(r,e,t){return n(),Reflect.construct(a,e,t)}}),updateTarget:function(r){a=r}}}function I(r){return 1===r.length?{params:{},path:function(){return r[0]}}:{params:r[0],path:r[1]}}var U={id:"boolean",parse:function(r){return"true"===r||"false"!==r&&f},stringify:function(r){return r?"true":"false"}},T={id:"number",parse:function(r){return e=r,isNaN(parseFloat(e))||!/^-?\d*\.?\d*$/.test(e)?f:parseFloat(r);var e},stringify:function(r){return r.toString()}},F={id:"string",parse:function(r){return r},stringify:function(r){return r}},L={path:t({},K("path",!1),{trailing:K("path",!0)}),query:K("query",!1),state:K("state",!1)};function K(r,e){return t({},n(!1,!1),{array:n(!1,!0),optional:t({},n(!0,!1),{array:n(!0,!0)})});function n(t,n){return{string:a({"~internal":{type:"ParamDef",array:n,kind:r,optional:t,valueSerializer:F,trailing:e,default:void 0}}),number:a({"~internal":{type:"ParamDef",array:n,kind:r,optional:t,valueSerializer:T,trailing:e,default:void 0}}),boolean:a({"~internal":{type:"ParamDef",array:n,kind:r,optional:t,valueSerializer:U,trailing:e,default:void 0}}),ofType:function(i){return void 0===i&&(i={id:"json",parse:function(r){var e;try{e=JSON.parse(r)}catch(r){return f}return e},stringify:function(r){return JSON.stringify(r)}}),a({"~internal":{type:"ParamDef",array:n,kind:r,optional:t,valueSerializer:i,trailing:e,default:void 0}})}}}function a(r){var e=r["~internal"];return e.optional?{"~internal":e,default:function(r){return{"~internal":t({},e,{default:r})}}}:{"~internal":e}}}function H(r){var e={};return r.forEach((function(r){r.routeNames?r.routeNames.forEach((function(r){e[r]=!0})):e[r.name]=!0})),{"~internal":{type:"RouteGroup",Route:null},routeNames:Object.keys(e),has:function(r){return!1!==r.name&&!!e[r.name]}}}var M=A({isFunction:!1}),B=A({isFunction:!1}),_=A({isFunction:!0}),J=A({isFunction:!0}),$=A({isFunction:!0});exports.coreCreateRouter=z,exports.createGroup=function(r){return r instanceof Array?H(r):(e=z(r),t=H(Object.values(e.routes)),e.stopListening(),t);var e,t},exports.createRouter=function(){for(var r=arguments.length,n=new Array(r),a=0;a<r;a++)n[a]=arguments[a];var i=N(n),o=i.opts,u=i.routeDefs,l=z(t({},o,{scrollToTop:!1}),u),f=l.routes,c=l.session,s=l.getRoute,p=e.createContext(null);function v(r){var t=e.useState(c.getInitialRoute()),n=t[0],a=t[1];return e.useLayoutEffect((function(){return c.listen(a)}),[]),e.useEffect((function(){O(n,o.scrollToTop)}),[n]),e.createElement(p.Provider,{value:n},r.children)}function m(){return e.useContext(p)}return M.updateTarget(f),B.updateTarget(c),_.updateTarget(v),J.updateTarget(m),$.updateTarget(s),{routes:M.proxy,session:B.proxy,RouteProvider:_.proxy,useRoute:J.proxy,getRoute:$.proxy}},exports.defineRoute=function r(){for(var e=arguments.length,n=new Array(e),a=0;a<e;a++)n[a]=arguments[a];var o=I(n),u={"~internal":{type:"RouteDef",params:o.params,path:o.path},extend:function(){for(var e=arguments.length,n=new Array(e),a=0;a<e;a++)n[a]=arguments[a];var u=I(n),l=u.params,f=u.path,c=Object.keys(o.params),s=Object.keys(l);return c.filter((function(r){return s.indexOf(r)>=0})),r(t({},l,o.params),(function(r){var e,t=i(o.path(a(c))),n=i(f(a(s)));return(e=[]).concat.apply(e,t.map((function(r){return n.map((function(e){return"/"===r?e:r+("/"===e?"":e)}))})));function a(e){var t={};return e.forEach((function(e){t[e]=r[e]})),t}}))}};return u},exports.noMatch=f,exports.param=L,exports.preventDefaultLinkClickBehavior=h;
 //# sourceMappingURL=type-route.cjs.production.min.js.map
diff --git a/node_modules/type-route/dist/type-route.cjs.production.min.js.map b/node_modules/type-route/dist/type-route.cjs.production.min.js.map
index c03d48d..025495a 100644
--- a/node_modules/type-route/dist/type-route.cjs.production.min.js.map
+++ b/node_modules/type-route/dist/type-route.cjs.production.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"type-route.cjs.production.min.js","sources":["../src/asArray.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/createMatcher.ts","../src/getQueryMatch.ts","../src/getStateMatch.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts","../src/react.ts"],"sourcesContent":["export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session: {\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n    },\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n","import {\n  CoreRouter,\n  UmbrellaRouteDefCollection,\n  UmbrellaRoute,\n  RouteDefCollectionRoute,\n  RouterOpts,\n} from \"./types\";\nimport { createRouter as coreCreateRouter, parseArgs } from \"./createRouter\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport * as React from \"react\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\n\nif (typeof __DEV__ === \"boolean\" && __DEV__) {\n  const [major, minor] = React.version\n    .split(\".\")\n    .map((value: string) => parseInt(value, 10));\n\n  if (major < 16 || (major === 16 && minor < 8)) {\n    throw TypeRouteError.Invalid_React_version.create(React.version);\n  }\n}\n\nexport { defineRoute } from \"./defineRoute\";\nexport { param } from \"./param\";\nexport { createGroup } from \"./createGroup\";\nexport { noMatch } from \"./noMatch\";\nexport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nexport {\n  GetRoute as Route,\n  Link,\n  ValueSerializer,\n  QueryStringSerializer,\n  SessionOpts,\n  RouterOpts,\n} from \"./types\";\n\ntype Router<TRouteDefCollection extends { [routeName: string]: any }> =\n  CoreRouter<TRouteDefCollection> & {\n    /**\n     * React hook for retrieving the current route.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/use-route\n     */\n    useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;\n\n    /**\n     * React component which connects React to Type Route and provides the current route to the rest of the application.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/route-provider\n     */\n    RouteProvider: (props: { children?: any }) => any;\n  };\ntype UmbrellaRouter = Router<UmbrellaRouteDefCollection>;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): Router<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaRouter {\n  const { opts, routeDefs } = parseArgs(args);\n  const router = coreCreateRouter({ ...opts, scrollToTop: false }, routeDefs);\n  const routeContext = React.createContext<UmbrellaRoute | null>(null);\n\n  return {\n    ...router,\n    RouteProvider,\n    useRoute,\n  };\n\n  function RouteProvider(props: { children?: any }) {\n    const [route, setRoute] = React.useState(router.session.getInitialRoute());\n\n    React.useLayoutEffect(() => router.session.listen(setRoute), []);\n\n    React.useEffect(() => {\n      attemptScrollToTop(route, opts.scrollToTop);\n    }, [route]);\n\n    return React.createElement(\n      routeContext.Provider,\n      { value: route },\n      props.children\n    );\n  }\n\n  function useRoute() {\n    const route = React.useContext(routeContext);\n\n    if (__DEV__) {\n      if (route === null) {\n        throw TypeRouteError.App_should_be_wrapped_in_a_RouteProvider_component.create();\n      }\n    }\n\n    return route!;\n  }\n}\n"],"names":["asArray","value","Array","isArray","getParamId","parameterName","getParamDefsOfType","type","paramDefCollection","filteredParamDefCollection","Object","keys","forEach","name","paramDef","kind","stringify","urlEncode","result","valueSerializer","encodeURIComponent","noMatch","__noMatch","stringUtils","start","i","length","end","split","_value$split","slice","join","endsWith","startsWith","getObjectMatch","_ref","_step","object","paramDefs","urlEncodeDefault","arraySeparator","params","namedParamDefs","map","_extends","extraneousParams","_loop","raw","undefined","optional","v","array","part","parse","_paramDef$Internal$v","decodeURIComponent","some","_paramDef$Internal$v2","_iterator","_createForOfIteratorHelperLoose","done","_ret","numExtraneousParams","createMatcher","pathDefs","queryParamDefCollection","stateParamDefCollection","defaultParams","paramName","param","_ref2","routerLocation","queryStringSerializer","path","pathMatch","index","match","primaryPath","pathDef","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","_pathSegmentDef$named","pathSegmentDef","pathSegment","namedParamDef","trailing","leading","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","Math","max","getPathMatch","queryMatch","query","getQueryMatch","stateMatch","state","getStateMatch","preventDefaultLinkClickBehavior","event","target","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","preventDefault","buildRoute","routeName","location","routerContext","navigate","href","history","createHref","pathname","fullPath","search","baseUrl","route","link","onClick","push","action","replace","createRouteBuilder","routeDef","getRouterContext","pathParamDefCollection","getRawPath","namedPathParamDefs","paramIdCollection","rawPath","rawPathSegments","usedPathParams","_step2","rawSegment","includedParamDef","_iterator2","indexOf","_rawSegment$split","filter","build","paramsWithDefault","paramCollection","paramValue","getValue","valueSerializerId","id","_ref3","reduce","key","_extends2","createLocation","defineProperty","Route","createQueryStringSerializer","args","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","rest","encodedName","getMatchingRoute","routes","getRoutes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","splitFirst","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","handler","splice","getHandlers","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sort","createRouter","_len","_key","arguments","unlisten","_parseArgs","parseArgs","opts","navigationHandlerManager","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","router","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","retry","findIndex","item","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","JSON","hash","boolean","number","isNaN","parseFloat","test","toString","string","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","~internal","default","ofType","internal","groupItems","routeNames","has","coreCreateRouter","routeContext","React","RouteProvider","useRoute","props","_React$useState","setRoute","Provider","children","defineRoute","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","x","parentPathArray","childPathArray","concat","apply","parentPath","childPath","allowedKeys","filteredX"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"type-route.cjs.production.min.js","sources":["../src/asArray.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/createMatcher.ts","../src/getQueryMatch.ts","../src/getStateMatch.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/tools/createForwardingProxy.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts","../src/react.ts"],"sourcesContent":["export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const session: UmbrellaCoreRouter[\"session\"] = {\n\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n\n  };\n\n  const { getRoute } = (() => {\n    let route_current = session.getInitialRoute();\n\n    session.listen(route => (route_current = route));\n\n    function getRoute() {\n        return route_current;\n    }\n\n    return { getRoute };\n  })();\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session,\n    stopListening: ()=> unlisten?.(),\n    getRoute\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","/**\n * Creates a proxy that forwards EVERYTHING to the current target.\n * The proxy has a stable identity, and you can update the target at runtime.\n */\nexport function createForwardingProxy<T extends object>(params: {\n  accessBeforeSetErrorMessage?: string;\n  isFunction: boolean;\n}) {\n  const { accessBeforeSetErrorMessage = \"Assertion error: Forwarded proxy accessed too early\", isFunction } =\n    params;\n\n  const checkSet = () => {\n    if (target === undefined) {\n      throw new Error(accessBeforeSetErrorMessage);\n    }\n  };\n\n  let target: any = undefined;\n\n  const handler: ProxyHandler<any> = {\n    get(_t, prop, receiver) {\n      checkSet();\n      return Reflect.get(target, prop, receiver);\n    },\n    set(_t, prop, value, receiver) {\n      checkSet();\n      return Reflect.set(target, prop, value, receiver);\n    },\n    has(_t, prop) {\n      checkSet();\n      return Reflect.has(target, prop);\n    },\n    deleteProperty(_t, prop) {\n      checkSet();\n      return Reflect.deleteProperty(target, prop);\n    },\n    ownKeys(_t) {\n      checkSet();\n      return Reflect.ownKeys(target);\n    },\n    getOwnPropertyDescriptor(_t, prop) {\n      checkSet();\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    },\n    defineProperty(_t, prop, descriptor) {\n      checkSet();\n      return Reflect.defineProperty(target, prop, descriptor);\n    },\n    getPrototypeOf(_t) {\n      checkSet();\n      return Reflect.getPrototypeOf(target);\n    },\n    setPrototypeOf(_t, proto) {\n      checkSet();\n      return Reflect.setPrototypeOf(target, proto);\n    },\n    isExtensible(_t) {\n      checkSet();\n      return Reflect.isExtensible(target);\n    },\n    preventExtensions(_t) {\n      checkSet();\n      return Reflect.preventExtensions(target);\n    },\n    apply(_t, thisArg, args) {\n      checkSet();\n      return Reflect.apply(target, thisArg, args);\n    },\n    construct(_t, args, newTarget) {\n      checkSet();\n      return Reflect.construct(target, args, newTarget);\n    },\n  };\n\n  // Use a dummy callable so proxy can stand in for both functions and objects\n  const proxy = new Proxy(isFunction ? (function (){}) : {}, handler) as T;\n\n  return {\n    proxy,\n    updateTarget(newTarget: T) {\n      target = newTarget;\n    },\n  };\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder, CoreRouter } from \"./types\";\nimport { assert } from \"./assert\";\nimport { createRouter as coreCreateRouter } from \"./createRouter\";\n\nfunction createGroup_fromItems<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n\nexport function createGroup_fromRouteDefs<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n> {\n  const core = coreCreateRouter(routeDefs);\n\n  const group= createGroup_fromItems(\n    Object.values(core.routes)\n  );\n\n  core.stopListening();\n\n  return group;\n}\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;\nexport function createGroup<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n>;\nexport function createGroup(\n  arg: any[] | Record<string, unknown>\n): RouteGroup<any> {\n  return arg instanceof Array\n    ? createGroup_fromItems(arg)\n    : createGroup_fromRouteDefs(arg);\n}\n\n\n","import {\n  CoreRouter,\n  UmbrellaRouteDefCollection,\n  UmbrellaRoute,\n  RouteDefCollectionRoute,\n  RouterOpts,\n} from \"./types\";\nimport { createRouter as coreCreateRouter, parseArgs } from \"./createRouter\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport * as React from \"react\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { createForwardingProxy } from \"./tools/createForwardingProxy\";\n\nimport * as types from \"./types\";\n\nexport type { types };\nexport { coreCreateRouter };\n\nif (typeof __DEV__ === \"boolean\" && __DEV__) {\n  const [major, minor] = React.version\n    .split(\".\")\n    .map((value: string) => parseInt(value, 10));\n\n  if (major < 16 || (major === 16 && minor < 8)) {\n    throw TypeRouteError.Invalid_React_version.create(React.version);\n  }\n}\n\nexport { defineRoute } from \"./defineRoute\";\nexport { param } from \"./param\";\nexport { createGroup } from \"./createGroup\";\nexport { noMatch } from \"./noMatch\";\nexport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nexport {\n  GetRoute as Route,\n  Link,\n  ValueSerializer,\n  QueryStringSerializer,\n  SessionOpts,\n  RouterOpts,\n} from \"./types\";\n\ntype Router<TRouteDefCollection extends { [routeName: string]: any }> =\n  Omit<CoreRouter<TRouteDefCollection>, \"stopListening\"> & {\n    /**\n     * React hook for retrieving the current route.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/use-route\n     */\n    useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;\n\n    /**\n     * Get current route synchronously outside of react.\n     */\n    getRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;\n\n    /**\n     * React component which connects React to Type Route and provides the current route to the rest of the application.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/route-provider\n     */\n    RouteProvider: (props: { children?: any }) => any;\n  };\ntype UmbrellaRouter = Router<UmbrellaRouteDefCollection>;\n\nconst fpRoutes = createForwardingProxy<UmbrellaRouter[\"routes\"]>({\n  isFunction: false\n});\nconst fpSession = createForwardingProxy<UmbrellaRouter[\"session\"]>({\n  isFunction: false\n});\nconst fpRouteProvider = createForwardingProxy<UmbrellaRouter[\"RouteProvider\"]>({\n  isFunction: true\n});\nconst fpUseRoute = createForwardingProxy<UmbrellaRouter[\"useRoute\"]>({\n  isFunction: true\n});\nconst fpGetRoute = createForwardingProxy<UmbrellaRouter[\"getRoute\"]>({\n  isFunction: true\n});\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): Router<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaRouter {\n  const { opts, routeDefs } = parseArgs(args);\n  const { routes, session, getRoute } = coreCreateRouter({ ...opts, scrollToTop: false }, routeDefs);\n  const routeContext = React.createContext<UmbrellaRoute | null>(null);\n\n  function RouteProvider(props: { children?: any }) {\n    const [route, setRoute] = React.useState(session.getInitialRoute());\n\n    React.useLayoutEffect(() => session.listen(setRoute), []);\n\n    React.useEffect(() => {\n      attemptScrollToTop(route, opts.scrollToTop);\n    }, [route]);\n\n    return React.createElement(\n      routeContext.Provider,\n      { value: route },\n      props.children\n    );\n  }\n\n  function useRoute() {\n    const route = React.useContext(routeContext);\n\n    if (__DEV__) {\n      if (route === null) {\n        throw TypeRouteError.App_should_be_wrapped_in_a_RouteProvider_component.create();\n      }\n    }\n\n    return route!;\n  }\n\n  fpRoutes.updateTarget(routes);\n  fpSession.updateTarget(session);\n  fpRouteProvider.updateTarget(RouteProvider);\n  fpUseRoute.updateTarget(useRoute);\n  fpGetRoute.updateTarget(getRoute);\n\n  return {\n    routes: fpRoutes.proxy,\n    session: fpSession.proxy,\n    RouteProvider: fpRouteProvider.proxy,\n    useRoute: fpUseRoute.proxy,\n    getRoute: fpGetRoute.proxy\n  };\n\n}\n"],"names":["asArray","value","Array","isArray","getParamId","parameterName","getParamDefsOfType","type","paramDefCollection","filteredParamDefCollection","Object","keys","forEach","name","paramDef","kind","stringify","urlEncode","result","valueSerializer","encodeURIComponent","noMatch","__noMatch","stringUtils","start","i","length","end","split","_value$split","slice","join","endsWith","startsWith","getObjectMatch","_ref","_step","object","paramDefs","urlEncodeDefault","arraySeparator","params","namedParamDefs","map","_extends","extraneousParams","_loop","raw","undefined","optional","v","array","part","parse","_paramDef$Internal$v","decodeURIComponent","some","_paramDef$Internal$v2","_iterator","_createForOfIteratorHelperLoose","done","_ret","numExtraneousParams","createMatcher","pathDefs","queryParamDefCollection","stateParamDefCollection","defaultParams","paramName","param","_ref2","routerLocation","queryStringSerializer","path","pathMatch","index","match","primaryPath","pathDef","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","_pathSegmentDef$named","pathSegmentDef","pathSegment","namedParamDef","trailing","leading","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","Math","max","getPathMatch","queryMatch","query","getQueryMatch","stateMatch","state","getStateMatch","preventDefaultLinkClickBehavior","event","target","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","preventDefault","buildRoute","routeName","location","routerContext","navigate","href","history","createHref","pathname","fullPath","search","baseUrl","route","link","onClick","push","action","replace","createRouteBuilder","routeDef","getRouterContext","pathParamDefCollection","getRawPath","namedPathParamDefs","paramIdCollection","rawPath","rawPathSegments","usedPathParams","_step2","rawSegment","includedParamDef","_iterator2","indexOf","_rawSegment$split","filter","build","paramsWithDefault","paramCollection","paramValue","getValue","valueSerializerId","id","_ref3","reduce","key","_extends2","createLocation","defineProperty","Route","createQueryStringSerializer","args","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","rest","encodedName","getMatchingRoute","routes","getRoutes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","splitFirst","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","handler","splice","getHandlers","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sort","createRouter","_len","_key","arguments","unlisten","_parseArgs","parseArgs","opts","navigationHandlerManager","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","route_current","createRouteBuilderCollection","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","retry","findIndex","item","getRoute","router","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","JSON","hash","createForwardingProxy","_params$accessBeforeS","accessBeforeSetErrorMessage","checkSet","Error","proxy","Proxy","isFunction","get","_t","prop","receiver","Reflect","set","has","deleteProperty","ownKeys","getOwnPropertyDescriptor","descriptor","getPrototypeOf","setPrototypeOf","proto","isExtensible","preventExtensions","apply","thisArg","construct","newTarget","updateTarget","boolean","number","isNaN","parseFloat","test","toString","string","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","~internal","default","ofType","internal","createGroup_fromItems","groupItems","routeNames","fpRoutes","fpSession","fpRouteProvider","fpUseRoute","fpGetRoute","arg","core","coreCreateRouter","group","values","_coreCreateRouter","routeContext","React","RouteProvider","props","_React$useState","setRoute","Provider","children","useRoute","defineRoute","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","x","parentPathArray","childPathArray","concat","parentPath","childPath","allowedKeys","filteredX"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/type-route/dist/type-route.esm.js b/node_modules/type-route/dist/type-route.esm.js
index 3517dec..f8ecffa 100644
--- a/node_modules/type-route/dist/type-route.esm.js
+++ b/node_modules/type-route/dist/type-route.esm.js
@@ -1268,95 +1268,113 @@ function createRouter() {
   var blockerCollection = [];
   applySessionOpts(opts.session);
   var routes = createRouteBuilderCollection(getRouterContext);
-  var router = {
-    routes: routes,
-    session: {
-      push: function push(href, state) {
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].push", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
-        }
-        var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),
-          route = _getRouteByHref.route,
-          primaryPath = _getRouteByHref.primaryPath;
-        return navigate(_extends({}, route, {
-          action: "push"
-        }), primaryPath);
-      },
-      replace: function replace(href, state) {
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].replace", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
-        }
-        var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),
-          route = _getRouteByHref2.route,
-          primaryPath = _getRouteByHref2.primaryPath;
-        return navigate(_extends({}, route, {
-          action: "replace"
-        }), primaryPath);
-      },
-      back: function back(amount) {
-        if (amount === void 0) {
-          amount = 1;
-        }
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].back", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
-        }
-        history.go(-amount);
-      },
-      forward: function forward(amount) {
-        if (amount === void 0) {
-          amount = 1;
-        }
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].forward", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
-        }
-        history.go(amount);
-      },
-      getInitialRoute: function getInitialRoute() {
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].getInitialRoute", [assert.numArgs([].slice.call(arguments), 0)]);
-        }
-        if (!initialRoute) {
-          var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());
-          if (!result.primaryPath) {
-            skipHandlingNextApplicationTriggeredNavigation = true;
-            result.route.replace();
-            result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());
-          }
-          initialRoute = result.route;
-        }
-        return initialRoute;
-      },
-      reset: function reset(session) {
-        if (process.env.NODE_ENV !== "production") {
-          assert("[RouterSessionHistory].reset", [assert.numArgs([].slice.call(arguments), 1), assert.type("object", "session", session)]);
+  var session = {
+    push: function push(href, state) {
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].push", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
+      }
+      var _getRouteByHref = getRouteByHref(href, state, getRouterContext()),
+        route = _getRouteByHref.route,
+        primaryPath = _getRouteByHref.primaryPath;
+      return navigate(_extends({}, route, {
+        action: "push"
+      }), primaryPath);
+    },
+    replace: function replace(href, state) {
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].replace", [assert.numArgs([].slice.call(arguments), 1, 2), assert.type("string", "href", href), assert.type(["object", "undefined"], "state", state)]);
+      }
+      var _getRouteByHref2 = getRouteByHref(href, state, getRouterContext()),
+        route = _getRouteByHref2.route,
+        primaryPath = _getRouteByHref2.primaryPath;
+      return navigate(_extends({}, route, {
+        action: "replace"
+      }), primaryPath);
+    },
+    back: function back(amount) {
+      if (amount === void 0) {
+        amount = 1;
+      }
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].back", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
+      }
+      history.go(-amount);
+    },
+    forward: function forward(amount) {
+      if (amount === void 0) {
+        amount = 1;
+      }
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].forward", [assert.numArgs([].slice.call(arguments), 0, 1), assert.type("number", "amount", amount)]);
+      }
+      history.go(amount);
+    },
+    getInitialRoute: function getInitialRoute() {
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].getInitialRoute", [assert.numArgs([].slice.call(arguments), 0)]);
+      }
+      if (!initialRoute) {
+        var result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());
+        if (!result.primaryPath) {
+          skipHandlingNextApplicationTriggeredNavigation = true;
+          result.route.replace();
+          result = getMatchingRoute(convertToRouterLocationFromHistoryLocation(history.location, baseUrl), getRouterContext());
         }
-        return applySessionOpts(session);
-      },
-      block: function block(blocker) {
-        blockerCollection.push(blocker);
-        var unblock = history.block(function (update) {
-          var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),
-            route = _getMatchingRoute2.route;
-          var action = update.action.toLowerCase();
-          blocker({
-            route: _extends({}, route, {
-              action: action
-            }),
-            retry: update.retry
-          });
-        });
-        return function () {
-          blockerCollection.splice(blockerCollection.findIndex(function (item) {
-            return item === blocker;
-          }), 1);
-          unblock();
-        };
-      },
-      listen: function listen(handler) {
-        return navigationHandlerManager.add(handler);
+        initialRoute = result.route;
+      }
+      return initialRoute;
+    },
+    reset: function reset(session) {
+      if (process.env.NODE_ENV !== "production") {
+        assert("[RouterSessionHistory].reset", [assert.numArgs([].slice.call(arguments), 1), assert.type("object", "session", session)]);
       }
+      return applySessionOpts(session);
+    },
+    block: function block(blocker) {
+      blockerCollection.push(blocker);
+      var unblock = history.block(function (update) {
+        var _getMatchingRoute2 = getMatchingRoute(convertToRouterLocationFromHistoryLocation(update.location, baseUrl), getRouterContext()),
+          route = _getMatchingRoute2.route;
+        var action = update.action.toLowerCase();
+        blocker({
+          route: _extends({}, route, {
+            action: action
+          }),
+          retry: update.retry
+        });
+      });
+      return function () {
+        blockerCollection.splice(blockerCollection.findIndex(function (item) {
+          return item === blocker;
+        }), 1);
+        unblock();
+      };
+    },
+    listen: function listen(handler) {
+      return navigationHandlerManager.add(handler);
     }
   };
+  var _ref = function () {
+      var route_current = session.getInitialRoute();
+      session.listen(function (route) {
+        return route_current = route;
+      });
+      function getRoute() {
+        return route_current;
+      }
+      return {
+        getRoute: getRoute
+      };
+    }(),
+    getRoute = _ref.getRoute;
+  var router = {
+    routes: routes,
+    session: session,
+    stopListening: function stopListening() {
+      return unlisten == null ? void 0 : unlisten();
+    },
+    getRoute: getRoute
+  };
   return router;
   function applySessionOpts(sessionOpts) {
     if (sessionOpts === void 0) {
@@ -1476,6 +1494,84 @@ function createRouteBuilderCollection(getRouterContext) {
   return routes;
 }
 
+/**
+ * Creates a proxy that forwards EVERYTHING to the current target.
+ * The proxy has a stable identity, and you can update the target at runtime.
+ */
+function createForwardingProxy(params) {
+  var _params$accessBeforeS = params.accessBeforeSetErrorMessage,
+    accessBeforeSetErrorMessage = _params$accessBeforeS === void 0 ? "Assertion error: Forwarded proxy accessed too early" : _params$accessBeforeS,
+    isFunction = params.isFunction;
+  var checkSet = function checkSet() {
+    if (target === undefined) {
+      throw new Error(accessBeforeSetErrorMessage);
+    }
+  };
+  var target = undefined;
+  var handler = {
+    get: function get(_t, prop, receiver) {
+      checkSet();
+      return Reflect.get(target, prop, receiver);
+    },
+    set: function set(_t, prop, value, receiver) {
+      checkSet();
+      return Reflect.set(target, prop, value, receiver);
+    },
+    has: function has(_t, prop) {
+      checkSet();
+      return Reflect.has(target, prop);
+    },
+    deleteProperty: function deleteProperty(_t, prop) {
+      checkSet();
+      return Reflect.deleteProperty(target, prop);
+    },
+    ownKeys: function ownKeys(_t) {
+      checkSet();
+      return Reflect.ownKeys(target);
+    },
+    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(_t, prop) {
+      checkSet();
+      return Reflect.getOwnPropertyDescriptor(target, prop);
+    },
+    defineProperty: function defineProperty(_t, prop, descriptor) {
+      checkSet();
+      return Reflect.defineProperty(target, prop, descriptor);
+    },
+    getPrototypeOf: function getPrototypeOf(_t) {
+      checkSet();
+      return Reflect.getPrototypeOf(target);
+    },
+    setPrototypeOf: function setPrototypeOf(_t, proto) {
+      checkSet();
+      return Reflect.setPrototypeOf(target, proto);
+    },
+    isExtensible: function isExtensible(_t) {
+      checkSet();
+      return Reflect.isExtensible(target);
+    },
+    preventExtensions: function preventExtensions(_t) {
+      checkSet();
+      return Reflect.preventExtensions(target);
+    },
+    apply: function apply(_t, thisArg, args) {
+      checkSet();
+      return Reflect.apply(target, thisArg, args);
+    },
+    construct: function construct(_t, args, newTarget) {
+      checkSet();
+      return Reflect.construct(target, args, newTarget);
+    }
+  };
+  // Use a dummy callable so proxy can stand in for both functions and objects
+  var proxy = new Proxy(isFunction ? function () {} : {}, handler);
+  return {
+    proxy: proxy,
+    updateTarget: function updateTarget(newTarget) {
+      target = newTarget;
+    }
+  };
+}
+
 function defineRoute() {
   for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
     args[_key] = arguments[_key];
@@ -1699,7 +1795,7 @@ function getParamDefKindSection(kind, trailing) {
   }
 }
 
-function createGroup(groupItems) {
+function createGroup_fromItems(groupItems) {
   if (process.env.NODE_ENV !== "production") {
     assert("createGroup", [assert.numArgs([].slice.call(arguments), 1), assert.arrayOfType(["RouteGroup", "RouteBuilder"], "groupItems", groupItems)]);
   }
@@ -1733,6 +1829,15 @@ function createGroup(groupItems) {
 function isRouteGroup(value) {
   return !!value.routeNames;
 }
+function createGroup_fromRouteDefs(routeDefs) {
+  var core = createRouter(routeDefs);
+  var group = createGroup_fromItems(Object.values(core.routes));
+  core.stopListening();
+  return group;
+}
+function createGroup(arg) {
+  return arg instanceof Array ? createGroup_fromItems(arg) : createGroup_fromRouteDefs(arg);
+}
 
 if (typeof (process.env.NODE_ENV !== "production") === "boolean" && process.env.NODE_ENV !== "production") {
   var _React$version$split$ = /*#__PURE__*/version.split(".").map(function (value) {
@@ -1744,6 +1849,21 @@ if (typeof (process.env.NODE_ENV !== "production") === "boolean" && process.env.
     throw TypeRouteError.Invalid_React_version.create(version);
   }
 }
+var fpRoutes = /*#__PURE__*/createForwardingProxy({
+  isFunction: false
+});
+var fpSession = /*#__PURE__*/createForwardingProxy({
+  isFunction: false
+});
+var fpRouteProvider = /*#__PURE__*/createForwardingProxy({
+  isFunction: true
+});
+var fpUseRoute = /*#__PURE__*/createForwardingProxy({
+  isFunction: true
+});
+var fpGetRoute = /*#__PURE__*/createForwardingProxy({
+  isFunction: true
+});
 function createRouter$1() {
   for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
     args[_key] = arguments[_key];
@@ -1751,20 +1871,19 @@ function createRouter$1() {
   var _parseArgs = parseArgs(args),
     opts = _parseArgs.opts,
     routeDefs = _parseArgs.routeDefs;
-  var router = createRouter(_extends({}, opts, {
-    scrollToTop: false
-  }), routeDefs);
+  var _coreCreateRouter = createRouter(_extends({}, opts, {
+      scrollToTop: false
+    }), routeDefs),
+    routes = _coreCreateRouter.routes,
+    session = _coreCreateRouter.session,
+    getRoute = _coreCreateRouter.getRoute;
   var routeContext = createContext(null);
-  return _extends({}, router, {
-    RouteProvider: RouteProvider,
-    useRoute: useRoute
-  });
   function RouteProvider(props) {
-    var _React$useState = useState(router.session.getInitialRoute()),
+    var _React$useState = useState(session.getInitialRoute()),
       route = _React$useState[0],
       setRoute = _React$useState[1];
     useLayoutEffect(function () {
-      return router.session.listen(setRoute);
+      return session.listen(setRoute);
     }, []);
     useEffect(function () {
       attemptScrollToTop(route, opts.scrollToTop);
@@ -1782,7 +1901,19 @@ function createRouter$1() {
     }
     return route;
   }
+  fpRoutes.updateTarget(routes);
+  fpSession.updateTarget(session);
+  fpRouteProvider.updateTarget(RouteProvider);
+  fpUseRoute.updateTarget(useRoute);
+  fpGetRoute.updateTarget(getRoute);
+  return {
+    routes: fpRoutes.proxy,
+    session: fpSession.proxy,
+    RouteProvider: fpRouteProvider.proxy,
+    useRoute: fpUseRoute.proxy,
+    getRoute: fpGetRoute.proxy
+  };
 }
 
-export { createGroup, createRouter$1 as createRouter, defineRoute, noMatch, param, preventDefaultLinkClickBehavior };
+export { createRouter as coreCreateRouter, createGroup, createRouter$1 as createRouter, defineRoute, noMatch, param, preventDefaultLinkClickBehavior };
 //# sourceMappingURL=type-route.esm.js.map
diff --git a/node_modules/type-route/dist/type-route.esm.js.map b/node_modules/type-route/dist/type-route.esm.js.map
index 83ac7b9..7b35157 100644
--- a/node_modules/type-route/dist/type-route.esm.js.map
+++ b/node_modules/type-route/dist/type-route.esm.js.map
@@ -1 +1 @@
-{"version":3,"file":"type-route.esm.js","sources":["../src/typeOf.ts","../src/TypeRouteError.ts","../src/asArray.ts","../src/assert.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/getStateMatch.ts","../src/getQueryMatch.ts","../src/createMatcher.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts","../src/react.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  App_should_be_wrapped_in_a_RouteProvider_component: {\n    errorCode: 1020,\n    getDetails() {\n      return [\n        \"Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook.\",\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session: {\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n    },\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n","import {\n  CoreRouter,\n  UmbrellaRouteDefCollection,\n  UmbrellaRoute,\n  RouteDefCollectionRoute,\n  RouterOpts,\n} from \"./types\";\nimport { createRouter as coreCreateRouter, parseArgs } from \"./createRouter\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport * as React from \"react\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\n\nif (typeof __DEV__ === \"boolean\" && __DEV__) {\n  const [major, minor] = React.version\n    .split(\".\")\n    .map((value: string) => parseInt(value, 10));\n\n  if (major < 16 || (major === 16 && minor < 8)) {\n    throw TypeRouteError.Invalid_React_version.create(React.version);\n  }\n}\n\nexport { defineRoute } from \"./defineRoute\";\nexport { param } from \"./param\";\nexport { createGroup } from \"./createGroup\";\nexport { noMatch } from \"./noMatch\";\nexport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nexport {\n  GetRoute as Route,\n  Link,\n  ValueSerializer,\n  QueryStringSerializer,\n  SessionOpts,\n  RouterOpts,\n} from \"./types\";\n\ntype Router<TRouteDefCollection extends { [routeName: string]: any }> =\n  CoreRouter<TRouteDefCollection> & {\n    /**\n     * React hook for retrieving the current route.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/use-route\n     */\n    useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;\n\n    /**\n     * React component which connects React to Type Route and provides the current route to the rest of the application.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/route-provider\n     */\n    RouteProvider: (props: { children?: any }) => any;\n  };\ntype UmbrellaRouter = Router<UmbrellaRouteDefCollection>;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): Router<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaRouter {\n  const { opts, routeDefs } = parseArgs(args);\n  const router = coreCreateRouter({ ...opts, scrollToTop: false }, routeDefs);\n  const routeContext = React.createContext<UmbrellaRoute | null>(null);\n\n  return {\n    ...router,\n    RouteProvider,\n    useRoute,\n  };\n\n  function RouteProvider(props: { children?: any }) {\n    const [route, setRoute] = React.useState(router.session.getInitialRoute());\n\n    React.useLayoutEffect(() => router.session.listen(setRoute), []);\n\n    React.useEffect(() => {\n      attemptScrollToTop(route, opts.scrollToTop);\n    }, [route]);\n\n    return React.createElement(\n      routeContext.Provider,\n      { value: route },\n      props.children\n    );\n  }\n\n  function useRoute() {\n    const route = React.useContext(routeContext);\n\n    if (__DEV__) {\n      if (route === null) {\n        throw TypeRouteError.App_should_be_wrapped_in_a_RouteProvider_component.create();\n      }\n    }\n\n    return route!;\n  }\n}\n"],"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","App_should_be_wrapped_in_a_RouteProvider_component","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","process","env","NODE_ENV","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","_loop","_paramDef$Internal$v","paramValue","undefined","urlEncodeDefault","urlEncode","valueSerializer","getValue","valueSerializerId","id","_ret","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","router","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","_opts$arrayFormat3","_getRouterContext","defineRoute","assertDefineRouteOrExtendArgs","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup","groupItems","routeNames","isRouteGroup","has","_React$version$split$","React","parseInt","major","minor","coreCreateRouter","routeContext","RouteProvider","useRoute","props","_React$useState","setRoute","Provider","children"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"type-route.esm.js","sources":["../src/typeOf.ts","../src/TypeRouteError.ts","../src/asArray.ts","../src/assert.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/getStateMatch.ts","../src/getQueryMatch.ts","../src/createMatcher.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/tools/createForwardingProxy.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts","../src/react.ts"],"sourcesContent":["export function typeOf(value: any) {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n\n  return typeof value;\n}\n","import { ErrorDef, BuildPathDefErrorContext } from \"./types\";\nimport { typeOf } from \"./typeOf\";\n\nfunction getBuildPathDefRouteNameMessage(routeName: string) {\n  return `This problem occurred when building the route definition for the \"${routeName}\" route.`;\n}\n\nfunction getBuildPathDefErrorMessage(context: BuildPathDefErrorContext) {\n  return [\n    getBuildPathDefRouteNameMessage(context.routeName),\n    `The path was constructed as \\`${context.rawPath}\\``,\n  ];\n}\n\nexport const TypeRouteError = buildErrorCollection({\n  Path_may_not_be_an_empty_string: {\n    errorCode: 1000,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_must_start_with_a_forward_slash: {\n    errorCode: 1001,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_end_with_a_forward_slash: {\n    errorCode: 1002,\n    getDetails: getBuildPathDefErrorMessage,\n  },\n\n  Path_may_not_include_characters_that_must_be_URL_encoded: {\n    errorCode: 1003,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      segment: {\n        leading: string;\n        paramId?: string;\n        trailing?: string;\n      }\n    ) => {\n      const leading = segment.leading;\n      const trailing = segment.trailing ?? \"\";\n      const paramId = segment.paramId ?? \"\";\n\n      const invalidCharacters = (leading + trailing)\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The path segment \\`${\n          leading + paramId + trailing\n        }\\` has the following invalid characters: ${invalidCharacters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_may_not_include_empty_segments: {\n    errorCode: 1004,\n    getDetails: (context: BuildPathDefErrorContext) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        \"Empty segments can be spotted by finding the place in the path with two consecutive forward slashes '//'.\",\n      ];\n    },\n  },\n\n  Path_may_have_at_most_one_parameter_per_segment: {\n    errorCode: 1005,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterNames: string[]\n    ) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `A single segment of the path included the following parameters: ${parameterNames}`,\n        \"Consider using ofType with a customer ValueSerializer for this scenario.\",\n      ];\n    },\n  },\n\n  Path_parameters_may_not_be_used_more_than_once_when_building_a_path: {\n    errorCode: 1005,\n    getDetails: (context: BuildPathDefErrorContext, parameterName: string) => {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The parameter \"${parameterName}\" was used more than once.`,\n      ];\n    },\n  },\n\n  Optional_path_parameters_may_not_have_any_text_around_the_parameter: {\n    errorCode: 1006,\n    getDetails: (\n      context: BuildPathDefErrorContext,\n      parameterName: string,\n      leadingText: string,\n      trailingText: string\n    ) => {\n      const messages = getBuildPathDefErrorMessage(context);\n\n      if (leadingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be preceded by \"${leadingText}\".`\n        );\n      }\n\n      if (trailingText) {\n        messages.push(\n          `The parameter \"${parameterName}\" cannot be followed by \"${trailingText}\".`\n        );\n      }\n\n      return messages;\n    },\n  },\n\n  Path_may_have_at_most_one_optional_or_trailing_parameter: {\n    errorCode: 1007,\n    getDetails(\n      context: BuildPathDefErrorContext,\n      numOptionalTrailingParameterNames: number\n    ) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `At most one optional/trailing parameter should be given but ${numOptionalTrailingParameterNames} were provided.`,\n      ];\n    },\n  },\n\n  Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment:\n    {\n      errorCode: 1008,\n      getDetails: getBuildPathDefErrorMessage,\n    },\n\n  All_path_parameters_must_be_used_in_path_construction: {\n    errorCode: 1009,\n    getDetails(context: BuildPathDefErrorContext, unusedParameters: string[]) {\n      return [\n        ...getBuildPathDefErrorMessage(context),\n        `The following parameters were not used: ${unusedParameters.join(\n          \", \"\n        )}`,\n      ];\n    },\n  },\n\n  Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character:\n    {\n      errorCode: 1010,\n      getDetails(routeName: string, paramName: string) {\n        return [\n          getBuildPathDefRouteNameMessage(routeName),\n          `The $ { } or / character was used in this parameter name: ${paramName}`,\n        ];\n      },\n    },\n\n  Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names:\n    {\n      errorCode: 1011,\n      getDetails(duplicateParameterNames: string[]) {\n        return [\n          `The following parameter names were used in both the base route definition and the extension: ${duplicateParameterNames.join(\n            \", \"\n          )}`,\n        ];\n      },\n    },\n\n  Expected_type_does_not_match_actual_type: {\n    errorCode: 1012,\n    getDetails({\n      context,\n      value,\n      valueName,\n      expectedType,\n      actualType,\n    }: {\n      context: string;\n      valueName: string;\n      expectedType: string | string[];\n      actualType: string;\n      value: any;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `\\`${valueName}\\` was expected to be of type \\`${\n          Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n        }\\` but was of type \\`${actualType}\\``,\n        `The actual value provided was: ${\n          typeOf(value) === \"object\"\n            ? \"\\n\" +\n              JSON.stringify(value, null, 2)\n                .split(\"\\n\")\n                .map((line) => `  ${line}`)\n                .join(\"\\n\")\n            : \"`\" + value + \"`\"\n        }`,\n      ];\n    },\n  },\n\n  Expected_number_of_arguments_does_match_actual_number: {\n    errorCode: 1013,\n    getDetails({\n      context,\n      args,\n      min,\n      max,\n    }: {\n      context: string;\n      args: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected ${min}${min === max ? \"\" : \" - \" + max} but received ${\n          args.length\n        } argument${args.length === 1 ? \"\" : \"s\"}`,\n      ];\n    },\n  },\n\n  Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided:\n    {\n      errorCode: 1014,\n      getDetails() {\n        return [\n          \"You may not provide both options.arrayFormat.queryString and options.queryStringSerializer. These options are not compatible.\",\n        ];\n      },\n    },\n\n  Expected_length_of_array_does_match_actual_length: {\n    errorCode: 1015,\n    getDetails({\n      context,\n      array,\n      min,\n      max,\n    }: {\n      context: string;\n      array: any[];\n      min: number;\n      max: number;\n    }) {\n      return [\n        `Problem found with your usage of \\`${context}\\``,\n        `Expected array to be of length ${min}${\n          min === max ? \"\" : \" - \" + max\n        } but actual length was ${array.length}`,\n      ];\n    },\n  },\n\n  Encountered_unexpected_parameter_when_building_route: {\n    errorCode: 1016,\n    getDetails({\n      routeName,\n      unexpectedParameterName,\n      allowedParameterNames,\n    }: {\n      routeName: string;\n      unexpectedParameterName: string;\n      allowedParameterNames: string[];\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `Unexpected parameter passed to route builder named \"${unexpectedParameterName}\"`,\n        allowedParameterNames.length === 0\n          ? \"The route does not take any parameters\"\n          : `This route takes the following parameters: ${allowedParameterNames\n              .map((name) => `\"${name}\"`)\n              .join(\", \")}`,\n      ];\n    },\n  },\n\n  Missing_required_parameter_when_building_route: {\n    errorCode: 1017,\n    getDetails({\n      routeName,\n      missingParameterName,\n    }: {\n      routeName: string;\n      missingParameterName: string;\n    }) {\n      return [\n        `Problem found with your usage of routes.${routeName}( ... )`,\n        `The parameter \"${missingParameterName}\" is required but was not provided.`,\n      ];\n    },\n  },\n\n  Base_url_must_start_with_a_forward_slash: {\n    errorCode: 1018,\n    getDetails(baseUrl: string) {\n      return [\n        'Base URL must start with a forward slash \"/\"',\n        `The value you provided \"${baseUrl}\" does not start with a forward slash.`,\n      ];\n    },\n  },\n\n  Base_url_must_not_contain_any_characters_that_must_be_url_encoded: {\n    errorCode: 1019,\n    getDetails(baseUrl: string) {\n      const invalidCharacters = baseUrl\n        .replace(/\\//g, \"\")\n        .split(\"\")\n        .filter((character) => character !== encodeURIComponent(character));\n      return [\n        `The following characters are invalid: ${invalidCharacters.join(\n          \", \"\n        )}.`,\n      ];\n    },\n  },\n\n  App_should_be_wrapped_in_a_RouteProvider_component: {\n    errorCode: 1020,\n    getDetails() {\n      return [\n        \"Your application must be wrapped in the `RouteProvider` component returned by `createRouter` in order to use the `useRoute` hook.\",\n      ];\n    },\n  },\n\n  Invalid_React_version: {\n    errorCode: 1021,\n    getDetails(version: string) {\n      return [\n        \"React version must be 16.8 or greater.\",\n        `You have version ${version} installed.`,\n        \"If you cannot upgrade the React version try using `type-route/core`.\",\n      ];\n    },\n  },\n});\n\nfunction buildErrorCollection<\n  TErrorDefCollection extends Record<string, ErrorDef>\n>(definitions: TErrorDefCollection) {\n  const errors: Record<\n    string,\n    {\n      name: string;\n      errorCode: number;\n      create(...args: any[]): Error;\n    }\n  > = {};\n\n  Object.keys(definitions).forEach((key) => {\n    const name = key.replace(/_/g, \" \") + \".\";\n    const { errorCode, getDetails } = definitions[key];\n    const messageTitle = `TR${errorCode} · ${name}`;\n\n    errors[key] = {\n      errorCode,\n      name,\n      create(...args: any[]) {\n        const message = (getDetails?.(...args) ?? [])\n          .map((detail) => `- ${detail}`)\n          .join(\"\\n\");\n\n        const error = new Error(\n          message\n            ? `\\n\\n${messageTitle}\\n\\n${message}\\n`\n            : `\\n\\n${messageTitle}\\n`\n        );\n        error.name = `(hopefully helpful 😄) TypeRouteError`;\n\n        return error;\n      },\n    };\n  });\n\n  return errors as {\n    [TName in keyof TErrorDefCollection]: {\n      create(\n        ...args: Parameters<TErrorDefCollection[TName][\"getDetails\"]>\n      ): Error;\n      name: TName;\n      errorCode: TErrorDefCollection[TName][\"errorCode\"];\n    };\n  };\n}\n","export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\nexport function assert(\n  context: string,\n  assertions: ((context: string) => void)[]\n) {\n  assertions.forEach((assert) => assert(context));\n}\n\nassert.arrayLength =\n  (array: any[], min: number, max = min) =>\n  (context: string) => {\n    if (array.length < min || array.length > max) {\n      throw TypeRouteError.Expected_length_of_array_does_match_actual_length.create(\n        {\n          context,\n          array,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.numArgs =\n  (args: any[], min: number, max = min) =>\n  (context: string) => {\n    if (args.length < min || args.length > max) {\n      throw TypeRouteError.Expected_number_of_arguments_does_match_actual_number.create(\n        {\n          context,\n          args,\n          min,\n          max,\n        }\n      );\n    }\n  };\n\nassert.collectionOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (typeOf(value) === \"object\") {\n      const valuePropertyNames = Object.keys(value);\n\n      for (const propertyName of valuePropertyNames) {\n        assert.type(\n          expectedType,\n          `${valueName}.${propertyName}`,\n          value[propertyName]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Record<string, ${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.arrayOfType =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        assert.type(\n          expectedType,\n          `${valueName}[${index}]`,\n          value[index]\n        )(context);\n      }\n\n      return;\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType: `Array<${\n        Array.isArray(expectedType) ? expectedType.join(\" | \") : expectedType\n      }>`,\n      value,\n      valueName,\n    });\n  };\n\nassert.type =\n  (expectedType: string | string[], valueName: string, value: any) =>\n  (context: string) => {\n    const expectedTypeList =\n      typeof expectedType === \"string\" ? [expectedType] : expectedType;\n\n    for (const expectedType of expectedTypeList) {\n      const expectsProperType =\n        expectedType[0].toUpperCase() === expectedType[0];\n\n      if (\n        (expectsProperType &&\n          (typeOf(value) === \"object\" || typeOf(value) === \"function\") &&\n          typeOf(value[\"~internal\"]) === \"object\" &&\n          value[\"~internal\"].type === expectedType) ||\n        (!expectsProperType && typeOf(value) === expectedType)\n      ) {\n        return;\n      }\n    }\n\n    throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n      context,\n      actualType: typeOf(value),\n      expectedType,\n      value,\n      valueName,\n    });\n  };\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const session: UmbrellaCoreRouter[\"session\"] = {\n\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n\n  };\n\n  const { getRoute } = (() => {\n    let route_current = session.getInitialRoute();\n\n    session.listen(route => (route_current = route));\n\n    function getRoute() {\n        return route_current;\n    }\n\n    return { getRoute };\n  })();\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session,\n    stopListening: ()=> unlisten?.(),\n    getRoute\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","/**\n * Creates a proxy that forwards EVERYTHING to the current target.\n * The proxy has a stable identity, and you can update the target at runtime.\n */\nexport function createForwardingProxy<T extends object>(params: {\n  accessBeforeSetErrorMessage?: string;\n  isFunction: boolean;\n}) {\n  const { accessBeforeSetErrorMessage = \"Assertion error: Forwarded proxy accessed too early\", isFunction } =\n    params;\n\n  const checkSet = () => {\n    if (target === undefined) {\n      throw new Error(accessBeforeSetErrorMessage);\n    }\n  };\n\n  let target: any = undefined;\n\n  const handler: ProxyHandler<any> = {\n    get(_t, prop, receiver) {\n      checkSet();\n      return Reflect.get(target, prop, receiver);\n    },\n    set(_t, prop, value, receiver) {\n      checkSet();\n      return Reflect.set(target, prop, value, receiver);\n    },\n    has(_t, prop) {\n      checkSet();\n      return Reflect.has(target, prop);\n    },\n    deleteProperty(_t, prop) {\n      checkSet();\n      return Reflect.deleteProperty(target, prop);\n    },\n    ownKeys(_t) {\n      checkSet();\n      return Reflect.ownKeys(target);\n    },\n    getOwnPropertyDescriptor(_t, prop) {\n      checkSet();\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    },\n    defineProperty(_t, prop, descriptor) {\n      checkSet();\n      return Reflect.defineProperty(target, prop, descriptor);\n    },\n    getPrototypeOf(_t) {\n      checkSet();\n      return Reflect.getPrototypeOf(target);\n    },\n    setPrototypeOf(_t, proto) {\n      checkSet();\n      return Reflect.setPrototypeOf(target, proto);\n    },\n    isExtensible(_t) {\n      checkSet();\n      return Reflect.isExtensible(target);\n    },\n    preventExtensions(_t) {\n      checkSet();\n      return Reflect.preventExtensions(target);\n    },\n    apply(_t, thisArg, args) {\n      checkSet();\n      return Reflect.apply(target, thisArg, args);\n    },\n    construct(_t, args, newTarget) {\n      checkSet();\n      return Reflect.construct(target, args, newTarget);\n    },\n  };\n\n  // Use a dummy callable so proxy can stand in for both functions and objects\n  const proxy = new Proxy(isFunction ? (function (){}) : {}, handler) as T;\n\n  return {\n    proxy,\n    updateTarget(newTarget: T) {\n      target = newTarget;\n    },\n  };\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder, CoreRouter } from \"./types\";\nimport { assert } from \"./assert\";\nimport { createRouter as coreCreateRouter } from \"./createRouter\";\n\nfunction createGroup_fromItems<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n\nexport function createGroup_fromRouteDefs<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n> {\n  const core = coreCreateRouter(routeDefs);\n\n  const group= createGroup_fromItems(\n    Object.values(core.routes)\n  );\n\n  core.stopListening();\n\n  return group;\n}\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;\nexport function createGroup<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  routeDefs: TRouteDefCollection\n): RouteGroup<\n  CoreRouter<TRouteDefCollection>[\"routes\"][keyof TRouteDefCollection][]\n>;\nexport function createGroup(\n  arg: any[] | Record<string, unknown>\n): RouteGroup<any> {\n  return arg instanceof Array\n    ? createGroup_fromItems(arg)\n    : createGroup_fromRouteDefs(arg);\n}\n\n\n","import {\n  CoreRouter,\n  UmbrellaRouteDefCollection,\n  UmbrellaRoute,\n  RouteDefCollectionRoute,\n  RouterOpts,\n} from \"./types\";\nimport { createRouter as coreCreateRouter, parseArgs } from \"./createRouter\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport * as React from \"react\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { createForwardingProxy } from \"./tools/createForwardingProxy\";\n\nimport * as types from \"./types\";\n\nexport type { types };\nexport { coreCreateRouter };\n\nif (typeof __DEV__ === \"boolean\" && __DEV__) {\n  const [major, minor] = React.version\n    .split(\".\")\n    .map((value: string) => parseInt(value, 10));\n\n  if (major < 16 || (major === 16 && minor < 8)) {\n    throw TypeRouteError.Invalid_React_version.create(React.version);\n  }\n}\n\nexport { defineRoute } from \"./defineRoute\";\nexport { param } from \"./param\";\nexport { createGroup } from \"./createGroup\";\nexport { noMatch } from \"./noMatch\";\nexport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nexport {\n  GetRoute as Route,\n  Link,\n  ValueSerializer,\n  QueryStringSerializer,\n  SessionOpts,\n  RouterOpts,\n} from \"./types\";\n\ntype Router<TRouteDefCollection extends { [routeName: string]: any }> =\n  Omit<CoreRouter<TRouteDefCollection>, \"stopListening\"> & {\n    /**\n     * React hook for retrieving the current route.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/use-route\n     */\n    useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;\n\n    /**\n     * Get current route synchronously outside of react.\n     */\n    getRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;\n\n    /**\n     * React component which connects React to Type Route and provides the current route to the rest of the application.\n     *\n     * @see https://type-route.zilch.dev/api-reference/router/route-provider\n     */\n    RouteProvider: (props: { children?: any }) => any;\n  };\ntype UmbrellaRouter = Router<UmbrellaRouteDefCollection>;\n\nconst fpRoutes = createForwardingProxy<UmbrellaRouter[\"routes\"]>({\n  isFunction: false\n});\nconst fpSession = createForwardingProxy<UmbrellaRouter[\"session\"]>({\n  isFunction: false\n});\nconst fpRouteProvider = createForwardingProxy<UmbrellaRouter[\"RouteProvider\"]>({\n  isFunction: true\n});\nconst fpUseRoute = createForwardingProxy<UmbrellaRouter[\"useRoute\"]>({\n  isFunction: true\n});\nconst fpGetRoute = createForwardingProxy<UmbrellaRouter[\"getRoute\"]>({\n  isFunction: true\n});\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): Router<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaRouter {\n  const { opts, routeDefs } = parseArgs(args);\n  const { routes, session, getRoute } = coreCreateRouter({ ...opts, scrollToTop: false }, routeDefs);\n  const routeContext = React.createContext<UmbrellaRoute | null>(null);\n\n  function RouteProvider(props: { children?: any }) {\n    const [route, setRoute] = React.useState(session.getInitialRoute());\n\n    React.useLayoutEffect(() => session.listen(setRoute), []);\n\n    React.useEffect(() => {\n      attemptScrollToTop(route, opts.scrollToTop);\n    }, [route]);\n\n    return React.createElement(\n      routeContext.Provider,\n      { value: route },\n      props.children\n    );\n  }\n\n  function useRoute() {\n    const route = React.useContext(routeContext);\n\n    if (__DEV__) {\n      if (route === null) {\n        throw TypeRouteError.App_should_be_wrapped_in_a_RouteProvider_component.create();\n      }\n    }\n\n    return route!;\n  }\n\n  fpRoutes.updateTarget(routes);\n  fpSession.updateTarget(session);\n  fpRouteProvider.updateTarget(RouteProvider);\n  fpUseRoute.updateTarget(useRoute);\n  fpGetRoute.updateTarget(getRoute);\n\n  return {\n    routes: fpRoutes.proxy,\n    session: fpSession.proxy,\n    RouteProvider: fpRouteProvider.proxy,\n    useRoute: fpUseRoute.proxy,\n    getRoute: fpGetRoute.proxy\n  };\n\n}\n"],"names":["typeOf","value","Array","isArray","getBuildPathDefRouteNameMessage","routeName","getBuildPathDefErrorMessage","context","rawPath","TypeRouteError","buildErrorCollection","Path_may_not_be_an_empty_string","errorCode","getDetails","Path_must_start_with_a_forward_slash","Path_may_not_end_with_a_forward_slash","Path_may_not_include_characters_that_must_be_URL_encoded","segment","leading","trailing","_segment$trailing","paramId","_segment$paramId","invalidCharacters","split","filter","character","encodeURIComponent","concat","join","Path_may_not_include_empty_segments","Path_may_have_at_most_one_parameter_per_segment","parameterNames","Path_parameters_may_not_be_used_more_than_once_when_building_a_path","parameterName","Optional_path_parameters_may_not_have_any_text_around_the_parameter","leadingText","trailingText","messages","push","Path_may_have_at_most_one_optional_or_trailing_parameter","numOptionalTrailingParameterNames","Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment","All_path_parameters_must_be_used_in_path_construction","unusedParameters","Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character","paramName","Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names","duplicateParameterNames","Expected_type_does_not_match_actual_type","_ref","valueName","expectedType","actualType","JSON","stringify","map","line","Expected_number_of_arguments_does_match_actual_number","_ref2","args","min","max","length","Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided","Expected_length_of_array_does_match_actual_length","_ref3","array","Encountered_unexpected_parameter_when_building_route","_ref4","unexpectedParameterName","allowedParameterNames","name","Missing_required_parameter_when_building_route","_ref5","missingParameterName","Base_url_must_start_with_a_forward_slash","baseUrl","Base_url_must_not_contain_any_characters_that_must_be_url_encoded","replace","App_should_be_wrapped_in_a_RouteProvider_component","Invalid_React_version","version","definitions","errors","Object","keys","forEach","key","_definitions$key","messageTitle","create","_len","_key","arguments","message","_getDetails","apply","detail","error","Error","asArray","assert","assertions","arrayLength","numArgs","collectionOfType","valuePropertyNames","_i","_valuePropertyNames","propertyName","type","arrayOfType","index","expectedTypeList","_iterator","_createForOfIteratorHelperLoose","_step","done","expectsProperType","toUpperCase","buildPathDefs","pathParamDefCollection","getRawPath","namedPathParamDefs","namedPathParameterDefinition","_extends","paramIdCollection","process","env","NODE_ENV","indexOf","getParamId","Infinity","errorContext","rawPathSegments","slice","usedPathParams","pathDef","rawSegment","includedParamDef","_iterator2","_step2","paramDef","_rawSegment$split","optional","namedParamDef","numOptionalOrTrailingParams","part","_part$namedParamDef","_part$namedParamDef2","lastPathSegmentParameterDefinition","unusedPathParameterDefinitions","getParamDefsOfType","paramDefCollection","filteredParamDefCollection","kind","createLocation","paramCollection","arraySeparator","queryStringSerializer","pathDefs","params","path","query","state","_loop","_paramDef$Internal$v","paramValue","undefined","urlEncodeDefault","urlEncode","valueSerializer","getValue","valueSerializerId","id","_ret","rawParam","hasQueryParams","reduce","_extends2","fullPath","result","noMatch","__noMatch","stringUtils","startsWith","endsWith","splitFirst","start","i","end","_value$split","first","rest","getPathMatch","match","primaryPath","numExtraneousParams","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","pathSegmentDef","pathSegment","v","numRemainingPathSegmentDefs","_pathSegmentDef$named","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","parse","decodeURIComponent","some","Math","getObjectMatch","object","paramDefs","namedParamDefs","extraneousParams","raw","_paramDef$Internal$v2","getStateMatch","getQueryMatch","createMatcher","queryParamDefCollection","stateParamDefCollection","defaultParams","param","routerLocation","pathMatch","queryMatch","stateMatch","preventDefaultLinkClickBehavior","event","e","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","isSelfTarget","target","defaultPrevented","button","preventDefault","buildRoute","location","routerContext","navigate","history","href","createHref","pathname","search","route","link","onClick","action","createRouteBuilder","routeDef","getRouterContext","build","call","paramKey","paramsWithDefault","defineProperty","Route","createQueryStringSerializer","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","encodedName","valueParts","getMatchingRoute","getRoutes","routes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","getHandlers","handler","remove","splice","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sortedParams","sort","createRouter","_parseArgs","parseArgs","opts","navigationHandlerManager","unlisten","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","createRouteBuilderCollection","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","_getMatchingRoute2","retry","findIndex","item","route_current","getRoute","router","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","hash","_opts$arrayFormat3","_getRouterContext","createForwardingProxy","_params$accessBeforeS","accessBeforeSetErrorMessage","isFunction","checkSet","get","_t","prop","receiver","Reflect","set","has","deleteProperty","ownKeys","getOwnPropertyDescriptor","descriptor","getPrototypeOf","setPrototypeOf","proto","isExtensible","preventExtensions","thisArg","construct","newTarget","proxy","Proxy","updateTarget","defineRoute","assertDefineRouteOrExtendArgs","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","duplicateParamNames","x","parentPathArray","childPathArray","parentPath","childPath","allowedKeys","filteredX","functionName","boolean","number","isNumeric","parseFloat","toString","isNaN","test","string","json","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","internal","_default","createGroup_fromItems","groupItems","routeNames","isRouteGroup","createGroup_fromRouteDefs","core","coreCreateRouter","group","values","createGroup","arg","_React$version$split$","React","parseInt","major","minor","fpRoutes","fpSession","fpRouteProvider","fpUseRoute","fpGetRoute","_coreCreateRouter","routeContext","RouteProvider","props","_React$useState","setRoute","Provider","children","useRoute"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/type-route/src/createGroup.ts b/node_modules/type-route/src/createGroup.ts
index 3234466..e45ecf2 100644
--- a/node_modules/type-route/src/createGroup.ts
+++ b/node_modules/type-route/src/createGroup.ts
@@ -1,7 +1,8 @@
-import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from "./types";
+import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder, CoreRouter } from "./types";
 import { assert } from "./assert";
+import { createRouter as coreCreateRouter } from "./createRouter";
 
-export function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {
+function createGroup_fromItems<T extends any[]>(groupItems: T): RouteGroup<T> {
   if (__DEV__) {
     assert("createGroup", [
       assert.numArgs([].slice.call(arguments), 1),
@@ -53,3 +54,39 @@ function isRouteGroup(
 ): value is RouteGroup {
   return !!(value as RouteGroup).routeNames;
 }
+
+export function createGroup_fromRouteDefs<
+  TRouteDefCollection extends { [routeName: string]: any }
+>(
+  routeDefs: TRouteDefCollection
+): RouteGroup<
+  CoreRouter<TRouteDefCollection>["routes"][keyof TRouteDefCollection][]
+> {
+  const core = coreCreateRouter(routeDefs);
+
+  const group= createGroup_fromItems(
+    Object.values(core.routes)
+  );
+
+  core.stopListening();
+
+  return group;
+}
+
+export function createGroup<T extends any[]>(groupItems: T): RouteGroup<T>;
+export function createGroup<
+  TRouteDefCollection extends { [routeName: string]: any }
+>(
+  routeDefs: TRouteDefCollection
+): RouteGroup<
+  CoreRouter<TRouteDefCollection>["routes"][keyof TRouteDefCollection][]
+>;
+export function createGroup(
+  arg: any[] | Record<string, unknown>
+): RouteGroup<any> {
+  return arg instanceof Array
+    ? createGroup_fromItems(arg)
+    : createGroup_fromRouteDefs(arg);
+}
+
+
diff --git a/node_modules/type-route/src/createRouter.ts b/node_modules/type-route/src/createRouter.ts
index ad0292a..a27a528 100644
--- a/node_modules/type-route/src/createRouter.ts
+++ b/node_modules/type-route/src/createRouter.ts
@@ -87,9 +87,8 @@ export function createRouter(...args: any[]): UmbrellaCoreRouter {
 
   const routes = createRouteBuilderCollection(getRouterContext);
 
-  const router: UmbrellaCoreRouter = {
-    routes,
-    session: {
+  const session: UmbrellaCoreRouter["session"] = {
+
       push(href, state) {
         if (__DEV__) {
           assert("[RouterSessionHistory].push", [
@@ -213,7 +212,26 @@ export function createRouter(...args: any[]): UmbrellaCoreRouter {
         };
       },
       listen: (handler) => navigationHandlerManager.add(handler),
-    },
+
+  };
+
+  const { getRoute } = (() => {
+    let route_current = session.getInitialRoute();
+
+    session.listen(route => (route_current = route));
+
+    function getRoute() {
+        return route_current;
+    }
+
+    return { getRoute };
+  })();
+
+  const router: UmbrellaCoreRouter = {
+    routes,
+    session,
+    stopListening: ()=> unlisten?.(),
+    getRoute
   };
 
   return router;
diff --git a/node_modules/type-route/src/react.ts b/node_modules/type-route/src/react.ts
index 2682db5..dcd3d8b 100644
--- a/node_modules/type-route/src/react.ts
+++ b/node_modules/type-route/src/react.ts
@@ -9,6 +9,12 @@ import { createRouter as coreCreateRouter, parseArgs } from "./createRouter";
 import { TypeRouteError } from "./TypeRouteError";
 import * as React from "react";
 import { attemptScrollToTop } from "./attemptScrollToTop";
+import { createForwardingProxy } from "./tools/createForwardingProxy";
+
+import * as types from "./types";
+
+export type { types };
+export { coreCreateRouter };
 
 if (typeof __DEV__ === "boolean" && __DEV__) {
   const [major, minor] = React.version
@@ -35,7 +41,7 @@ export {
 } from "./types";
 
 type Router<TRouteDefCollection extends { [routeName: string]: any }> =
-  CoreRouter<TRouteDefCollection> & {
+  Omit<CoreRouter<TRouteDefCollection>, "stopListening"> & {
     /**
      * React hook for retrieving the current route.
      *
@@ -43,6 +49,11 @@ type Router<TRouteDefCollection extends { [routeName: string]: any }> =
      */
     useRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;
 
+    /**
+     * Get current route synchronously outside of react.
+     */
+    getRoute: () => RouteDefCollectionRoute<TRouteDefCollection>;
+
     /**
      * React component which connects React to Type Route and provides the current route to the rest of the application.
      *
@@ -52,6 +63,22 @@ type Router<TRouteDefCollection extends { [routeName: string]: any }> =
   };
 type UmbrellaRouter = Router<UmbrellaRouteDefCollection>;
 
+const fpRoutes = createForwardingProxy<UmbrellaRouter["routes"]>({
+  isFunction: false
+});
+const fpSession = createForwardingProxy<UmbrellaRouter["session"]>({
+  isFunction: false
+});
+const fpRouteProvider = createForwardingProxy<UmbrellaRouter["RouteProvider"]>({
+  isFunction: true
+});
+const fpUseRoute = createForwardingProxy<UmbrellaRouter["useRoute"]>({
+  isFunction: true
+});
+const fpGetRoute = createForwardingProxy<UmbrellaRouter["getRoute"]>({
+  isFunction: true
+});
+
 export function createRouter<
   TRouteDefCollection extends { [routeName: string]: any }
 >(routeDefs: TRouteDefCollection): Router<TRouteDefCollection>;
@@ -63,19 +90,13 @@ export function createRouter<
 ): Router<TRouteDefCollection>;
 export function createRouter(...args: any[]): UmbrellaRouter {
   const { opts, routeDefs } = parseArgs(args);
-  const router = coreCreateRouter({ ...opts, scrollToTop: false }, routeDefs);
+  const { routes, session, getRoute } = coreCreateRouter({ ...opts, scrollToTop: false }, routeDefs);
   const routeContext = React.createContext<UmbrellaRoute | null>(null);
 
-  return {
-    ...router,
-    RouteProvider,
-    useRoute,
-  };
-
   function RouteProvider(props: { children?: any }) {
-    const [route, setRoute] = React.useState(router.session.getInitialRoute());
+    const [route, setRoute] = React.useState(session.getInitialRoute());
 
-    React.useLayoutEffect(() => router.session.listen(setRoute), []);
+    React.useLayoutEffect(() => session.listen(setRoute), []);
 
     React.useEffect(() => {
       attemptScrollToTop(route, opts.scrollToTop);
@@ -99,4 +120,19 @@ export function createRouter(...args: any[]): UmbrellaRouter {
 
     return route!;
   }
+
+  fpRoutes.updateTarget(routes);
+  fpSession.updateTarget(session);
+  fpRouteProvider.updateTarget(RouteProvider);
+  fpUseRoute.updateTarget(useRoute);
+  fpGetRoute.updateTarget(getRoute);
+
+  return {
+    routes: fpRoutes.proxy,
+    session: fpSession.proxy,
+    RouteProvider: fpRouteProvider.proxy,
+    useRoute: fpUseRoute.proxy,
+    getRoute: fpGetRoute.proxy
+  };
+
 }
diff --git a/node_modules/type-route/src/tools/createForwardingProxy.ts b/node_modules/type-route/src/tools/createForwardingProxy.ts
new file mode 100644
index 0000000..4739429
--- /dev/null
+++ b/node_modules/type-route/src/tools/createForwardingProxy.ts
@@ -0,0 +1,84 @@
+/**
+ * Creates a proxy that forwards EVERYTHING to the current target.
+ * The proxy has a stable identity, and you can update the target at runtime.
+ */
+export function createForwardingProxy<T extends object>(params: {
+  accessBeforeSetErrorMessage?: string;
+  isFunction: boolean;
+}) {
+  const { accessBeforeSetErrorMessage = "Assertion error: Forwarded proxy accessed too early", isFunction } =
+    params;
+
+  const checkSet = () => {
+    if (target === undefined) {
+      throw new Error(accessBeforeSetErrorMessage);
+    }
+  };
+
+  let target: any = undefined;
+
+  const handler: ProxyHandler<any> = {
+    get(_t, prop, receiver) {
+      checkSet();
+      return Reflect.get(target, prop, receiver);
+    },
+    set(_t, prop, value, receiver) {
+      checkSet();
+      return Reflect.set(target, prop, value, receiver);
+    },
+    has(_t, prop) {
+      checkSet();
+      return Reflect.has(target, prop);
+    },
+    deleteProperty(_t, prop) {
+      checkSet();
+      return Reflect.deleteProperty(target, prop);
+    },
+    ownKeys(_t) {
+      checkSet();
+      return Reflect.ownKeys(target);
+    },
+    getOwnPropertyDescriptor(_t, prop) {
+      checkSet();
+      return Reflect.getOwnPropertyDescriptor(target, prop);
+    },
+    defineProperty(_t, prop, descriptor) {
+      checkSet();
+      return Reflect.defineProperty(target, prop, descriptor);
+    },
+    getPrototypeOf(_t) {
+      checkSet();
+      return Reflect.getPrototypeOf(target);
+    },
+    setPrototypeOf(_t, proto) {
+      checkSet();
+      return Reflect.setPrototypeOf(target, proto);
+    },
+    isExtensible(_t) {
+      checkSet();
+      return Reflect.isExtensible(target);
+    },
+    preventExtensions(_t) {
+      checkSet();
+      return Reflect.preventExtensions(target);
+    },
+    apply(_t, thisArg, args) {
+      checkSet();
+      return Reflect.apply(target, thisArg, args);
+    },
+    construct(_t, args, newTarget) {
+      checkSet();
+      return Reflect.construct(target, args, newTarget);
+    },
+  };
+
+  // Use a dummy callable so proxy can stand in for both functions and objects
+  const proxy = new Proxy(isFunction ? (function (){}) : {}, handler) as T;
+
+  return {
+    proxy,
+    updateTarget(newTarget: T) {
+      target = newTarget;
+    },
+  };
+}
diff --git a/node_modules/type-route/src/types.ts b/node_modules/type-route/src/types.ts
index d0976f1..e1e126d 100644
--- a/node_modules/type-route/src/types.ts
+++ b/node_modules/type-route/src/types.ts
@@ -570,6 +570,10 @@ export type CoreRouter<
   };
 
   session: RouterSession<TRouteDefCollection>;
+
+  stopListening: ()=> void;
+
+  getRoute: ()=> RouteDefCollectionRoute<TRouteDefCollection>
 };
 
 export type UmbrellaCoreRouter = CoreRouter<UmbrellaRouteDefCollection>;
